"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// node_modules/ini/lib/ini.js
var require_ini = __commonJS({
  "node_modules/ini/lib/ini.js"(exports, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var encode = (obj, opt = {}) => {
      if (typeof opt === "string") {
        opt = { section: opt };
      }
      opt.align = opt.align === true;
      opt.newline = opt.newline === true;
      opt.sort = opt.sort === true;
      opt.whitespace = opt.whitespace === true || opt.align === true;
      opt.platform = opt.platform || typeof process !== "undefined" && process.platform;
      opt.bracketedArray = opt.bracketedArray !== false;
      const eol2 = opt.platform === "win32" ? "\r\n" : "\n";
      const separator = opt.whitespace ? " = " : "=";
      const children = [];
      const keys = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
      let padToChars = 0;
      if (opt.align) {
        padToChars = safe(
          keys.filter((k) => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== "object").map((k) => Array.isArray(obj[k]) ? `${k}[]` : k).concat([""]).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)
        ).length;
      }
      let out = "";
      const arraySuffix = opt.bracketedArray ? "[]" : "";
      for (const k of keys) {
        const val = obj[k];
        if (val && Array.isArray(val)) {
          for (const item of val) {
            out += safe(`${k}${arraySuffix}`).padEnd(padToChars, " ") + separator + safe(item) + eol2;
          }
        } else if (val && typeof val === "object") {
          children.push(k);
        } else {
          out += safe(k).padEnd(padToChars, " ") + separator + safe(val) + eol2;
        }
      }
      if (opt.section && out.length) {
        out = "[" + safe(opt.section) + "]" + (opt.newline ? eol2 + eol2 : eol2) + out;
      }
      for (const k of children) {
        const nk = splitSections(k, ".").join("\\.");
        const section = (opt.section ? opt.section + "." : "") + nk;
        const child = encode(obj[k], {
          ...opt,
          section
        });
        if (out.length && child.length) {
          out += eol2;
        }
        out += child;
      }
      return out;
    };
    function splitSections(str, separator) {
      var lastMatchIndex = 0;
      var lastSeparatorIndex = 0;
      var nextIndex = 0;
      var sections = [];
      do {
        nextIndex = str.indexOf(separator, lastMatchIndex);
        if (nextIndex !== -1) {
          lastMatchIndex = nextIndex + separator.length;
          if (nextIndex > 0 && str[nextIndex - 1] === "\\") {
            continue;
          }
          sections.push(str.slice(lastSeparatorIndex, nextIndex));
          lastSeparatorIndex = nextIndex + separator.length;
        }
      } while (nextIndex !== -1);
      sections.push(str.slice(lastSeparatorIndex));
      return sections;
    }
    var decode = (str, opt = {}) => {
      opt.bracketedArray = opt.bracketedArray !== false;
      const out = /* @__PURE__ */ Object.create(null);
      let p = out;
      let section = null;
      const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
      const lines = str.split(/[\r\n]+/g);
      const duplicates = {};
      for (const line of lines) {
        if (!line || line.match(/^\s*[;#]/) || line.match(/^\s*$/)) {
          continue;
        }
        const match = line.match(re);
        if (!match) {
          continue;
        }
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = /* @__PURE__ */ Object.create(null);
            continue;
          }
          p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
          continue;
        }
        const keyRaw = unsafe(match[2]);
        let isArray;
        if (opt.bracketedArray) {
          isArray = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
        } else {
          duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;
          isArray = duplicates[keyRaw] > 1;
        }
        const key = isArray ? keyRaw.slice(0, -2) : keyRaw;
        if (key === "__proto__") {
          continue;
        }
        const valueRaw = match[3] ? unsafe(match[4]) : true;
        const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
        if (isArray) {
          if (!hasOwnProperty.call(p, key)) {
            p[key] = [];
          } else if (!Array.isArray(p[key])) {
            p[key] = [p[key]];
          }
        }
        if (Array.isArray(p[key])) {
          p[key].push(value);
        } else {
          p[key] = value;
        }
      }
      const remove = [];
      for (const k of Object.keys(out)) {
        if (!hasOwnProperty.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k])) {
          continue;
        }
        const parts = splitSections(k, ".");
        p = out;
        const l = parts.pop();
        const nl = l.replace(/\\\./g, ".");
        for (const part of parts) {
          if (part === "__proto__") {
            continue;
          }
          if (!hasOwnProperty.call(p, part) || typeof p[part] !== "object") {
            p[part] = /* @__PURE__ */ Object.create(null);
          }
          p = p[part];
        }
        if (p === out && nl === l) {
          continue;
        }
        p[nl] = out[k];
        remove.push(k);
      }
      for (const del of remove) {
        delete out[del];
      }
      return out;
    };
    var isQuoted = (val) => {
      return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
    };
    var safe = (val) => {
      if (typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
        return JSON.stringify(val);
      }
      return val.split(";").join("\\;").split("#").join("\\#");
    };
    var unsafe = (val) => {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'") {
          val = val.slice(1, -1);
        }
        try {
          val = JSON.parse(val);
        } catch {
        }
      } else {
        let esc = false;
        let unesc = "";
        for (let i = 0, l = val.length; i < l; i++) {
          const c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1) {
              unesc += c;
            } else {
              unesc += "\\" + c;
            }
            esc = false;
          } else if (";#".indexOf(c) !== -1) {
            break;
          } else if (c === "\\") {
            esc = true;
          } else {
            unesc += c;
          }
        }
        if (esc) {
          unesc += "\\";
        }
        return unesc.trim();
      }
      return val;
    };
    module2.exports = {
      parse: decode,
      decode,
      stringify: encode,
      encode,
      safe,
      unsafe
    };
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (false) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError2 = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError2];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError2] = new RangeError("Max payload size exceeded");
      this[kError2].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError2][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (false) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net3 = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError2 = Symbol("kError");
    var kMessage2 = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event2 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, "target", { enumerable: true });
    Object.defineProperty(Event2.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event2 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent3 = class extends Event2 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError2] = options.error === void 0 ? null : options.error;
        this[kMessage2] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError2];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage2];
      }
    };
    Object.defineProperty(ErrorEvent3.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent3.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event2 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget2 = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler2, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler2 && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler2, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler2, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent3("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler2, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event2("open");
            event[kTarget] = this;
            callListener(handler2, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler2;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler2) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler2 && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent: ErrorEvent3,
      Event: Event2,
      EventTarget: EventTarget2,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse2(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse: parse2 };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var https = require("https");
    var http2 = require("http");
    var net3 = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse2 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket3 = class _WebSocket extends EventEmitter2 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket3, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket3, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket3, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket3, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket3.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket3.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket3.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler2) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler2 !== "function")
            return;
          this.addEventListener(method, handler2, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket3.prototype.addEventListener = addEventListener;
    WebSocket3.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket3;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http2.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location2 = res.headers.location;
        const statusCode = res.statusCode;
        if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location2, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location2}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket3.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse2(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket3.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net3.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net3.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket3.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket3.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket3.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket3.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse2(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse: parse2 };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var http2 = require("http");
    var https = require("https");
    var net3 = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket3 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer3 = class extends EventEmitter2 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket3,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer3;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http2.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket3 = require_websocket();
    WebSocket3.createWebSocketStream = require_stream();
    WebSocket3.Server = require_websocket_server();
    WebSocket3.Receiver = require_receiver();
    WebSocket3.Sender = require_sender();
    WebSocket3.WebSocket = WebSocket3;
    WebSocket3.WebSocketServer = WebSocket3.Server;
    module2.exports = WebSocket3;
  }
});

// packages/php-wasm/node/public/php_8_3.js
var php_8_3_exports = {};
__export(php_8_3_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize,
  dependencyFilename: () => dependencyFilename,
  init: () => init
});
function init(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["hb"];
      updateMemoryViews();
      wasmTable = wasmExports["kb"];
      addOnInit(wasmExports["ib"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  function _SharpYuvConvert() {
    abort("missing function: SharpYuvConvert");
  }
  _SharpYuvConvert.stub = true;
  function _SharpYuvGetConversionMatrix() {
    abort("missing function: SharpYuvGetConversionMatrix");
  }
  _SharpYuvGetConversionMatrix.stub = true;
  function _SharpYuvInit() {
    abort("missing function: SharpYuvInit");
  }
  _SharpYuvInit.stub = true;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  function _getcontext() {
    abort("missing function: getcontext");
  }
  _getcontext.stub = true;
  function _getdtablesize() {
    abort("missing function: getdtablesize");
  }
  _getdtablesize.stub = true;
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  function _makecontext() {
    abort("missing function: makecontext");
  }
  _makecontext.stub = true;
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _swapcontext() {
    abort("missing function: swapcontext");
  }
  _swapcontext.stub = true;
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    gb: _SharpYuvConvert,
    /** @export */
    fb: _SharpYuvGetConversionMatrix,
    /** @export */
    eb: _SharpYuvInit,
    /** @export */
    k: ___assert_fail,
    /** @export */
    db: ___call_sighandler,
    /** @export */
    cb: ___syscall_accept4,
    /** @export */
    bb: ___syscall_bind,
    /** @export */
    ab: ___syscall_chdir,
    /** @export */
    R: ___syscall_chmod,
    /** @export */
    $a: ___syscall_connect,
    /** @export */
    _a: ___syscall_dup,
    /** @export */
    Za: ___syscall_dup3,
    /** @export */
    Ya: ___syscall_faccessat,
    /** @export */
    fa: ___syscall_fallocate,
    /** @export */
    Xa: ___syscall_fchmod,
    /** @export */
    Wa: ___syscall_fchown32,
    /** @export */
    Q: ___syscall_fchownat,
    /** @export */
    n: ___syscall_fcntl64,
    /** @export */
    Va: ___syscall_fdatasync,
    /** @export */
    Ua: ___syscall_fstat64,
    /** @export */
    ma: ___syscall_ftruncate64,
    /** @export */
    Ta: ___syscall_getcwd,
    /** @export */
    Sa: ___syscall_getdents64,
    /** @export */
    Ra: ___syscall_getpeername,
    /** @export */
    Qa: ___syscall_getsockname,
    /** @export */
    Pa: ___syscall_getsockopt,
    /** @export */
    F: ___syscall_ioctl,
    /** @export */
    Oa: ___syscall_listen,
    /** @export */
    Na: ___syscall_lstat64,
    /** @export */
    Ma: ___syscall_mkdirat,
    /** @export */
    La: ___syscall_newfstatat,
    /** @export */
    y: ___syscall_openat,
    /** @export */
    Ka: ___syscall_pipe,
    /** @export */
    Ja: ___syscall_poll,
    /** @export */
    Ia: ___syscall_readlinkat,
    /** @export */
    Ha: ___syscall_recvfrom,
    /** @export */
    Ga: ___syscall_renameat,
    /** @export */
    P: ___syscall_rmdir,
    /** @export */
    Fa: ___syscall_sendto,
    /** @export */
    O: ___syscall_socket,
    /** @export */
    Ea: ___syscall_stat64,
    /** @export */
    Da: ___syscall_statfs64,
    /** @export */
    Ca: ___syscall_symlink,
    /** @export */
    E: ___syscall_unlinkat,
    /** @export */
    Ba: ___syscall_utimensat,
    /** @export */
    wa: __abort_js,
    /** @export */
    va: __emscripten_get_now_is_monotonic,
    /** @export */
    ua: __emscripten_lookup_name,
    /** @export */
    ta: __emscripten_memcpy_js,
    /** @export */
    sa: __emscripten_runtime_keepalive_clear,
    /** @export */
    ra: __emscripten_throw_longjmp,
    /** @export */
    ia: __gmtime_js,
    /** @export */
    ja: __localtime_js,
    /** @export */
    ka: __mktime_js,
    /** @export */
    ga: __mmap_js,
    /** @export */
    ha: __munmap_js,
    /** @export */
    L: __setitimer_js,
    /** @export */
    qa: __tzset_js,
    /** @export */
    C: _emscripten_date_now,
    /** @export */
    pa: _emscripten_get_heap_max,
    /** @export */
    v: _emscripten_get_now,
    /** @export */
    oa: _emscripten_resize_heap,
    /** @export */
    K: _emscripten_sleep,
    /** @export */
    Aa: _environ_get,
    /** @export */
    za: _environ_sizes_get,
    /** @export */
    p: _exit,
    /** @export */
    q: _fd_close,
    /** @export */
    N: _fd_fdstat_get,
    /** @export */
    M: _fd_read,
    /** @export */
    la: _fd_seek,
    /** @export */
    ya: _fd_sync,
    /** @export */
    D: _fd_write,
    /** @export */
    J: _getaddrinfo,
    /** @export */
    ea: _getcontext,
    /** @export */
    da: _getdtablesize,
    /** @export */
    x: _getnameinfo,
    /** @export */
    ca: _getprotobyname,
    /** @export */
    ba: _getprotobynumber,
    /** @export */
    j: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    e: invoke_iiii,
    /** @export */
    i: invoke_iiiii,
    /** @export */
    m: invoke_iiiiii,
    /** @export */
    s: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    I: invoke_iiiiiiiiii,
    /** @export */
    na: invoke_jii,
    /** @export */
    f: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    B: invoke_viidii,
    /** @export */
    g: invoke_viii,
    /** @export */
    l: invoke_viiii,
    /** @export */
    h: invoke_viiiii,
    /** @export */
    A: invoke_viiiiii,
    /** @export */
    aa: invoke_viiiiiii,
    /** @export */
    z: invoke_viiiiiiiii,
    /** @export */
    H: _js_create_input_device,
    /** @export */
    $: _js_fd_read,
    /** @export */
    _: _js_module_onMessage,
    /** @export */
    G: _js_open_process,
    /** @export */
    Z: _js_popen_to_file,
    /** @export */
    Y: _js_process_status,
    /** @export */
    X: _js_waitpid,
    /** @export */
    W: _makecontext,
    /** @export */
    xa: _proc_exit,
    /** @export */
    u: _strftime,
    /** @export */
    V: _strftime_l,
    /** @export */
    U: _strptime,
    /** @export */
    T: _swapcontext,
    /** @export */
    r: _wasm_close,
    /** @export */
    t: _wasm_poll_socket,
    /** @export */
    o: _wasm_setsockopt,
    /** @export */
    S: _wasm_shutdown
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["ib"])();
  var _free = (a0) => (_free = wasmExports["jb"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["lb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["mb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["nb"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["ob"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["pb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["qb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["rb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["sb"])(a0);
  var _fflush = (a0) => (_fflush = wasmExports["tb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["ub"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["vb"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["xb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["yb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["zb"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["Ab"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["Bb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["Cb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["Db"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Eb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Fb"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Gb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Hb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Ib"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Jb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Kb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Lb"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Mb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Nb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Ob"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Pb"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Qb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Rb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Sb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Tb"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Ub"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Vb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Wb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Xb"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Yb"])(a0, a1, a2, a3);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Zb"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["_b"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["$b"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["ac"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["bc"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["cc"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["dc"])(a0, a1, a2, a3, a4, a5);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["ec"])(a0, a1, a2, a3);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["fc"])(a0);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["gc"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["hc"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["ic"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["jc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["kc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["lc"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["mc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["nc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["oc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["pc"])(a0, a1, a2, a3, a4, a5);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["qc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["rc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["sc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["tc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename, dependenciesTotalSize;
var init_php_8_3 = __esm({
  "packages/php-wasm/node/public/php_8_3.js"() {
    "use strict";
    dependencyFilename = __dirname + "/8_3_0/php_8_3.wasm";
    dependenciesTotalSize = 15312039;
  }
});

// packages/php-wasm/node/public/php_8_2.js
var php_8_2_exports = {};
__export(php_8_2_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize2,
  dependencyFilename: () => dependencyFilename2,
  init: () => init2
});
function init2(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename2;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["hb"];
      updateMemoryViews();
      wasmTable = wasmExports["kb"];
      addOnInit(wasmExports["ib"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  function _SharpYuvConvert() {
    abort("missing function: SharpYuvConvert");
  }
  _SharpYuvConvert.stub = true;
  function _SharpYuvGetConversionMatrix() {
    abort("missing function: SharpYuvGetConversionMatrix");
  }
  _SharpYuvGetConversionMatrix.stub = true;
  function _SharpYuvInit() {
    abort("missing function: SharpYuvInit");
  }
  _SharpYuvInit.stub = true;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  function _getcontext() {
    abort("missing function: getcontext");
  }
  _getcontext.stub = true;
  function _getdtablesize() {
    abort("missing function: getdtablesize");
  }
  _getdtablesize.stub = true;
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  function _makecontext() {
    abort("missing function: makecontext");
  }
  _makecontext.stub = true;
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _swapcontext() {
    abort("missing function: swapcontext");
  }
  _swapcontext.stub = true;
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    gb: _SharpYuvConvert,
    /** @export */
    fb: _SharpYuvGetConversionMatrix,
    /** @export */
    eb: _SharpYuvInit,
    /** @export */
    l: ___assert_fail,
    /** @export */
    db: ___call_sighandler,
    /** @export */
    cb: ___syscall_accept4,
    /** @export */
    bb: ___syscall_bind,
    /** @export */
    ab: ___syscall_chdir,
    /** @export */
    Q: ___syscall_chmod,
    /** @export */
    $a: ___syscall_connect,
    /** @export */
    _a: ___syscall_dup,
    /** @export */
    Za: ___syscall_dup3,
    /** @export */
    Ya: ___syscall_faccessat,
    /** @export */
    fa: ___syscall_fallocate,
    /** @export */
    Xa: ___syscall_fchmod,
    /** @export */
    Wa: ___syscall_fchown32,
    /** @export */
    P: ___syscall_fchownat,
    /** @export */
    n: ___syscall_fcntl64,
    /** @export */
    Va: ___syscall_fdatasync,
    /** @export */
    Ua: ___syscall_fstat64,
    /** @export */
    ma: ___syscall_ftruncate64,
    /** @export */
    Ta: ___syscall_getcwd,
    /** @export */
    Sa: ___syscall_getdents64,
    /** @export */
    Ra: ___syscall_getpeername,
    /** @export */
    Qa: ___syscall_getsockname,
    /** @export */
    Pa: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    Oa: ___syscall_listen,
    /** @export */
    Na: ___syscall_lstat64,
    /** @export */
    Ma: ___syscall_mkdirat,
    /** @export */
    La: ___syscall_newfstatat,
    /** @export */
    y: ___syscall_openat,
    /** @export */
    Ka: ___syscall_pipe,
    /** @export */
    Ja: ___syscall_poll,
    /** @export */
    Ia: ___syscall_readlinkat,
    /** @export */
    Ha: ___syscall_recvfrom,
    /** @export */
    Ga: ___syscall_renameat,
    /** @export */
    O: ___syscall_rmdir,
    /** @export */
    Fa: ___syscall_sendto,
    /** @export */
    N: ___syscall_socket,
    /** @export */
    Ea: ___syscall_stat64,
    /** @export */
    Da: ___syscall_statfs64,
    /** @export */
    Ca: ___syscall_symlink,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    Ba: ___syscall_utimensat,
    /** @export */
    wa: __abort_js,
    /** @export */
    va: __emscripten_get_now_is_monotonic,
    /** @export */
    ua: __emscripten_lookup_name,
    /** @export */
    ta: __emscripten_memcpy_js,
    /** @export */
    sa: __emscripten_runtime_keepalive_clear,
    /** @export */
    ra: __emscripten_throw_longjmp,
    /** @export */
    ia: __gmtime_js,
    /** @export */
    ja: __localtime_js,
    /** @export */
    ka: __mktime_js,
    /** @export */
    ga: __mmap_js,
    /** @export */
    ha: __munmap_js,
    /** @export */
    K: __setitimer_js,
    /** @export */
    qa: __tzset_js,
    /** @export */
    B: _emscripten_date_now,
    /** @export */
    pa: _emscripten_get_heap_max,
    /** @export */
    v: _emscripten_get_now,
    /** @export */
    oa: _emscripten_resize_heap,
    /** @export */
    J: _emscripten_sleep,
    /** @export */
    Aa: _environ_get,
    /** @export */
    za: _environ_sizes_get,
    /** @export */
    q: _exit,
    /** @export */
    r: _fd_close,
    /** @export */
    M: _fd_fdstat_get,
    /** @export */
    L: _fd_read,
    /** @export */
    la: _fd_seek,
    /** @export */
    ya: _fd_sync,
    /** @export */
    C: _fd_write,
    /** @export */
    I: _getaddrinfo,
    /** @export */
    ea: _getcontext,
    /** @export */
    da: _getdtablesize,
    /** @export */
    x: _getnameinfo,
    /** @export */
    ca: _getprotobyname,
    /** @export */
    ba: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    f: invoke_iiii,
    /** @export */
    h: invoke_iiiii,
    /** @export */
    p: invoke_iiiiii,
    /** @export */
    s: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    H: invoke_iiiiiiiiii,
    /** @export */
    na: invoke_jii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    A: invoke_viidii,
    /** @export */
    g: invoke_viii,
    /** @export */
    j: invoke_viiii,
    /** @export */
    m: invoke_viiiii,
    /** @export */
    k: invoke_viiiiii,
    /** @export */
    aa: invoke_viiiiiii,
    /** @export */
    z: invoke_viiiiiiiii,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    $: _js_fd_read,
    /** @export */
    _: _js_module_onMessage,
    /** @export */
    F: _js_open_process,
    /** @export */
    Z: _js_popen_to_file,
    /** @export */
    Y: _js_process_status,
    /** @export */
    X: _js_waitpid,
    /** @export */
    W: _makecontext,
    /** @export */
    xa: _proc_exit,
    /** @export */
    V: _strftime,
    /** @export */
    U: _strftime_l,
    /** @export */
    T: _strptime,
    /** @export */
    S: _swapcontext,
    /** @export */
    t: _wasm_close,
    /** @export */
    u: _wasm_poll_socket,
    /** @export */
    o: _wasm_setsockopt,
    /** @export */
    R: _wasm_shutdown
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["ib"])();
  var _free = (a0) => (_free = wasmExports["jb"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["lb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["mb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["nb"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["ob"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["pb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["qb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["rb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["sb"])(a0);
  var _fflush = (a0) => (_fflush = wasmExports["tb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["ub"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["vb"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["wb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["xb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["yb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["zb"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["Ab"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["Bb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["Cb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["Db"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Eb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Fb"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Gb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Hb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Ib"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Jb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Kb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Lb"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Mb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Nb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Ob"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Pb"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Qb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Rb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Sb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Tb"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Ub"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Vb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Wb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Xb"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Yb"])(a0, a1, a2, a3);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Zb"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["_b"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["$b"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["ac"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["bc"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["cc"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["dc"])(a0, a1, a2, a3, a4, a5);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["ec"])(a0, a1, a2, a3);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["fc"])(a0);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["gc"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["hc"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["ic"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["jc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["kc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["lc"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["mc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["nc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["oc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["pc"])(a0, a1, a2, a3, a4, a5);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["qc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["rc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["sc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["tc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename2, dependenciesTotalSize2;
var init_php_8_2 = __esm({
  "packages/php-wasm/node/public/php_8_2.js"() {
    "use strict";
    dependencyFilename2 = __dirname + "/8_2_10/php_8_2.wasm";
    dependenciesTotalSize2 = 14931833;
  }
});

// packages/php-wasm/node/public/php_8_1.js
var php_8_1_exports = {};
__export(php_8_1_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize3,
  dependencyFilename: () => dependencyFilename3,
  init: () => init3
});
function init3(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename3;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["gb"];
      updateMemoryViews();
      wasmTable = wasmExports["jb"];
      addOnInit(wasmExports["hb"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  function _SharpYuvConvert() {
    abort("missing function: SharpYuvConvert");
  }
  _SharpYuvConvert.stub = true;
  function _SharpYuvGetConversionMatrix() {
    abort("missing function: SharpYuvGetConversionMatrix");
  }
  _SharpYuvGetConversionMatrix.stub = true;
  function _SharpYuvInit() {
    abort("missing function: SharpYuvInit");
  }
  _SharpYuvInit.stub = true;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  function _getcontext() {
    abort("missing function: getcontext");
  }
  _getcontext.stub = true;
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  function _makecontext() {
    abort("missing function: makecontext");
  }
  _makecontext.stub = true;
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _swapcontext() {
    abort("missing function: swapcontext");
  }
  _swapcontext.stub = true;
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    fb: _SharpYuvConvert,
    /** @export */
    eb: _SharpYuvGetConversionMatrix,
    /** @export */
    db: _SharpYuvInit,
    /** @export */
    l: ___assert_fail,
    /** @export */
    cb: ___call_sighandler,
    /** @export */
    bb: ___syscall_accept4,
    /** @export */
    ab: ___syscall_bind,
    /** @export */
    $a: ___syscall_chdir,
    /** @export */
    Q: ___syscall_chmod,
    /** @export */
    _a: ___syscall_connect,
    /** @export */
    Za: ___syscall_dup,
    /** @export */
    Ya: ___syscall_dup3,
    /** @export */
    Xa: ___syscall_faccessat,
    /** @export */
    ea: ___syscall_fallocate,
    /** @export */
    Wa: ___syscall_fchmod,
    /** @export */
    Va: ___syscall_fchown32,
    /** @export */
    P: ___syscall_fchownat,
    /** @export */
    n: ___syscall_fcntl64,
    /** @export */
    Ua: ___syscall_fdatasync,
    /** @export */
    Ta: ___syscall_fstat64,
    /** @export */
    la: ___syscall_ftruncate64,
    /** @export */
    Sa: ___syscall_getcwd,
    /** @export */
    Ra: ___syscall_getdents64,
    /** @export */
    Qa: ___syscall_getpeername,
    /** @export */
    Pa: ___syscall_getsockname,
    /** @export */
    Oa: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    Na: ___syscall_listen,
    /** @export */
    Ma: ___syscall_lstat64,
    /** @export */
    La: ___syscall_mkdirat,
    /** @export */
    Ka: ___syscall_newfstatat,
    /** @export */
    y: ___syscall_openat,
    /** @export */
    Ja: ___syscall_pipe,
    /** @export */
    Ia: ___syscall_poll,
    /** @export */
    Ha: ___syscall_readlinkat,
    /** @export */
    Ga: ___syscall_recvfrom,
    /** @export */
    Fa: ___syscall_renameat,
    /** @export */
    O: ___syscall_rmdir,
    /** @export */
    Ea: ___syscall_sendto,
    /** @export */
    N: ___syscall_socket,
    /** @export */
    Da: ___syscall_stat64,
    /** @export */
    Ca: ___syscall_statfs64,
    /** @export */
    Ba: ___syscall_symlink,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    Aa: ___syscall_utimensat,
    /** @export */
    va: __abort_js,
    /** @export */
    ua: __emscripten_get_now_is_monotonic,
    /** @export */
    ta: __emscripten_lookup_name,
    /** @export */
    sa: __emscripten_memcpy_js,
    /** @export */
    ra: __emscripten_runtime_keepalive_clear,
    /** @export */
    qa: __emscripten_throw_longjmp,
    /** @export */
    ha: __gmtime_js,
    /** @export */
    ia: __localtime_js,
    /** @export */
    ja: __mktime_js,
    /** @export */
    fa: __mmap_js,
    /** @export */
    ga: __munmap_js,
    /** @export */
    K: __setitimer_js,
    /** @export */
    pa: __tzset_js,
    /** @export */
    B: _emscripten_date_now,
    /** @export */
    oa: _emscripten_get_heap_max,
    /** @export */
    v: _emscripten_get_now,
    /** @export */
    na: _emscripten_resize_heap,
    /** @export */
    J: _emscripten_sleep,
    /** @export */
    za: _environ_get,
    /** @export */
    ya: _environ_sizes_get,
    /** @export */
    o: _exit,
    /** @export */
    s: _fd_close,
    /** @export */
    M: _fd_fdstat_get,
    /** @export */
    L: _fd_read,
    /** @export */
    ka: _fd_seek,
    /** @export */
    xa: _fd_sync,
    /** @export */
    C: _fd_write,
    /** @export */
    I: _getaddrinfo,
    /** @export */
    da: _getcontext,
    /** @export */
    x: _getnameinfo,
    /** @export */
    ca: _getprotobyname,
    /** @export */
    ba: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    f: invoke_iiii,
    /** @export */
    h: invoke_iiiii,
    /** @export */
    q: invoke_iiiiii,
    /** @export */
    r: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    H: invoke_iiiiiiiiii,
    /** @export */
    ma: invoke_jii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    A: invoke_viidii,
    /** @export */
    g: invoke_viii,
    /** @export */
    j: invoke_viiii,
    /** @export */
    m: invoke_viiiii,
    /** @export */
    k: invoke_viiiiii,
    /** @export */
    aa: invoke_viiiiiii,
    /** @export */
    z: invoke_viiiiiiiii,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    $: _js_fd_read,
    /** @export */
    _: _js_module_onMessage,
    /** @export */
    F: _js_open_process,
    /** @export */
    Z: _js_popen_to_file,
    /** @export */
    Y: _js_process_status,
    /** @export */
    X: _js_waitpid,
    /** @export */
    W: _makecontext,
    /** @export */
    wa: _proc_exit,
    /** @export */
    V: _strftime,
    /** @export */
    U: _strftime_l,
    /** @export */
    T: _strptime,
    /** @export */
    S: _swapcontext,
    /** @export */
    t: _wasm_close,
    /** @export */
    u: _wasm_poll_socket,
    /** @export */
    p: _wasm_setsockopt,
    /** @export */
    R: _wasm_shutdown
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["hb"])();
  var _free = (a0) => (_free = wasmExports["ib"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["kb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["lb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["mb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["nb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["ob"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["pb"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["qb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["rb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["sb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["tb"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["ub"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["vb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["wb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["xb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["yb"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["zb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["Ab"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["Bb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["Cb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["Db"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Eb"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Fb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Gb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Hb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Ib"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Jb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Kb"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Lb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Mb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Nb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Ob"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Pb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Qb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Rb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Sb"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Tb"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Ub"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Vb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Wb"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Xb"])(a0, a1, a2, a3);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Yb"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Zb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["_b"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["$b"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["ac"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["bc"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["cc"])(a0, a1, a2, a3, a4, a5);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["dc"])(a0, a1, a2, a3);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["ec"])(a0);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["fc"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["gc"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["hc"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["ic"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["jc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["kc"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["lc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["mc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["nc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["oc"])(a0, a1, a2, a3, a4, a5);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["pc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["qc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["rc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["sc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename3, dependenciesTotalSize3;
var init_php_8_1 = __esm({
  "packages/php-wasm/node/public/php_8_1.js"() {
    "use strict";
    dependencyFilename3 = __dirname + "/8_1_23/php_8_1.wasm";
    dependenciesTotalSize3 = 14676594;
  }
});

// packages/php-wasm/node/public/php_8_0.js
var php_8_0_exports = {};
__export(php_8_0_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize4,
  dependencyFilename: () => dependencyFilename4,
  init: () => init4
});
function init4(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename4;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["cb"];
      updateMemoryViews();
      wasmTable = wasmExports["fb"];
      addOnInit(wasmExports["db"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  function _SharpYuvConvert() {
    abort("missing function: SharpYuvConvert");
  }
  _SharpYuvConvert.stub = true;
  function _SharpYuvGetConversionMatrix() {
    abort("missing function: SharpYuvGetConversionMatrix");
  }
  _SharpYuvGetConversionMatrix.stub = true;
  function _SharpYuvInit() {
    abort("missing function: SharpYuvInit");
  }
  _SharpYuvInit.stub = true;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    bb: _SharpYuvConvert,
    /** @export */
    ab: _SharpYuvGetConversionMatrix,
    /** @export */
    $a: _SharpYuvInit,
    /** @export */
    l: ___assert_fail,
    /** @export */
    _a: ___call_sighandler,
    /** @export */
    Za: ___syscall_accept4,
    /** @export */
    Ya: ___syscall_bind,
    /** @export */
    Xa: ___syscall_chdir,
    /** @export */
    Q: ___syscall_chmod,
    /** @export */
    Wa: ___syscall_connect,
    /** @export */
    Va: ___syscall_dup,
    /** @export */
    Ua: ___syscall_dup3,
    /** @export */
    Ta: ___syscall_faccessat,
    /** @export */
    ba: ___syscall_fallocate,
    /** @export */
    Sa: ___syscall_fchmod,
    /** @export */
    Ra: ___syscall_fchown32,
    /** @export */
    P: ___syscall_fchownat,
    /** @export */
    n: ___syscall_fcntl64,
    /** @export */
    Qa: ___syscall_fdatasync,
    /** @export */
    Pa: ___syscall_fstat64,
    /** @export */
    ia: ___syscall_ftruncate64,
    /** @export */
    Oa: ___syscall_getcwd,
    /** @export */
    Na: ___syscall_getdents64,
    /** @export */
    Ma: ___syscall_getpeername,
    /** @export */
    La: ___syscall_getsockname,
    /** @export */
    Ka: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    Ja: ___syscall_listen,
    /** @export */
    Ia: ___syscall_lstat64,
    /** @export */
    Ha: ___syscall_mkdirat,
    /** @export */
    Ga: ___syscall_newfstatat,
    /** @export */
    x: ___syscall_openat,
    /** @export */
    Fa: ___syscall_pipe,
    /** @export */
    Ea: ___syscall_poll,
    /** @export */
    Da: ___syscall_readlinkat,
    /** @export */
    Ca: ___syscall_recvfrom,
    /** @export */
    Ba: ___syscall_renameat,
    /** @export */
    O: ___syscall_rmdir,
    /** @export */
    Aa: ___syscall_sendto,
    /** @export */
    N: ___syscall_socket,
    /** @export */
    za: ___syscall_stat64,
    /** @export */
    ya: ___syscall_statfs64,
    /** @export */
    xa: ___syscall_symlink,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    wa: ___syscall_utimensat,
    /** @export */
    sa: __abort_js,
    /** @export */
    ra: __emscripten_get_now_is_monotonic,
    /** @export */
    qa: __emscripten_lookup_name,
    /** @export */
    pa: __emscripten_memcpy_js,
    /** @export */
    oa: __emscripten_runtime_keepalive_clear,
    /** @export */
    na: __emscripten_throw_longjmp,
    /** @export */
    ea: __gmtime_js,
    /** @export */
    fa: __localtime_js,
    /** @export */
    ga: __mktime_js,
    /** @export */
    ca: __mmap_js,
    /** @export */
    da: __munmap_js,
    /** @export */
    K: __setitimer_js,
    /** @export */
    ma: __tzset_js,
    /** @export */
    B: _emscripten_date_now,
    /** @export */
    la: _emscripten_get_heap_max,
    /** @export */
    v: _emscripten_get_now,
    /** @export */
    ka: _emscripten_resize_heap,
    /** @export */
    J: _emscripten_sleep,
    /** @export */
    va: _environ_get,
    /** @export */
    ua: _environ_sizes_get,
    /** @export */
    o: _exit,
    /** @export */
    q: _fd_close,
    /** @export */
    M: _fd_fdstat_get,
    /** @export */
    L: _fd_read,
    /** @export */
    ha: _fd_seek,
    /** @export */
    C: _fd_write,
    /** @export */
    I: _getaddrinfo,
    /** @export */
    A: _getnameinfo,
    /** @export */
    aa: _getprotobyname,
    /** @export */
    $: _getprotobynumber,
    /** @export */
    j: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    f: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    s: invoke_iiiiii,
    /** @export */
    r: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    H: invoke_iiiiiiiiii,
    /** @export */
    ja: invoke_jii,
    /** @export */
    e: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    z: invoke_viidii,
    /** @export */
    h: invoke_viii,
    /** @export */
    i: invoke_viiii,
    /** @export */
    m: invoke_viiiii,
    /** @export */
    k: invoke_viiiiii,
    /** @export */
    _: invoke_viiiiiii,
    /** @export */
    y: invoke_viiiiiiiii,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    Z: _js_fd_read,
    /** @export */
    Y: _js_module_onMessage,
    /** @export */
    F: _js_open_process,
    /** @export */
    X: _js_popen_to_file,
    /** @export */
    W: _js_process_status,
    /** @export */
    V: _js_waitpid,
    /** @export */
    ta: _proc_exit,
    /** @export */
    U: _strftime,
    /** @export */
    T: _strftime_l,
    /** @export */
    S: _strptime,
    /** @export */
    t: _wasm_close,
    /** @export */
    u: _wasm_poll_socket,
    /** @export */
    p: _wasm_setsockopt,
    /** @export */
    R: _wasm_shutdown
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["db"])();
  var _free = (a0) => (_free = wasmExports["eb"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["gb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["hb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["ib"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["jb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["kb"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["lb"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["mb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["nb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["ob"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["pb"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["qb"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["rb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["sb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["tb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["ub"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["vb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["wb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["xb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["yb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["zb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["Ab"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Bb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Cb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Db"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Eb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Fb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Gb"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Hb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Ib"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Jb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Kb"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Lb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Mb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Nb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Ob"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Pb"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Qb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Rb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Sb"])();
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Tb"])(a0, a1, a2, a3);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Ub"])(a0, a1);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Vb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Wb"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["Xb"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["Yb"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["Zb"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["_b"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["$b"])(a0, a1, a2, a3, a4, a5);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["ac"])(a0);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["bc"])(a0, a1, a2, a3);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["cc"])(a0, a1, a2, a3, a4);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["dc"])(a0);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["ec"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = wasmExports["fc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["gc"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["hc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["ic"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["jc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["kc"])(a0, a1, a2, a3, a4, a5);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["lc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["mc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["nc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["oc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename4, dependenciesTotalSize4;
var init_php_8_0 = __esm({
  "packages/php-wasm/node/public/php_8_0.js"() {
    "use strict";
    dependencyFilename4 = __dirname + "/8_0_30/php_8_0.wasm";
    dependenciesTotalSize4 = 14694447;
  }
});

// packages/php-wasm/node/public/php_7_4.js
var php_7_4_exports = {};
__export(php_7_4_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize5,
  dependencyFilename: () => dependencyFilename5,
  init: () => init5
});
function init5(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename5;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["bb"];
      updateMemoryViews();
      wasmTable = wasmExports["eb"];
      addOnInit(wasmExports["cb"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  function _SharpYuvConvert() {
    abort("missing function: SharpYuvConvert");
  }
  _SharpYuvConvert.stub = true;
  function _SharpYuvGetConversionMatrix() {
    abort("missing function: SharpYuvGetConversionMatrix");
  }
  _SharpYuvGetConversionMatrix.stub = true;
  function _SharpYuvInit() {
    abort("missing function: SharpYuvInit");
  }
  _SharpYuvInit.stub = true;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_fallocate(fd, mode, offset_low, offset_high, len_low, len_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    var len = convertI32PairToI53Checked(len_low, len_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fdatasync(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  function _wasm_shutdown(socketd, how) {
    return PHPWASM.shutdownSocket(socketd, how);
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    ab: _SharpYuvConvert,
    /** @export */
    $a: _SharpYuvGetConversionMatrix,
    /** @export */
    _a: _SharpYuvInit,
    /** @export */
    k: ___assert_fail,
    /** @export */
    Za: ___call_sighandler,
    /** @export */
    Ya: ___syscall_accept4,
    /** @export */
    Xa: ___syscall_bind,
    /** @export */
    Wa: ___syscall_chdir,
    /** @export */
    Q: ___syscall_chmod,
    /** @export */
    Va: ___syscall_connect,
    /** @export */
    Ua: ___syscall_dup,
    /** @export */
    Ta: ___syscall_dup3,
    /** @export */
    Sa: ___syscall_faccessat,
    /** @export */
    aa: ___syscall_fallocate,
    /** @export */
    Ra: ___syscall_fchmod,
    /** @export */
    Qa: ___syscall_fchown32,
    /** @export */
    P: ___syscall_fchownat,
    /** @export */
    n: ___syscall_fcntl64,
    /** @export */
    Pa: ___syscall_fdatasync,
    /** @export */
    Oa: ___syscall_fstat64,
    /** @export */
    ha: ___syscall_ftruncate64,
    /** @export */
    Na: ___syscall_getcwd,
    /** @export */
    Ma: ___syscall_getdents64,
    /** @export */
    La: ___syscall_getpeername,
    /** @export */
    Ka: ___syscall_getsockname,
    /** @export */
    Ja: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    Ia: ___syscall_listen,
    /** @export */
    Ha: ___syscall_lstat64,
    /** @export */
    Ga: ___syscall_mkdirat,
    /** @export */
    Fa: ___syscall_newfstatat,
    /** @export */
    x: ___syscall_openat,
    /** @export */
    Ea: ___syscall_pipe,
    /** @export */
    Da: ___syscall_poll,
    /** @export */
    Ca: ___syscall_readlinkat,
    /** @export */
    Ba: ___syscall_recvfrom,
    /** @export */
    Aa: ___syscall_renameat,
    /** @export */
    O: ___syscall_rmdir,
    /** @export */
    za: ___syscall_sendto,
    /** @export */
    N: ___syscall_socket,
    /** @export */
    ya: ___syscall_stat64,
    /** @export */
    xa: ___syscall_statfs64,
    /** @export */
    wa: ___syscall_symlink,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    va: ___syscall_utimensat,
    /** @export */
    ra: __abort_js,
    /** @export */
    qa: __emscripten_get_now_is_monotonic,
    /** @export */
    pa: __emscripten_lookup_name,
    /** @export */
    oa: __emscripten_memcpy_js,
    /** @export */
    na: __emscripten_runtime_keepalive_clear,
    /** @export */
    ma: __emscripten_throw_longjmp,
    /** @export */
    da: __gmtime_js,
    /** @export */
    ea: __localtime_js,
    /** @export */
    fa: __mktime_js,
    /** @export */
    ba: __mmap_js,
    /** @export */
    ca: __munmap_js,
    /** @export */
    K: __setitimer_js,
    /** @export */
    la: __tzset_js,
    /** @export */
    B: _emscripten_date_now,
    /** @export */
    ka: _emscripten_get_heap_max,
    /** @export */
    v: _emscripten_get_now,
    /** @export */
    ja: _emscripten_resize_heap,
    /** @export */
    J: _emscripten_sleep,
    /** @export */
    ua: _environ_get,
    /** @export */
    ta: _environ_sizes_get,
    /** @export */
    o: _exit,
    /** @export */
    q: _fd_close,
    /** @export */
    M: _fd_fdstat_get,
    /** @export */
    L: _fd_read,
    /** @export */
    ga: _fd_seek,
    /** @export */
    C: _fd_write,
    /** @export */
    I: _getaddrinfo,
    /** @export */
    A: _getnameinfo,
    /** @export */
    $: _getprotobyname,
    /** @export */
    _: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    e: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    r: invoke_iiiiii,
    /** @export */
    t: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    H: invoke_iiiiiiiiii,
    /** @export */
    ia: invoke_jii,
    /** @export */
    f: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    z: invoke_viidii,
    /** @export */
    h: invoke_viii,
    /** @export */
    l: invoke_viiii,
    /** @export */
    m: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    y: invoke_viiiiiiiii,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    Z: _js_fd_read,
    /** @export */
    Y: _js_module_onMessage,
    /** @export */
    F: _js_open_process,
    /** @export */
    X: _js_popen_to_file,
    /** @export */
    W: _js_process_status,
    /** @export */
    V: _js_waitpid,
    /** @export */
    sa: _proc_exit,
    /** @export */
    U: _strftime,
    /** @export */
    T: _strftime_l,
    /** @export */
    S: _strptime,
    /** @export */
    s: _wasm_close,
    /** @export */
    u: _wasm_poll_socket,
    /** @export */
    p: _wasm_setsockopt,
    /** @export */
    R: _wasm_shutdown
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["cb"])();
  var _free = (a0) => (_free = wasmExports["db"])(a0);
  var _malloc = (a0) => (_malloc = wasmExports["fb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["gb"])(a0, a1, a2);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["hb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["ib"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["jb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["kb"])(a0, a1, a2, a3);
  var _htons = (a0) => (_htons = wasmExports["lb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["mb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["nb"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["ob"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["pb"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["qb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["rb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["sb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["tb"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["ub"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["vb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["wb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["xb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["yb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["zb"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["Ab"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["Bb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["Cb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["Db"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["Eb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Fb"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Gb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Hb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Ib"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Jb"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Kb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Lb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Mb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Nb"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Ob"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Pb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Qb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Rb"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Sb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Tb"])(a0, a1, a2);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["Ub"])(a0, a1, a2, a3);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Vb"])(a0, a1);
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Wb"])(a0, a1, a2, a3);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["Xb"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["Yb"])(a0, a1, a2, a3, a4);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["Zb"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["_b"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["$b"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["ac"])(a0);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["bc"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["cc"])(a0, a1, a2, a3, a4);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["dc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["ec"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["fc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["gc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["hc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["ic"])(a0, a1, a2, a3, a4, a5);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["jc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["kc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["lc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["mc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename5, dependenciesTotalSize5;
var init_php_7_4 = __esm({
  "packages/php-wasm/node/public/php_7_4.js"() {
    "use strict";
    dependencyFilename5 = __dirname + "/7_4_33/php_7_4.wasm";
    dependenciesTotalSize5 = 15184093;
  }
});

// packages/php-wasm/node/public/php_7_3.js
var php_7_3_exports = {};
__export(php_7_3_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize6,
  dependencyFilename: () => dependencyFilename6,
  init: () => init6
});
function init6(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename6;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["Ya"];
      updateMemoryViews();
      wasmTable = wasmExports["ab"];
      addOnInit(wasmExports["Za"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    k: ___assert_fail,
    /** @export */
    Xa: ___call_sighandler,
    /** @export */
    Wa: ___syscall_accept4,
    /** @export */
    Va: ___syscall_bind,
    /** @export */
    Ua: ___syscall_chdir,
    /** @export */
    Q: ___syscall_chmod,
    /** @export */
    Ta: ___syscall_connect,
    /** @export */
    Sa: ___syscall_dup,
    /** @export */
    Ra: ___syscall_dup3,
    /** @export */
    Qa: ___syscall_faccessat,
    /** @export */
    Pa: ___syscall_fchmod,
    /** @export */
    Oa: ___syscall_fchown32,
    /** @export */
    P: ___syscall_fchownat,
    /** @export */
    m: ___syscall_fcntl64,
    /** @export */
    Na: ___syscall_fstat64,
    /** @export */
    ba: ___syscall_ftruncate64,
    /** @export */
    Ma: ___syscall_getcwd,
    /** @export */
    La: ___syscall_getdents64,
    /** @export */
    Ka: ___syscall_getpeername,
    /** @export */
    Ja: ___syscall_getsockname,
    /** @export */
    Ia: ___syscall_getsockopt,
    /** @export */
    F: ___syscall_ioctl,
    /** @export */
    Ha: ___syscall_listen,
    /** @export */
    Ga: ___syscall_lstat64,
    /** @export */
    Fa: ___syscall_mkdirat,
    /** @export */
    Ea: ___syscall_newfstatat,
    /** @export */
    x: ___syscall_openat,
    /** @export */
    Da: ___syscall_pipe,
    /** @export */
    Ca: ___syscall_poll,
    /** @export */
    Ba: ___syscall_readlinkat,
    /** @export */
    Aa: ___syscall_recvfrom,
    /** @export */
    za: ___syscall_renameat,
    /** @export */
    O: ___syscall_rmdir,
    /** @export */
    ya: ___syscall_sendto,
    /** @export */
    N: ___syscall_socket,
    /** @export */
    xa: ___syscall_stat64,
    /** @export */
    wa: ___syscall_statfs64,
    /** @export */
    va: ___syscall_symlink,
    /** @export */
    E: ___syscall_unlinkat,
    /** @export */
    ua: ___syscall_utimensat,
    /** @export */
    pa: __abort_js,
    /** @export */
    oa: __emscripten_get_now_is_monotonic,
    /** @export */
    na: __emscripten_lookup_name,
    /** @export */
    ma: __emscripten_memcpy_js,
    /** @export */
    la: __emscripten_runtime_keepalive_clear,
    /** @export */
    ka: __emscripten_throw_longjmp,
    /** @export */
    fa: __gmtime_js,
    /** @export */
    ga: __localtime_js,
    /** @export */
    $: __mktime_js,
    /** @export */
    da: __mmap_js,
    /** @export */
    ea: __munmap_js,
    /** @export */
    K: __setitimer_js,
    /** @export */
    ja: __tzset_js,
    /** @export */
    C: _emscripten_date_now,
    /** @export */
    ia: _emscripten_get_heap_max,
    /** @export */
    v: _emscripten_get_now,
    /** @export */
    ha: _emscripten_resize_heap,
    /** @export */
    J: _emscripten_sleep,
    /** @export */
    ta: _environ_get,
    /** @export */
    sa: _environ_sizes_get,
    /** @export */
    o: _exit,
    /** @export */
    q: _fd_close,
    /** @export */
    M: _fd_fdstat_get,
    /** @export */
    L: _fd_read,
    /** @export */
    aa: _fd_seek,
    /** @export */
    ra: _fd_sync,
    /** @export */
    D: _fd_write,
    /** @export */
    I: _getaddrinfo,
    /** @export */
    B: _getnameinfo,
    /** @export */
    _: _getprotobyname,
    /** @export */
    Z: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    e: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    r: invoke_iiiiii,
    /** @export */
    t: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    A: invoke_iiiiiiiiii,
    /** @export */
    ca: invoke_jii,
    /** @export */
    f: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    z: invoke_viidii,
    /** @export */
    h: invoke_viii,
    /** @export */
    l: invoke_viiii,
    /** @export */
    n: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    y: invoke_viiiiiiiii,
    /** @export */
    H: _js_create_input_device,
    /** @export */
    Y: _js_fd_read,
    /** @export */
    X: _js_module_onMessage,
    /** @export */
    G: _js_open_process,
    /** @export */
    W: _js_popen_to_file,
    /** @export */
    V: _js_process_status,
    /** @export */
    U: _js_waitpid,
    /** @export */
    qa: _proc_exit,
    /** @export */
    T: _strftime,
    /** @export */
    S: _strftime_l,
    /** @export */
    R: _strptime,
    /** @export */
    s: _wasm_close,
    /** @export */
    u: _wasm_poll_socket,
    /** @export */
    p: _wasm_setsockopt
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["Za"])();
  var _malloc = (a0) => (_malloc = wasmExports["_a"])(a0);
  var _free = (a0) => (_free = wasmExports["$a"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["bb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["cb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["db"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["eb"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["fb"])(a0, a1, a2);
  var _htons = (a0) => (_htons = wasmExports["gb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["hb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["ib"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["jb"])(a0);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["kb"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["lb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["mb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["nb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["ob"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["pb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["qb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["rb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["sb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["tb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["ub"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["vb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["xb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["yb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["zb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Ab"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Bb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Cb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Db"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Eb"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Fb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Gb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Hb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Ib"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Jb"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Kb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Lb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Mb"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Nb"])(a0, a1);
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Ob"])(a0, a1, a2, a3);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Pb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Qb"])(a0, a1, a2);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["Rb"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["Sb"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["Tb"])(a0, a1, a2, a3, a4, a5);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["Ub"])(a0, a1, a2, a3, a4);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["Vb"])(a0, a1, a2, a3);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["Wb"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["Xb"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["Yb"])(a0);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["Zb"])(a0);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["_b"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["$b"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["ac"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["bc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["cc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["dc"])(a0, a1, a2, a3, a4, a5);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["ec"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["fc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["gc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["hc"])();
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename6, dependenciesTotalSize6;
var init_php_7_3 = __esm({
  "packages/php-wasm/node/public/php_7_3.js"() {
    "use strict";
    dependencyFilename6 = __dirname + "/7_3_33/php_7_3.wasm";
    dependenciesTotalSize6 = 14496257;
  }
});

// packages/php-wasm/node/public/php_7_2.js
var php_7_2_exports = {};
__export(php_7_2_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize7,
  dependencyFilename: () => dependencyFilename7,
  init: () => init7
});
function init7(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename7;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["Ya"];
      updateMemoryViews();
      wasmTable = wasmExports["ab"];
      addOnInit(wasmExports["Za"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    l: ___assert_fail,
    /** @export */
    Xa: ___call_sighandler,
    /** @export */
    Wa: ___syscall_accept4,
    /** @export */
    Va: ___syscall_bind,
    /** @export */
    Ua: ___syscall_chdir,
    /** @export */
    P: ___syscall_chmod,
    /** @export */
    Ta: ___syscall_connect,
    /** @export */
    Sa: ___syscall_dup,
    /** @export */
    Ra: ___syscall_dup3,
    /** @export */
    Qa: ___syscall_faccessat,
    /** @export */
    Pa: ___syscall_fchmod,
    /** @export */
    Oa: ___syscall_fchown32,
    /** @export */
    O: ___syscall_fchownat,
    /** @export */
    m: ___syscall_fcntl64,
    /** @export */
    Na: ___syscall_fstat64,
    /** @export */
    ba: ___syscall_ftruncate64,
    /** @export */
    Ma: ___syscall_getcwd,
    /** @export */
    La: ___syscall_getdents64,
    /** @export */
    Ka: ___syscall_getpeername,
    /** @export */
    Ja: ___syscall_getsockname,
    /** @export */
    Ia: ___syscall_getsockopt,
    /** @export */
    E: ___syscall_ioctl,
    /** @export */
    Ha: ___syscall_listen,
    /** @export */
    Ga: ___syscall_lstat64,
    /** @export */
    Fa: ___syscall_mkdirat,
    /** @export */
    Ea: ___syscall_newfstatat,
    /** @export */
    x: ___syscall_openat,
    /** @export */
    Da: ___syscall_pipe,
    /** @export */
    Ca: ___syscall_poll,
    /** @export */
    Ba: ___syscall_readlinkat,
    /** @export */
    Aa: ___syscall_recvfrom,
    /** @export */
    za: ___syscall_renameat,
    /** @export */
    N: ___syscall_rmdir,
    /** @export */
    ya: ___syscall_sendto,
    /** @export */
    M: ___syscall_socket,
    /** @export */
    xa: ___syscall_stat64,
    /** @export */
    wa: ___syscall_statfs64,
    /** @export */
    va: ___syscall_symlink,
    /** @export */
    D: ___syscall_unlinkat,
    /** @export */
    ua: ___syscall_utimensat,
    /** @export */
    pa: __abort_js,
    /** @export */
    oa: __emscripten_get_now_is_monotonic,
    /** @export */
    na: __emscripten_lookup_name,
    /** @export */
    ma: __emscripten_memcpy_js,
    /** @export */
    la: __emscripten_runtime_keepalive_clear,
    /** @export */
    ka: __emscripten_throw_longjmp,
    /** @export */
    fa: __gmtime_js,
    /** @export */
    ga: __localtime_js,
    /** @export */
    $: __mktime_js,
    /** @export */
    da: __mmap_js,
    /** @export */
    ea: __munmap_js,
    /** @export */
    J: __setitimer_js,
    /** @export */
    ja: __tzset_js,
    /** @export */
    B: _emscripten_date_now,
    /** @export */
    ia: _emscripten_get_heap_max,
    /** @export */
    v: _emscripten_get_now,
    /** @export */
    ha: _emscripten_resize_heap,
    /** @export */
    I: _emscripten_sleep,
    /** @export */
    ta: _environ_get,
    /** @export */
    sa: _environ_sizes_get,
    /** @export */
    o: _exit,
    /** @export */
    r: _fd_close,
    /** @export */
    L: _fd_fdstat_get,
    /** @export */
    K: _fd_read,
    /** @export */
    aa: _fd_seek,
    /** @export */
    ra: _fd_sync,
    /** @export */
    C: _fd_write,
    /** @export */
    _: _getaddrinfo,
    /** @export */
    H: _getnameinfo,
    /** @export */
    Z: _getprotobyname,
    /** @export */
    Y: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    e: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    q: invoke_iiiiii,
    /** @export */
    t: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    A: invoke_iiiiiiiiii,
    /** @export */
    ca: invoke_jii,
    /** @export */
    f: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    z: invoke_viidii,
    /** @export */
    h: invoke_viii,
    /** @export */
    k: invoke_viiii,
    /** @export */
    n: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    y: invoke_viiiiiiiii,
    /** @export */
    G: _js_create_input_device,
    /** @export */
    X: _js_fd_read,
    /** @export */
    W: _js_module_onMessage,
    /** @export */
    F: _js_open_process,
    /** @export */
    V: _js_popen_to_file,
    /** @export */
    U: _js_process_status,
    /** @export */
    T: _js_waitpid,
    /** @export */
    qa: _proc_exit,
    /** @export */
    S: _strftime,
    /** @export */
    R: _strftime_l,
    /** @export */
    Q: _strptime,
    /** @export */
    s: _wasm_close,
    /** @export */
    u: _wasm_poll_socket,
    /** @export */
    p: _wasm_setsockopt
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["Za"])();
  var _malloc = (a0) => (_malloc = wasmExports["_a"])(a0);
  var _free = (a0) => (_free = wasmExports["$a"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["bb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["cb"])(a0);
  var _htons = (a0) => (_htons = wasmExports["db"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["eb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["fb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["gb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["hb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["ib"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["jb"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["kb"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["lb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["mb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["nb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["ob"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["pb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["qb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["rb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["sb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["tb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["ub"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["vb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["xb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["yb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["zb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Ab"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Bb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Cb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Db"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Eb"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Fb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Gb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Hb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Ib"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Jb"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Kb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Lb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Mb"])();
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Nb"])(a0, a1);
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Ob"])(a0, a1, a2, a3);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Pb"])(a0, a1);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Qb"])(a0, a1, a2);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["Rb"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["Sb"])(a0, a1, a2);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["Tb"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["Ub"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["Vb"])(a0, a1, a2, a3, a4, a5);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["Wb"])(a0);
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["Xb"])(a0, a1, a2, a3);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["Yb"])(a0, a1, a2, a3, a4);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["Zb"])(a0);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["_b"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["$b"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["ac"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["bc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["cc"])(a0, a1, a2);
  var dynCall_viidii = Module["dynCall_viidii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viidii = Module["dynCall_viidii"] = wasmExports["dc"])(a0, a1, a2, a3, a4, a5);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["ec"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["fc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["gc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["hc"])();
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viidii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viidii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename7, dependenciesTotalSize7;
var init_php_7_2 = __esm({
  "packages/php-wasm/node/public/php_7_2.js"() {
    "use strict";
    dependencyFilename7 = __dirname + "/7_2_34/php_7_2.wasm";
    dependenciesTotalSize7 = 14371503;
  }
});

// packages/php-wasm/node/public/php_7_1.js
var php_7_1_exports = {};
__export(php_7_1_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize8,
  dependencyFilename: () => dependencyFilename8,
  init: () => init8
});
function init8(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename8;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["Xa"];
      updateMemoryViews();
      wasmTable = wasmExports["$a"];
      addOnInit(wasmExports["Ya"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    l: ___assert_fail,
    /** @export */
    Wa: ___call_sighandler,
    /** @export */
    Va: ___syscall_accept4,
    /** @export */
    Ua: ___syscall_bind,
    /** @export */
    Ta: ___syscall_chdir,
    /** @export */
    O: ___syscall_chmod,
    /** @export */
    Sa: ___syscall_connect,
    /** @export */
    Ra: ___syscall_dup,
    /** @export */
    Qa: ___syscall_dup3,
    /** @export */
    Pa: ___syscall_faccessat,
    /** @export */
    Oa: ___syscall_fchmod,
    /** @export */
    Na: ___syscall_fchown32,
    /** @export */
    N: ___syscall_fchownat,
    /** @export */
    m: ___syscall_fcntl64,
    /** @export */
    Ma: ___syscall_fstat64,
    /** @export */
    ba: ___syscall_ftruncate64,
    /** @export */
    La: ___syscall_getcwd,
    /** @export */
    Ka: ___syscall_getdents64,
    /** @export */
    Ja: ___syscall_getpeername,
    /** @export */
    Ia: ___syscall_getsockname,
    /** @export */
    Ha: ___syscall_getsockopt,
    /** @export */
    C: ___syscall_ioctl,
    /** @export */
    Ga: ___syscall_listen,
    /** @export */
    Fa: ___syscall_lstat64,
    /** @export */
    Ea: ___syscall_mkdirat,
    /** @export */
    Da: ___syscall_newfstatat,
    /** @export */
    B: ___syscall_openat,
    /** @export */
    Ca: ___syscall_pipe,
    /** @export */
    Ba: ___syscall_poll,
    /** @export */
    Aa: ___syscall_readlinkat,
    /** @export */
    za: ___syscall_recvfrom,
    /** @export */
    ya: ___syscall_renameat,
    /** @export */
    M: ___syscall_rmdir,
    /** @export */
    xa: ___syscall_sendto,
    /** @export */
    L: ___syscall_socket,
    /** @export */
    wa: ___syscall_stat64,
    /** @export */
    va: ___syscall_statfs64,
    /** @export */
    ua: ___syscall_symlink,
    /** @export */
    K: ___syscall_unlinkat,
    /** @export */
    ta: ___syscall_utimensat,
    /** @export */
    oa: __abort_js,
    /** @export */
    na: __emscripten_get_now_is_monotonic,
    /** @export */
    ma: __emscripten_lookup_name,
    /** @export */
    la: __emscripten_memcpy_js,
    /** @export */
    ka: __emscripten_runtime_keepalive_clear,
    /** @export */
    ja: __emscripten_throw_longjmp,
    /** @export */
    fa: __gmtime_js,
    /** @export */
    _: __localtime_js,
    /** @export */
    $: __mktime_js,
    /** @export */
    da: __mmap_js,
    /** @export */
    ea: __munmap_js,
    /** @export */
    H: __setitimer_js,
    /** @export */
    ia: __tzset_js,
    /** @export */
    z: _emscripten_date_now,
    /** @export */
    ha: _emscripten_get_heap_max,
    /** @export */
    v: _emscripten_get_now,
    /** @export */
    ga: _emscripten_resize_heap,
    /** @export */
    G: _emscripten_sleep,
    /** @export */
    sa: _environ_get,
    /** @export */
    ra: _environ_sizes_get,
    /** @export */
    o: _exit,
    /** @export */
    t: _fd_close,
    /** @export */
    J: _fd_fdstat_get,
    /** @export */
    I: _fd_read,
    /** @export */
    aa: _fd_seek,
    /** @export */
    qa: _fd_sync,
    /** @export */
    A: _fd_write,
    /** @export */
    Z: _getaddrinfo,
    /** @export */
    F: _getnameinfo,
    /** @export */
    Y: _getprotobyname,
    /** @export */
    X: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    e: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    s: invoke_iiiiii,
    /** @export */
    r: invoke_iiiiiii,
    /** @export */
    w: invoke_iiiiiiii,
    /** @export */
    y: invoke_iiiiiiiiii,
    /** @export */
    ca: invoke_jii,
    /** @export */
    f: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    h: invoke_viii,
    /** @export */
    k: invoke_viiii,
    /** @export */
    n: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    x: invoke_viiiiiiiii,
    /** @export */
    E: _js_create_input_device,
    /** @export */
    W: _js_fd_read,
    /** @export */
    V: _js_module_onMessage,
    /** @export */
    D: _js_open_process,
    /** @export */
    U: _js_popen_to_file,
    /** @export */
    T: _js_process_status,
    /** @export */
    S: _js_waitpid,
    /** @export */
    pa: _proc_exit,
    /** @export */
    R: _strftime,
    /** @export */
    Q: _strftime_l,
    /** @export */
    P: _strptime,
    /** @export */
    q: _wasm_close,
    /** @export */
    u: _wasm_poll_socket,
    /** @export */
    p: _wasm_setsockopt
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["Ya"])();
  var _malloc = (a0) => (_malloc = wasmExports["Za"])(a0);
  var _free = (a0) => (_free = wasmExports["_a"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["ab"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["bb"])(a0);
  var _htons = (a0) => (_htons = wasmExports["cb"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["db"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["eb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["fb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["gb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["hb"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["ib"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["jb"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["kb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["lb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["mb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["nb"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["ob"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["pb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["qb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["rb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["sb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["tb"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["ub"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["vb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["wb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["xb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["yb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["zb"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Ab"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Bb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Cb"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Db"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Eb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Fb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Gb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Hb"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Ib"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Jb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Kb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Lb"])();
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["Mb"])(a0, a1, a2, a3);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Nb"])(a0, a1, a2);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Ob"])(a0, a1);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["Pb"])(a0, a1, a2);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Qb"])(a0, a1);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["Rb"])(a0);
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Sb"])(a0, a1, a2, a3);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["Tb"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["Ub"])(a0, a1, a2, a3, a4, a5);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["Vb"])(a0, a1, a2, a3, a4);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["Wb"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["Xb"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["Yb"])(a0);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["Zb"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["_b"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["$b"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["ac"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["bc"])(a0, a1, a2);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["cc"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["dc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["ec"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["fc"])();
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename8, dependenciesTotalSize8;
var init_php_7_1 = __esm({
  "packages/php-wasm/node/public/php_7_1.js"() {
    "use strict";
    dependencyFilename8 = __dirname + "/7_1_30/php_7_1.wasm";
    dependenciesTotalSize8 = 13822227;
  }
});

// packages/php-wasm/node/public/php_7_0.js
var php_7_0_exports = {};
__export(php_7_0_exports, {
  dependenciesTotalSize: () => dependenciesTotalSize9,
  dependencyFilename: () => dependencyFilename9,
  init: () => init9
});
function init9(RuntimeName, PHPLoader) {
  ExitStatus = class PHPExitStatus extends Error {
    constructor(status) {
      super(status);
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
  };
  var Module = typeof PHPLoader != "undefined" ? PHPLoader : {};
  var ENVIRONMENT_IS_WORKER = RuntimeName === "WORKER";
  var ENVIRONMENT_IS_NODE = RuntimeName === "NODE";
  if (ENVIRONMENT_IS_NODE) {
  }
  var moduleOverrides = Object.assign({}, Module);
  var arguments_ = [];
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var read_, readAsync, readBinary;
  if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var nodePath = require("path");
    scriptDirectory = __dirname + "/";
    read_ = (filename, binary) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      return fs.readFileSync(filename, binary ? void 0 : "utf8");
    };
    readBinary = (filename) => {
      var ret = read_(filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      return ret;
    };
    readAsync = (filename, onload, onerror, binary = true) => {
      filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
      fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
        if (err2)
          onerror(err2);
        else
          onload(binary ? data.buffer : data);
      });
    };
    if (!Module["thisProgram"] && process.argv.length > 1) {
      thisProgram = process.argv[1].replace(/\\/g, "/");
    }
    arguments_ = process.argv.slice(2);
    if (typeof module != "undefined") {
      module["exports"] = Module;
    }
    quit_ = (status, toThrow) => {
      process.exitCode = status;
      throw toThrow;
    };
  } else {
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.error.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"])
    arguments_ = Module["arguments"];
  if (Module["thisProgram"])
    thisProgram = Module["thisProgram"];
  if (Module["quit"])
    quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"])
    wasmBinary = Module["wasmBinary"];
  var wasmMemory;
  var ABORT = false;
  var EXITSTATUS;
  function assert(condition, text) {
    if (!condition) {
      abort(text);
    }
  }
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateMemoryViews() {
    var b = wasmMemory.buffer;
    Module["HEAP8"] = HEAP8 = new Int8Array(b);
    Module["HEAP16"] = HEAP16 = new Int16Array(b);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
    Module["HEAP32"] = HEAP32 = new Int32Array(b);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  var runtimeExited = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    runtimeInitialized = true;
    SOCKFS.root = FS.mount(SOCKFS, {}, null);
    if (!Module["noFSInit"] && !FS.init.initialized)
      FS.init();
    FS.ignorePermissions = false;
    TTY.init();
    PIPEFS.root = FS.mount(PIPEFS, {}, null);
    callRuntimeCallbacks(__ATINIT__);
  }
  function exitRuntime() {
    ___funcs_on_exit();
    callRuntimeCallbacks(__ATEXIT__);
    FS.quit();
    TTY.shutdown();
    runtimeExited = true;
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function getUniqueRunDependency(id) {
    return id;
  }
  function addRunDependency(id) {
    runDependencies++;
    Module["monitorRunDependencies"]?.(runDependencies);
  }
  function removeRunDependency(id) {
    runDependencies--;
    Module["monitorRunDependencies"]?.(runDependencies);
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    Module["onAbort"]?.(what);
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    EXITSTATUS = 1;
    what += ". Build with -sASSERTIONS for more info.";
    var e = new WebAssembly.RuntimeError(what);
    throw e;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
  var isFileURI = (filename) => filename.startsWith("file://");
  function findWasmBinary() {
    var f = dependencyFilename9;
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  var wasmBinaryFile;
  function getBinarySync(file) {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  function getBinaryPromise(binaryFile) {
    if (!wasmBinary) {
      return new Promise((resolve, reject) => {
        readAsync(binaryFile, (response) => resolve(new Uint8Array(
          /** @type{!ArrayBuffer} */
          response
        )), (error) => {
          try {
            resolve(getBinarySync(binaryFile));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    return Promise.resolve().then(() => getBinarySync(binaryFile));
  }
  function instantiateArrayBuffer(binaryFile, imports, receiver) {
    return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
      err(`failed to asynchronously prepare wasm: ${reason}`);
      abort(reason);
    });
  }
  function instantiateAsync(binary, binaryFile, imports, callback) {
    if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
      return fetch(binaryFile, {
        credentials: "same-origin"
      }).then((response) => {
        var result = WebAssembly.instantiateStreaming(response, imports);
        return result.then(callback, function(reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
      });
    }
    return instantiateArrayBuffer(binaryFile, imports, callback);
  }
  function getWasmImports() {
    return {
      "a": wasmImports
    };
  }
  function createWasm() {
    var info = getWasmImports();
    function receiveInstance(instance, module2) {
      wasmExports = instance.exports;
      wasmExports = Asyncify.instrumentWasmExports(wasmExports);
      Module["wasmExports"] = wasmExports;
      wasmMemory = wasmExports["Ya"];
      updateMemoryViews();
      wasmTable = wasmExports["ab"];
      addOnInit(wasmExports["Za"]);
      removeRunDependency("wasm-instantiate");
      return wasmExports;
    }
    addRunDependency("wasm-instantiate");
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    if (Module["instantiateWasm"]) {
      try {
        return Module["instantiateWasm"](info, receiveInstance);
      } catch (e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
      }
    }
    if (!wasmBinaryFile)
      wasmBinaryFile = findWasmBinary();
    instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
    return {};
  }
  var tempDouble;
  var tempI64;
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = `Program terminated with exit(${status})`;
    this.status = status;
  }
  var callRuntimeCallbacks = (callbacks) => {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  };
  var noExitRuntime = Module["noExitRuntime"] || false;
  var stackRestore = (val) => __emscripten_stack_restore(val);
  var stackSave = () => _emscripten_stack_get_current();
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  };
  var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  Module["UTF8ToString"] = UTF8ToString;
  var ___assert_fail = (condition, filename, line, func) => {
    abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  };
  var ___call_sighandler = (fp, sig) => ((a1) => dynCall_vi(fp, a1))(sig);
  var initRandomFill = () => {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      return (view) => crypto.getRandomValues(view);
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = require("crypto");
        var randomFillSync = crypto_module["randomFillSync"];
        if (randomFillSync) {
          return (view) => crypto_module["randomFillSync"](view);
        }
        var randomBytes = crypto_module["randomBytes"];
        return (view) => (view.set(randomBytes(view.byteLength)), view);
      } catch (e) {
      }
    }
    abort("initRandomDevice");
  };
  var randomFill = (view) => (randomFill = initRandomFill())(view);
  var PATH = {
    isAbs: (path) => path.charAt(0) === "/",
    splitPath: (filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    },
    normalizeArray: (parts, allowAboveRoot) => {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts.unshift("..");
        }
      }
      return parts;
    },
    normalize: (path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    },
    dirname: (path) => {
      var result = PATH.splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    },
    basename: (path) => {
      if (path === "/")
        return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1)
        return path;
      return path.substr(lastSlash + 1);
    },
    join: (...paths) => PATH.normalize(paths.join("/")),
    join2: (l, r) => PATH.normalize(l + "/" + r)
  };
  var PATH_FS = {
    resolve: (...args) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    },
    relative: (from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== "")
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== "")
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split("/"));
      var toParts = trim(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    }
  };
  var FS_stdin_getChar_buffer = [];
  var lengthBytesUTF8 = (str) => {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      var c = str.charCodeAt(i);
      if (c <= 127) {
        len++;
      } else if (c <= 2047) {
        len += 2;
      } else if (c >= 55296 && c <= 57343) {
        len += 4;
        ++i;
      } else {
        len += 3;
      }
    }
    return len;
  };
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        heap[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        heap[outIdx++] = 192 | u >> 6;
        heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        heap[outIdx++] = 224 | u >> 12;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx)
          break;
        heap[outIdx++] = 240 | u >> 18;
        heap[outIdx++] = 128 | u >> 12 & 63;
        heap[outIdx++] = 128 | u >> 6 & 63;
        heap[outIdx++] = 128 | u & 63;
      }
    }
    heap[outIdx] = 0;
    return outIdx - startIdx;
  };
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
    if (!FS_stdin_getChar_buffer.length) {
      var result = null;
      if (ENVIRONMENT_IS_NODE) {
        var BUFSIZE = 256;
        var buf = Buffer.alloc(BUFSIZE);
        var bytesRead = 0;
        var fd = process.stdin.fd;
        try {
          bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
        } catch (e) {
          if (e.toString().includes("EOF"))
            bytesRead = 0;
          else
            throw e;
        }
        if (bytesRead > 0) {
          result = buf.slice(0, bytesRead).toString("utf-8");
        }
      } else {
      }
      if (!result) {
        return null;
      }
      FS_stdin_getChar_buffer = intArrayFromString(result, true);
    }
    return FS_stdin_getChar_buffer.shift();
  };
  var TTY = {
    ttys: [],
    init() {
    },
    shutdown() {
    },
    register(dev, ops) {
      TTY.ttys[dev] = {
        input: [],
        output: [],
        ops
      };
      FS.registerDevice(dev, TTY.stream_ops);
    },
    stream_ops: {
      open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      },
      close(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      },
      read(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0)
            break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write(stream, buffer, offset, length, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    },
    default_tty_ops: {
      get_char(tty) {
        return FS_stdin_getChar();
      },
      put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      },
      ioctl_tcgets(tty) {
        return {
          c_iflag: 25856,
          c_oflag: 5,
          c_cflag: 191,
          c_lflag: 35387,
          c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
      },
      ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      },
      ioctl_tiocgwinsz(tty) {
        return [24, 80];
      }
    },
    default_tty1_ops: {
      put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        } else {
          if (val != 0)
            tty.output.push(val);
        }
      },
      fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output, 0));
          tty.output = [];
        }
      }
    }
  };
  var zeroMemory = (address, size) => {
    HEAPU8.fill(0, address, address + size);
    return address;
  };
  var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
  var mmapAlloc = (size) => {
    size = alignMemory(size, 65536);
    var ptr = _emscripten_builtin_memalign(65536, size);
    if (!ptr)
      return 0;
    return zeroMemory(ptr, size);
  };
  var MEMFS = {
    ops_table: null,
    mount(mount) {
      return MEMFS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    },
    getFileDataAsTypedArray(node) {
      if (!node.contents)
        return new Uint8Array(0);
      if (node.contents.subarray)
        return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    },
    expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0)
        node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    },
    resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize)
        return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    },
    node_ops: {
      getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      },
      setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      },
      lookup(parent, name) {
        throw FS.genericErrors[44];
      },
      mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      },
      rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      },
      unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      },
      readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      },
      symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | /* 0777 */
        40960, 0);
        node.link = oldpath;
        return node;
      },
      readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      }
    },
    stream_ops: {
      read(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes)
          return 0;
        var size = Math.min(stream.node.usedBytes - position, length);
        if (size > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size), offset);
        } else {
          for (var i = 0; i < size; i++)
            buffer[offset + i] = contents[position + i];
        }
        return size;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length)
          return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length);
            node.usedBytes = length;
            return length;
          } else if (position + length <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length), position);
            return length;
          }
        }
        MEMFS.expandFileStorage(node, position + length);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
        } else {
          for (var i = 0; i < length; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length);
        return length;
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      allocate(stream, offset, length) {
        MEMFS.expandFileStorage(stream.node, offset + length);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          if (position > 0 || position + length < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position, position + length);
            } else {
              contents = Array.prototype.slice.call(contents, position, position + length);
            }
          }
          allocated = true;
          ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          HEAP8.set(contents, ptr);
        }
        return {
          ptr,
          allocated
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var asyncLoad = (url, onload, onerror, noRunDep) => {
    var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
    readAsync(url, (arrayBuffer) => {
      onload(new Uint8Array(arrayBuffer));
      if (dep)
        removeRunDependency(dep);
    }, (event) => {
      if (onerror) {
        onerror();
      } else {
        throw `Loading data file "${url}" failed.`;
      }
    });
    if (dep)
      addRunDependency(dep);
  };
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
    FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
  };
  var preloadPlugins = Module["preloadPlugins"] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
    if (typeof Browser != "undefined")
      Browser.init();
    var handled = false;
    preloadPlugins.forEach((plugin) => {
      if (handled)
        return;
      if (plugin["canHandle"](fullname)) {
        plugin["handle"](byteArray, fullname, finish, onerror);
        handled = true;
      }
    });
    return handled;
  };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency(`cp ${fullname}`);
    function processData(byteArray) {
      function finish(byteArray2) {
        preFinish?.();
        if (!dontCreateFile) {
          FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
        }
        onload?.();
        removeRunDependency(dep);
      }
      if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
        onerror?.();
        removeRunDependency(dep);
      })) {
        return;
      }
      finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      asyncLoad(url, processData, onerror);
    } else {
      processData(url);
    }
  };
  var FS_modeStringToFlags = (str) => {
    var flagModes = {
      "r": 0,
      "r+": 2,
      "w": 512 | 64 | 1,
      "w+": 512 | 64 | 2,
      "a": 1024 | 64 | 1,
      "a+": 1024 | 64 | 2
    };
    var flags = flagModes[str];
    if (typeof flags == "undefined") {
      throw new Error(`Unknown file open mode: ${str}`);
    }
    return flags;
  };
  var FS_getMode = (canRead, canWrite) => {
    var mode = 0;
    if (canRead)
      mode |= 292 | 73;
    if (canWrite)
      mode |= 146;
    return mode;
  };
  var ERRNO_CODES = {
    "EPERM": 63,
    "ENOENT": 44,
    "ESRCH": 71,
    "EINTR": 27,
    "EIO": 29,
    "ENXIO": 60,
    "E2BIG": 1,
    "ENOEXEC": 45,
    "EBADF": 8,
    "ECHILD": 12,
    "EAGAIN": 6,
    "EWOULDBLOCK": 6,
    "ENOMEM": 48,
    "EACCES": 2,
    "EFAULT": 21,
    "ENOTBLK": 105,
    "EBUSY": 10,
    "EEXIST": 20,
    "EXDEV": 75,
    "ENODEV": 43,
    "ENOTDIR": 54,
    "EISDIR": 31,
    "EINVAL": 28,
    "ENFILE": 41,
    "EMFILE": 33,
    "ENOTTY": 59,
    "ETXTBSY": 74,
    "EFBIG": 22,
    "ENOSPC": 51,
    "ESPIPE": 70,
    "EROFS": 69,
    "EMLINK": 34,
    "EPIPE": 64,
    "EDOM": 18,
    "ERANGE": 68,
    "ENOMSG": 49,
    "EIDRM": 24,
    "ECHRNG": 106,
    "EL2NSYNC": 156,
    "EL3HLT": 107,
    "EL3RST": 108,
    "ELNRNG": 109,
    "EUNATCH": 110,
    "ENOCSI": 111,
    "EL2HLT": 112,
    "EDEADLK": 16,
    "ENOLCK": 46,
    "EBADE": 113,
    "EBADR": 114,
    "EXFULL": 115,
    "ENOANO": 104,
    "EBADRQC": 103,
    "EBADSLT": 102,
    "EDEADLOCK": 16,
    "EBFONT": 101,
    "ENOSTR": 100,
    "ENODATA": 116,
    "ETIME": 117,
    "ENOSR": 118,
    "ENONET": 119,
    "ENOPKG": 120,
    "EREMOTE": 121,
    "ENOLINK": 47,
    "EADV": 122,
    "ESRMNT": 123,
    "ECOMM": 124,
    "EPROTO": 65,
    "EMULTIHOP": 36,
    "EDOTDOT": 125,
    "EBADMSG": 9,
    "ENOTUNIQ": 126,
    "EBADFD": 127,
    "EREMCHG": 128,
    "ELIBACC": 129,
    "ELIBBAD": 130,
    "ELIBSCN": 131,
    "ELIBMAX": 132,
    "ELIBEXEC": 133,
    "ENOSYS": 52,
    "ENOTEMPTY": 55,
    "ENAMETOOLONG": 37,
    "ELOOP": 32,
    "EOPNOTSUPP": 138,
    "EPFNOSUPPORT": 139,
    "ECONNRESET": 15,
    "ENOBUFS": 42,
    "EAFNOSUPPORT": 5,
    "EPROTOTYPE": 67,
    "ENOTSOCK": 57,
    "ENOPROTOOPT": 50,
    "ESHUTDOWN": 140,
    "ECONNREFUSED": 14,
    "EADDRINUSE": 3,
    "ECONNABORTED": 13,
    "ENETUNREACH": 40,
    "ENETDOWN": 38,
    "ETIMEDOUT": 73,
    "EHOSTDOWN": 142,
    "EHOSTUNREACH": 23,
    "EINPROGRESS": 26,
    "EALREADY": 7,
    "EDESTADDRREQ": 17,
    "EMSGSIZE": 35,
    "EPROTONOSUPPORT": 66,
    "ESOCKTNOSUPPORT": 137,
    "EADDRNOTAVAIL": 4,
    "ENETRESET": 39,
    "EISCONN": 30,
    "ENOTCONN": 53,
    "ETOOMANYREFS": 141,
    "EUSERS": 136,
    "EDQUOT": 19,
    "ESTALE": 72,
    "ENOTSUP": 138,
    "ENOMEDIUM": 148,
    "EILSEQ": 25,
    "EOVERFLOW": 61,
    "ECANCELED": 11,
    "ENOTRECOVERABLE": 56,
    "EOWNERDEAD": 62,
    "ESTRPIPE": 135
  };
  var NODEFS = {
    isWindows: false,
    staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var flags = process.binding("constants");
      if (flags["fs"]) {
        flags = flags["fs"];
      }
      NODEFS.flagsForNodeMap = {
        1024: flags["O_APPEND"],
        64: flags["O_CREAT"],
        128: flags["O_EXCL"],
        256: flags["O_NOCTTY"],
        0: flags["O_RDONLY"],
        2: flags["O_RDWR"],
        4096: flags["O_SYNC"],
        512: flags["O_TRUNC"],
        1: flags["O_WRONLY"],
        131072: flags["O_NOFOLLOW"]
      };
    },
    convertNodeCode(e) {
      var code = e.code;
      return ERRNO_CODES[code];
    },
    tryFSOperation(f) {
      try {
        return f();
      } catch (e) {
        if (!e.code)
          throw e;
        if (e.code === "UNKNOWN")
          throw new FS.ErrnoError(28);
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    mount(mount) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(28);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = NODEFS.node_ops;
      node.stream_ops = NODEFS.stream_ops;
      return node;
    },
    getMode(path) {
      var stat;
      return NODEFS.tryFSOperation(() => {
        stat = fs.lstatSync(path);
        if (NODEFS.isWindows) {
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return stat.mode;
      });
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    flagsForNode(flags) {
      flags &= ~2097152;
      flags &= ~2048;
      flags &= ~32768;
      flags &= ~524288;
      flags &= ~65536;
      var newFlags = 0;
      for (var k in NODEFS.flagsForNodeMap) {
        if (flags & k) {
          newFlags |= NODEFS.flagsForNodeMap[k];
          flags ^= k;
        }
      }
      if (flags) {
        throw new FS.ErrnoError(28);
      }
      return newFlags;
    },
    node_ops: {
      getattr(node) {
        var path = NODEFS.realPath(node);
        var stat;
        NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
        if (NODEFS.isWindows) {
          if (!stat.blksize) {
            stat.blksize = 4096;
          }
          if (!stat.blocks) {
            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
          }
          stat.mode |= (stat.mode & 292) >> 2;
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (attr.mode !== void 0) {
            fs.chmodSync(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            fs.utimesSync(path, date, date);
          }
          if (attr.size !== void 0) {
            fs.truncateSync(path, attr.size);
          }
        });
      },
      lookup(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        var mode = NODEFS.getMode(path);
        return NODEFS.createNode(parent, name, mode);
      },
      mknod(parent, name, mode, dev) {
        var node = NODEFS.createNode(parent, name, mode, dev);
        var path = NODEFS.realPath(node);
        NODEFS.tryFSOperation(() => {
          if (FS.isDir(node.mode)) {
            fs.mkdirSync(path, node.mode);
          } else {
            fs.writeFileSync(path, "", {
              mode: node.mode
            });
          }
        });
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = NODEFS.realPath(oldNode);
        var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
        NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
        oldNode.name = newName;
      },
      unlink(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.unlinkSync(path));
      },
      rmdir(parent, name) {
        var path = PATH.join2(NODEFS.realPath(parent), name);
        NODEFS.tryFSOperation(() => fs.rmdirSync(path));
      },
      readdir(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readdirSync(path));
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(NODEFS.realPath(parent), newName);
        NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
      },
      readlink(node) {
        var path = NODEFS.realPath(node);
        return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
      }
    },
    stream_ops: {
      open(stream) {
        var path = NODEFS.realPath(stream.node);
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode)) {
            stream.shared.refcount = 1;
            stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
          }
        });
      },
      close(stream) {
        NODEFS.tryFSOperation(() => {
          if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
            fs.closeSync(stream.nfd);
          }
        });
      },
      dup(stream) {
        stream.shared.refcount++;
      },
      read(stream, buffer, offset, length, position) {
        if (length === 0)
          return 0;
        return NODEFS.tryFSOperation(() => fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      write(stream, buffer, offset, length, position) {
        return NODEFS.tryFSOperation(() => fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position));
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            NODEFS.tryFSOperation(() => {
              var stat = fs.fstatSync(stream.nfd);
              position += stat.size;
            });
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      },
      mmap(stream, length, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr = mmapAlloc(length);
        NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
        return 0;
      }
    }
  };
  var PROXYFS = {
    mount(mount) {
      return PROXYFS.createNode(null, "/", mount.opts.fs.lstat(mount.opts.root).mode, 0);
    },
    createNode(parent, name, mode, dev) {
      if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var node = FS.createNode(parent, name, mode);
      node.node_ops = PROXYFS.node_ops;
      node.stream_ops = PROXYFS.stream_ops;
      return node;
    },
    realPath(node) {
      var parts = [];
      while (node.parent !== node) {
        parts.push(node.name);
        node = node.parent;
      }
      parts.push(node.mount.opts.root);
      parts.reverse();
      return PATH.join(...parts);
    },
    node_ops: {
      getattr(node) {
        var path = PROXYFS.realPath(node);
        var stat;
        try {
          stat = node.mount.opts.fs.lstat(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return {
          dev: stat.dev,
          ino: stat.ino,
          mode: stat.mode,
          nlink: stat.nlink,
          uid: stat.uid,
          gid: stat.gid,
          rdev: stat.rdev,
          size: stat.size,
          atime: stat.atime,
          mtime: stat.mtime,
          ctime: stat.ctime,
          blksize: stat.blksize,
          blocks: stat.blocks
        };
      },
      setattr(node, attr) {
        var path = PROXYFS.realPath(node);
        try {
          if (attr.mode !== void 0) {
            node.mount.opts.fs.chmod(path, attr.mode);
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            var date = new Date(attr.timestamp);
            node.mount.opts.fs.utime(path, date, date);
          }
          if (attr.size !== void 0) {
            node.mount.opts.fs.truncate(path, attr.size);
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      lookup(parent, name) {
        try {
          var path = PATH.join2(PROXYFS.realPath(parent), name);
          var mode = parent.mount.opts.fs.lstat(path).mode;
          var node = PROXYFS.createNode(parent, name, mode);
          return node;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      mknod(parent, name, mode, dev) {
        var node = PROXYFS.createNode(parent, name, mode, dev);
        var path = PROXYFS.realPath(node);
        try {
          if (FS.isDir(node.mode)) {
            node.mount.opts.fs.mkdir(path, node.mode);
          } else {
            node.mount.opts.fs.writeFile(path, "", {
              mode: node.mode
            });
          }
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return node;
      },
      rename(oldNode, newDir, newName) {
        var oldPath = PROXYFS.realPath(oldNode);
        var newPath = PATH.join2(PROXYFS.realPath(newDir), newName);
        try {
          oldNode.mount.opts.fs.rename(oldPath, newPath);
          oldNode.name = newName;
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      unlink(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.unlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      rmdir(parent, name) {
        var path = PATH.join2(PROXYFS.realPath(parent), name);
        try {
          parent.mount.opts.fs.rmdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readdir(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readdir(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      symlink(parent, newName, oldPath) {
        var newPath = PATH.join2(PROXYFS.realPath(parent), newName);
        try {
          parent.mount.opts.fs.symlink(oldPath, newPath);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      readlink(node) {
        var path = PROXYFS.realPath(node);
        try {
          return node.mount.opts.fs.readlink(path);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      }
    },
    stream_ops: {
      open(stream) {
        var path = PROXYFS.realPath(stream.node);
        try {
          stream.nfd = stream.node.mount.opts.fs.open(path, stream.flags);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      close(stream) {
        try {
          stream.node.mount.opts.fs.close(stream.nfd);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      read(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.read(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      write(stream, buffer, offset, length, position) {
        try {
          return stream.node.mount.opts.fs.write(stream.nfd, buffer, offset, length, position);
        } catch (e) {
          if (!e.code)
            throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
      },
      llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            try {
              var stat = stream.node.node_ops.getattr(stream.node);
              position += stat.size;
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES[e.code]);
            }
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return position;
      }
    }
  };
  var FS = {
    root: null,
    mounts: [],
    devices: {},
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: false,
    ignorePermissions: true,
    ErrnoError: class {
      constructor(errno) {
        this.name = "ErrnoError";
        this.errno = errno;
      }
    },
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    FSStream: class {
      constructor() {
        this.shared = {};
      }
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    },
    FSNode: class {
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.mounted = null;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.node_ops = {};
        this.stream_ops = {};
        this.rdev = rdev;
        this.readMode = 292 | /*292*/
        73;
        this.writeMode = 146;
      }
      /*146*/
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    },
    lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path)
        return {
          path: "",
          node: null
        };
      var defaults = {
        follow_mount: true,
        recurse_count: 0
      };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts = path.split("/").filter((p) => !!p);
      var current = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts.length; i++) {
        var islast = i === parts.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current = FS.lookupNode(current, parts[i]);
        current_path = PATH.join2(current_path, parts[i]);
        if (FS.isMountpoint(current)) {
          if (!islast || islast && opts.follow_mount) {
            current = current.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count = 0;
          while (FS.isLink(current.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup3 = FS.lookupPath(current_path, {
              recurse_count: opts.recurse_count + 1
            });
            current = lookup3.node;
            if (count++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return {
        path: current_path,
        node: current
      };
    },
    getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount = node.mount.mountpoint;
          if (!path)
            return mount;
          return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    },
    hashName(parentid, name) {
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
      }
      return (parentid + hash >>> 0) % FS.nameTable.length;
    },
    hashAddNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash];
      FS.nameTable[hash] = node;
    },
    hashRemoveNode(node) {
      var hash = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash] === node) {
        FS.nameTable[hash] = node.name_next;
      } else {
        var current = FS.nameTable[hash];
        while (current) {
          if (current.name_next === node) {
            current.name_next = node.name_next;
            break;
          }
          current = current.name_next;
        }
      }
    },
    lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    },
    createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    },
    destroyNode(node) {
      FS.hashRemoveNode(node);
    },
    isRoot(node) {
      return node === node.parent;
    },
    isMountpoint(node) {
      return !!node.mounted;
    },
    isFile(mode) {
      return (mode & 61440) === 32768;
    },
    isDir(mode) {
      return (mode & 61440) === 16384;
    },
    isLink(mode) {
      return (mode & 61440) === 40960;
    },
    isChrdev(mode) {
      return (mode & 61440) === 8192;
    },
    isBlkdev(mode) {
      return (mode & 61440) === 24576;
    },
    isFIFO(mode) {
      return (mode & 61440) === 4096;
    },
    isSocket(mode) {
      return (mode & 49152) === 49152;
    },
    flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    },
    nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    },
    mayLookup(dir) {
      if (!FS.isDir(dir.mode))
        return 54;
      var errCode = FS.nodePermissions(dir, "x");
      if (errCode)
        return errCode;
      if (!dir.node_ops.lookup)
        return 2;
      return 0;
    },
    mayCreate(dir, name) {
      try {
        var node = FS.lookupNode(dir, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir, "wx");
    },
    mayDelete(dir, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    },
    mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    },
    MAX_OPEN_FDS: 4096,
    nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    },
    getStreamChecked(fd) {
      var stream = FS.getStream(fd);
      if (!stream) {
        throw new FS.ErrnoError(8);
      }
      return stream;
    },
    getStream: (fd) => FS.streams[fd],
    createStream(stream, fd = -1) {
      stream = Object.assign(new FS.FSStream(), stream);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream.fd = fd;
      FS.streams[fd] = stream;
      return stream;
    },
    closeStream(fd) {
      FS.streams[fd] = null;
    },
    dupStream(origStream, fd = -1) {
      var stream = FS.createStream(origStream, fd);
      stream.stream_ops?.dup?.(stream);
      return stream;
    },
    chrdev_stream_ops: {
      open(stream) {
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        stream.stream_ops.open?.(stream);
      },
      llseek() {
        throw new FS.ErrnoError(70);
      }
    },
    major: (dev) => dev >> 8,
    minor: (dev) => dev & 255,
    makedev: (ma, mi) => ma << 8 | mi,
    registerDevice(dev, ops) {
      FS.devices[dev] = {
        stream_ops: ops
      };
    },
    getDevice: (dev) => FS.devices[dev],
    getMounts(mount) {
      var mounts = [];
      var check = [mount];
      while (check.length) {
        var m = check.pop();
        mounts.push(m);
        check.push(...m.mounts);
      }
      return mounts;
    },
    syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      function done(errCode) {
        if (errCode) {
          if (!done.errored) {
            done.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      mounts.forEach((mount) => {
        if (!mount.type.syncfs) {
          return done(null);
        }
        mount.type.syncfs(mount, populate, done);
      });
    },
    mount(type, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup3 = FS.lookupPath(mountpoint, {
          follow_mount: false
        });
        mountpoint = lookup3.path;
        node = lookup3.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount = {
        type,
        opts,
        mountpoint,
        mounts: []
      };
      var mountRoot = type.mount(mount);
      mountRoot.mount = mount;
      mount.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount;
        if (node.mount) {
          node.mount.mounts.push(mount);
        }
      }
      return mountRoot;
    },
    unmount(mountpoint) {
      var lookup3 = FS.lookupPath(mountpoint, {
        follow_mount: false
      });
      if (!FS.isMountpoint(lookup3.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup3.node;
      var mount = node.mounted;
      var mounts = FS.getMounts(mount);
      Object.keys(FS.nameTable).forEach((hash) => {
        var current = FS.nameTable[hash];
        while (current) {
          var next = current.name_next;
          if (mounts.includes(current.mount)) {
            FS.destroyNode(current);
          }
          current = next;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount);
      node.mount.mounts.splice(idx, 1);
    },
    lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    },
    mknod(path, mode, dev) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    },
    create(path, mode) {
      mode = mode !== void 0 ? mode : 438;
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    },
    mkdir(path, mode) {
      mode = mode !== void 0 ? mode : 511;
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    },
    mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i])
          continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20)
            throw e;
        }
      }
    },
    mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    },
    symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup3 = FS.lookupPath(newpath, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    },
    rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup3, old_dir, new_dir;
      lookup3 = FS.lookupPath(old_path, {
        parent: true
      });
      old_dir = lookup3.node;
      lookup3 = FS.lookupPath(new_path, {
        parent: true
      });
      new_dir = lookup3.node;
      if (!old_dir || !new_dir)
        throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    },
    rmdir(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    },
    readdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    },
    unlink(path) {
      var lookup3 = FS.lookupPath(path, {
        parent: true
      });
      var parent = lookup3.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    },
    readlink(path) {
      var lookup3 = FS.lookupPath(path);
      var link = lookup3.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
    },
    stat(path, dontFollow) {
      var lookup3 = FS.lookupPath(path, {
        follow: !dontFollow
      });
      var node = lookup3.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    },
    lstat(path) {
      return FS.stat(path, true);
    },
    chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        mode: mode & 4095 | node.mode & ~4095,
        timestamp: Date.now()
      });
    },
    lchmod(path, mode) {
      FS.chmod(path, mode, true);
    },
    fchmod(fd, mode) {
      var stream = FS.getStreamChecked(fd);
      FS.chmod(stream.node, mode);
    },
    chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontFollow
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, {
        timestamp: Date.now()
      });
    },
    lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    },
    fchown(fd, uid, gid) {
      var stream = FS.getStreamChecked(fd);
      FS.chown(stream.node, uid, gid);
    },
    truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup3 = FS.lookupPath(path, {
          follow: true
        });
        node = lookup3.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, {
        size: len,
        timestamp: Date.now()
      });
    },
    ftruncate(fd, len) {
      var stream = FS.getStreamChecked(fd);
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream.node, len);
    },
    utime(path, atime, mtime) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      node.node_ops.setattr(node, {
        timestamp: Math.max(atime, mtime)
      });
    },
    open(path, flags, mode) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = typeof mode == "undefined" ? 438 : (
          /* 0666 */
          mode
        );
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup3 = FS.lookupPath(path, {
            follow: !(flags & 131072)
          });
          node = lookup3.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream = FS.createStream({
        node,
        path: FS.getPath(node),
        flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      });
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
      if (Module["logReadFiles"] && !(flags & 1)) {
        if (!FS.readFiles)
          FS.readFiles = {};
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream;
    },
    close(stream) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (stream.getdents)
        stream.getdents = null;
      try {
        if (stream.stream_ops.close) {
          stream.stream_ops.close(stream);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream.fd);
      }
      stream.fd = null;
    },
    isClosed(stream) {
      return stream.fd === null;
    },
    llseek(stream, offset, whence) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream.seekable || !stream.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream.position = stream.stream_ops.llseek(stream, offset, whence);
      stream.ungotten = [];
      return stream.position;
    },
    read(stream, buffer, offset, length, position) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
      if (!seeking)
        stream.position += bytesRead;
      return bytesRead;
    },
    write(stream, buffer, offset, length, position, canOwn) {
      if (length < 0 || position < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream.seekable && stream.flags & 1024) {
        FS.llseek(stream, 0, 2);
      }
      var seeking = typeof position != "undefined";
      if (!seeking) {
        position = stream.position;
      } else if (!stream.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
      if (!seeking)
        stream.position += bytesWritten;
      return bytesWritten;
    },
    allocate(stream, offset, length) {
      if (FS.isClosed(stream)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream.stream_ops.allocate(stream, offset, length);
    },
    mmap(stream, length, position, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      return stream.stream_ops.mmap(stream, length, position, prot, flags);
    },
    msync(stream, buffer, offset, length, mmapFlags) {
      if (!stream.stream_ops.msync) {
        return 0;
      }
      return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
    },
    ioctl(stream, cmd, arg) {
      if (!stream.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream.stream_ops.ioctl(stream, cmd, arg);
    },
    readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length = stat.size;
      var buf = new Uint8Array(length);
      FS.read(stream, buf, 0, length, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf, 0);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream);
      return ret;
    },
    writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream);
    },
    cwd: () => FS.currentPath,
    chdir(path) {
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      if (lookup3.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup3.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup3.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup3.path;
    },
    createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    },
    createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), {
        read: () => 0,
        write: (stream, buffer, offset, length, pos) => length
      });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = () => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      };
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    },
    createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({
        mount() {
          var node = FS.createNode(
            proc_self,
            "fd",
            16384 | 511,
            /* 0777 */
            73
          );
          node.node_ops = {
            lookup(parent, name) {
              var fd = +name;
              var stream = FS.getStreamChecked(fd);
              var ret = {
                parent: null,
                mount: {
                  mountpoint: "fake"
                },
                node_ops: {
                  readlink: () => stream.path
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      }, {}, "/proc/self/fd");
    },
    createStandardStreams() {
      if (Module["stdin"]) {
        FS.createDevice("/dev", "stdin", Module["stdin"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (Module["stdout"]) {
        FS.createDevice("/dev", "stdout", null, Module["stdout"]);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (Module["stderr"]) {
        FS.createDevice("/dev", "stderr", null, Module["stderr"]);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin = FS.open("/dev/stdin", 0);
      var stdout = FS.open("/dev/stdout", 1);
      var stderr = FS.open("/dev/stderr", 1);
    },
    staticInit() {
      [44].forEach((code) => {
        FS.genericErrors[code] = new FS.ErrnoError(code);
        FS.genericErrors[code].stack = "<generic error, no stack>";
      });
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = {
        "MEMFS": MEMFS,
        "NODEFS": NODEFS,
        "PROXYFS": PROXYFS
      };
    },
    init(input, output, error) {
      FS.init.initialized = true;
      Module["stdin"] = input || Module["stdin"];
      Module["stdout"] = output || Module["stdout"];
      Module["stderr"] = error || Module["stderr"];
      FS.createStandardStreams();
    },
    quit() {
      FS.init.initialized = false;
      _fflush(0);
      for (var i = 0; i < FS.streams.length; i++) {
        var stream = FS.streams[i];
        if (!stream) {
          continue;
        }
        FS.close(stream);
      }
    },
    findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    },
    analyzePath(path, dontResolveLastLink) {
      try {
        var lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        path = lookup3.path;
      } catch (e) {
      }
      var ret = {
        isRoot: false,
        exists: false,
        error: 0,
        name: null,
        path: null,
        object: null,
        parentExists: false,
        parentPath: null,
        parentObject: null
      };
      try {
        var lookup3 = FS.lookupPath(path, {
          parent: true
        });
        ret.parentExists = true;
        ret.parentPath = lookup3.path;
        ret.parentObject = lookup3.node;
        ret.name = PATH.basename(path);
        lookup3 = FS.lookupPath(path, {
          follow: !dontResolveLastLink
        });
        ret.exists = true;
        ret.path = lookup3.path;
        ret.object = lookup3.node;
        ret.name = lookup3.node.name;
        ret.isRoot = lookup3.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    },
    createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts = path.split("/").reverse();
      while (parts.length) {
        var part = parts.pop();
        if (!part)
          continue;
        var current = PATH.join2(parent, part);
        try {
          FS.mkdir(current);
        } catch (e) {
        }
        parent = current;
      }
      return current;
    },
    createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    },
    createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i)
            arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream = FS.open(node, 577);
        FS.write(stream, data, 0, data.length, 0, canOwn);
        FS.close(stream);
        FS.chmod(node, mode);
      }
    },
    createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      if (!FS.createDevice.major)
        FS.createDevice.major = 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, {
        open(stream) {
          stream.seekable = false;
        },
        close(stream) {
          if (output?.buffer?.length) {
            output(10);
          }
        },
        read(stream, buffer, offset, length, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          for (var i = 0; i < length; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      });
      return FS.mkdev(path, mode, dev);
    },
    forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
        return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else if (read_) {
        try {
          obj.contents = intArrayFromString(read_(obj.url), true);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      } else {
        throw new Error("Cannot load without read() or XMLHttpRequest.");
      }
    },
    createLazyFile(parent, name, url, canRead, canWrite) {
      class LazyUint8Array {
        constructor() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to) => {
            if (from > to)
              throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1)
              throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(
                /** @type{Array<number>} */
                xhr2.response || []
              );
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = {
          isDevice: false,
          contents: lazyArray
        };
      } else {
        var properties = {
          isDevice: false,
          url
        };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, {
        usedBytes: {
          get: function() {
            return this.contents.length;
          }
        }
      });
      var stream_ops = {};
      var keys = Object.keys(node.stream_ops);
      keys.forEach((key) => {
        var fn = node.stream_ops[key];
        stream_ops[key] = (...args) => {
          FS.forceLoadFile(node);
          return fn(...args);
        };
      });
      function writeChunks(stream, buffer, offset, length, position) {
        var contents = stream.node.contents;
        if (position >= contents.length)
          return 0;
        var size = Math.min(contents.length - position, length);
        if (contents.slice) {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents[position + i];
          }
        } else {
          for (var i = 0; i < size; i++) {
            buffer[offset + i] = contents.get(position + i);
          }
        }
        return size;
      }
      stream_ops.read = (stream, buffer, offset, length, position) => {
        FS.forceLoadFile(node);
        return writeChunks(stream, buffer, offset, length, position);
      };
      stream_ops.mmap = (stream, length, position, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream, HEAP8, ptr, length, position);
        return {
          ptr,
          allocated: true
        };
      };
      node.stream_ops = stream_ops;
      return node;
    }
  };
  Module["FS"] = FS;
  var SOCKFS = {
    mount(mount) {
      Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
      Module["websocket"]._callbacks = {};
      Module["websocket"]["on"] = /** @this{Object} */
      function(event, callback) {
        if ("function" === typeof callback) {
          this._callbacks[event] = callback;
        }
        return this;
      };
      Module["websocket"].emit = /** @this{Object} */
      function(event, param) {
        if ("function" === typeof this._callbacks[event]) {
          this._callbacks[event].call(this, param);
        }
      };
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createSocket(family, type, protocol) {
      type &= ~526336;
      var streaming = type == 1;
      if (streaming && protocol && protocol != 6) {
        throw new FS.ErrnoError(66);
      }
      var sock = {
        family,
        type,
        protocol,
        server: null,
        error: null,
        peers: {},
        pending: [],
        recv_queue: [],
        sock_ops: SOCKFS.websocket_sock_ops
      };
      var name = SOCKFS.nextname();
      var node = FS.createNode(SOCKFS.root, name, 49152, 0);
      node.sock = sock;
      var stream = FS.createStream({
        path: name,
        node,
        flags: 2,
        seekable: false,
        stream_ops: SOCKFS.stream_ops
      });
      sock.stream = stream;
      return sock;
    },
    getSocket(fd) {
      var stream = FS.getStream(fd);
      if (!stream || !FS.isSocket(stream.node.mode)) {
        return null;
      }
      return stream.node.sock;
    },
    stream_ops: {
      poll(stream) {
        var sock = stream.node.sock;
        return sock.sock_ops.poll(sock);
      },
      ioctl(stream, request, varargs) {
        var sock = stream.node.sock;
        return sock.sock_ops.ioctl(sock, request, varargs);
      },
      read(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        var msg = sock.sock_ops.recvmsg(sock, length);
        if (!msg) {
          return 0;
        }
        buffer.set(msg.buffer, offset);
        return msg.buffer.length;
      },
      write(stream, buffer, offset, length, position) {
        var sock = stream.node.sock;
        return sock.sock_ops.sendmsg(sock, buffer, offset, length);
      },
      close(stream) {
        var sock = stream.node.sock;
        sock.sock_ops.close(sock);
      }
    },
    nextname() {
      if (!SOCKFS.nextname.current) {
        SOCKFS.nextname.current = 0;
      }
      return "socket[" + SOCKFS.nextname.current++ + "]";
    },
    websocket_sock_ops: {
      createPeer(sock, addr, port) {
        var ws;
        if (typeof addr == "object") {
          ws = addr;
          addr = null;
          port = null;
        }
        if (ws) {
          if (ws._socket) {
            addr = ws._socket.remoteAddress;
            port = ws._socket.remotePort;
          } else {
            var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
            if (!result) {
              throw new Error("WebSocket URL must be in the format ws(s)://address:port");
            }
            addr = result[1];
            port = parseInt(result[2], 10);
          }
        } else {
          try {
            var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
            var url = "ws:#".replace("#", "//");
            if (runtimeConfig) {
              if ("function" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"](...arguments);
              } else if ("string" === typeof Module["websocket"]["url"]) {
                url = Module["websocket"]["url"];
              }
            }
            if (url === "ws://" || url === "wss://") {
              var parts = addr.split("/");
              url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
            }
            var subProtocols = "binary";
            if (runtimeConfig) {
              if ("string" === typeof Module["websocket"]["subprotocol"]) {
                subProtocols = Module["websocket"]["subprotocol"];
              }
            }
            var opts = void 0;
            if (subProtocols !== "null") {
              subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
              opts = subProtocols;
            }
            if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
              subProtocols = "null";
              opts = void 0;
            }
            var WebSocketConstructor;
            if (ENVIRONMENT_IS_NODE) {
              WebSocketConstructor = /** @type{(typeof WebSocket)} */
              require_ws();
            } else {
              WebSocketConstructor = WebSocket;
            }
            if (Module["websocket"]["decorator"]) {
              WebSocketConstructor = Module["websocket"]["decorator"](WebSocketConstructor);
            }
            ws = new WebSocketConstructor(url, opts);
            ws.binaryType = "arraybuffer";
          } catch (e) {
            throw new FS.ErrnoError(23);
          }
        }
        var peer = {
          addr,
          port,
          socket: ws,
          dgram_send_queue: []
        };
        SOCKFS.websocket_sock_ops.addPeer(sock, peer);
        SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
        if (sock.type === 2 && typeof sock.sport != "undefined") {
          peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255]));
        }
        return peer;
      },
      getPeer(sock, addr, port) {
        return sock.peers[addr + ":" + port];
      },
      addPeer(sock, peer) {
        sock.peers[peer.addr + ":" + peer.port] = peer;
      },
      removePeer(sock, peer) {
        delete sock.peers[peer.addr + ":" + peer.port];
      },
      handlePeerEvents(sock, peer) {
        var first = true;
        var handleOpen = function() {
          Module["websocket"].emit("open", sock.stream.fd);
          try {
            var queued = peer.dgram_send_queue.shift();
            while (queued) {
              peer.socket.send(queued);
              queued = peer.dgram_send_queue.shift();
            }
          } catch (e) {
            peer.socket.close();
          }
        };
        function handleMessage(data) {
          if (typeof data == "string") {
            var encoder = new TextEncoder();
            data = encoder.encode(data);
          } else {
            assert(data.byteLength !== void 0);
            if (data.byteLength == 0) {
              return;
            }
            data = new Uint8Array(data);
          }
          var wasfirst = first;
          first = false;
          if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
            var newport = data[8] << 8 | data[9];
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
            peer.port = newport;
            SOCKFS.websocket_sock_ops.addPeer(sock, peer);
            return;
          }
          sock.recv_queue.push({
            addr: peer.addr,
            port: peer.port,
            data
          });
          Module["websocket"].emit("message", sock.stream.fd);
        }
        if (ENVIRONMENT_IS_NODE) {
          peer.socket.on("open", handleOpen);
          peer.socket.on("message", function(data, isBinary) {
            if (!isBinary) {
              return;
            }
            handleMessage(new Uint8Array(data).buffer);
          });
          peer.socket.on("close", function() {
            Module["websocket"].emit("close", sock.stream.fd);
          });
          peer.socket.on("error", function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          });
        } else {
          peer.socket.onopen = handleOpen;
          peer.socket.onclose = function() {
            Module["websocket"].emit("close", sock.stream.fd);
          };
          peer.socket.onmessage = function peer_socket_onmessage(event) {
            handleMessage(event.data);
          };
          peer.socket.onerror = function(error) {
            sock.error = 14;
            Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]);
          };
        }
      },
      poll(sock) {
        if (sock.type === 1 && sock.server) {
          return sock.pending.length ? 64 | 1 : 0;
        }
        var mask = 0;
        var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
        if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 64 | 1;
        }
        if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
          mask |= 4;
        }
        if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
          mask |= 16;
        }
        return mask;
      },
      ioctl(sock, request, arg) {
        switch (request) {
          case 21531:
            var bytes = 0;
            if (sock.recv_queue.length) {
              bytes = sock.recv_queue[0].data.length;
            }
            HEAP32[arg >> 2] = bytes;
            return 0;
          default:
            return 28;
        }
      },
      close(sock) {
        if (sock.server) {
          try {
            sock.server.close();
          } catch (e) {
          }
          sock.server = null;
        }
        var peers = Object.keys(sock.peers);
        for (var i = 0; i < peers.length; i++) {
          var peer = sock.peers[peers[i]];
          try {
            peer.socket.close();
          } catch (e) {
          }
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        }
        return 0;
      },
      bind(sock, addr, port) {
        if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") {
          throw new FS.ErrnoError(28);
        }
        sock.saddr = addr;
        sock.sport = port;
        if (sock.type === 2) {
          if (sock.server) {
            sock.server.close();
            sock.server = null;
          }
          try {
            sock.sock_ops.listen(sock, 0);
          } catch (e) {
            if (!(e.name === "ErrnoError"))
              throw e;
            if (e.errno !== 138)
              throw e;
          }
        }
      },
      connect(sock, addr, port) {
        if (sock.server) {
          throw new FS.ErrnoError(138);
        }
        if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
          if (dest) {
            if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(7);
            } else {
              throw new FS.ErrnoError(30);
            }
          }
        }
        var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
        sock.daddr = peer.addr;
        sock.dport = peer.port;
        throw new FS.ErrnoError(26);
      },
      listen(sock, backlog) {
        if (!ENVIRONMENT_IS_NODE) {
          throw new FS.ErrnoError(138);
        }
        if (sock.server) {
          throw new FS.ErrnoError(28);
        }
        var WebSocketServer3 = require_ws().Server;
        var host = sock.saddr;
        if (Module["websocket"]["serverDecorator"]) {
          WebSocketServer3 = Module["websocket"]["serverDecorator"](WebSocketServer3);
        }
        sock.server = new WebSocketServer3({
          host,
          port: sock.sport
        });
        Module["websocket"].emit("listen", sock.stream.fd);
        sock.server.on("connection", function(ws) {
          if (sock.type === 1) {
            var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
            var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
            newsock.daddr = peer.addr;
            newsock.dport = peer.port;
            sock.pending.push(newsock);
            Module["websocket"].emit("connection", newsock.stream.fd);
          } else {
            SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            Module["websocket"].emit("connection", sock.stream.fd);
          }
        });
        sock.server.on("close", function() {
          Module["websocket"].emit("close", sock.stream.fd);
          sock.server = null;
        });
        sock.server.on("error", function(error) {
          sock.error = 23;
          Module["websocket"].emit("error", [sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable"]);
        });
      },
      accept(listensock) {
        if (!listensock.server || !listensock.pending.length) {
          throw new FS.ErrnoError(28);
        }
        var newsock = listensock.pending.shift();
        newsock.stream.flags = listensock.stream.flags;
        return newsock;
      },
      getname(sock, peer) {
        var addr, port;
        if (peer) {
          if (sock.daddr === void 0 || sock.dport === void 0) {
            throw new FS.ErrnoError(53);
          }
          addr = sock.daddr;
          port = sock.dport;
        } else {
          addr = sock.saddr || 0;
          port = sock.sport || 0;
        }
        return {
          addr,
          port
        };
      },
      sendmsg(sock, buffer, offset, length, addr, port) {
        if (sock.type === 2) {
          if (addr === void 0 || port === void 0) {
            addr = sock.daddr;
            port = sock.dport;
          }
          if (addr === void 0 || port === void 0) {
            throw new FS.ErrnoError(17);
          }
        } else {
          addr = sock.daddr;
          port = sock.dport;
        }
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
        if (sock.type === 1) {
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            throw new FS.ErrnoError(53);
          } else if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(6);
          }
        }
        if (ArrayBuffer.isView(buffer)) {
          offset += buffer.byteOffset;
          buffer = buffer.buffer;
        }
        var data;
        data = buffer.slice(offset, offset + length);
        if (sock.type === 2) {
          if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
            }
            dest.dgram_send_queue.push(data);
            return length;
          }
        }
        try {
          dest.socket.send(data);
          return length;
        } catch (e) {
          throw new FS.ErrnoError(28);
        }
      },
      recvmsg(sock, length, flags) {
        if (sock.type === 1 && sock.server) {
          throw new FS.ErrnoError(53);
        }
        var queued = sock.recv_queue.shift();
        if (!queued) {
          if (sock.type === 1) {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (!dest) {
              throw new FS.ErrnoError(53);
            }
            if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              return null;
            }
            throw new FS.ErrnoError(6);
          }
          throw new FS.ErrnoError(6);
        }
        var queuedLength = queued.data.byteLength || queued.data.length;
        var queuedOffset = queued.data.byteOffset || 0;
        var queuedBuffer = queued.data.buffer || queued.data;
        var bytesRead = Math.min(length, queuedLength);
        var res = {
          buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
          addr: queued.addr,
          port: queued.port
        };
        if (flags & 2) {
          bytesRead = 0;
        }
        if (sock.type === 1 && bytesRead < queuedLength) {
          var bytesRemaining = queuedLength - bytesRead;
          queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
          sock.recv_queue.unshift(queued);
        }
        return res;
      }
    }
  };
  var getSocketFromFD = (fd) => {
    var socket = SOCKFS.getSocket(fd);
    if (!socket)
      throw new FS.ErrnoError(8);
    return socket;
  };
  var inetPton4 = (str) => {
    var b = str.split(".");
    for (var i = 0; i < 4; i++) {
      var tmp = Number(b[i]);
      if (isNaN(tmp))
        return null;
      b[i] = tmp;
    }
    return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
  };
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
    var words;
    var w, offset, z;
    var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
    var parts = [];
    if (!valid6regx.test(str)) {
      return null;
    }
    if (str === "::") {
      return [0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (str.startsWith("::")) {
      str = str.replace("::", "Z:");
    } else {
      str = str.replace("::", ":Z:");
    }
    if (str.indexOf(".") > 0) {
      str = str.replace(new RegExp("[.]", "g"), ":");
      words = str.split(":");
      words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
      words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
      words = words.slice(0, words.length - 2);
    } else {
      words = str.split(":");
    }
    offset = 0;
    z = 0;
    for (w = 0; w < words.length; w++) {
      if (typeof words[w] == "string") {
        if (words[w] === "Z") {
          for (z = 0; z < 8 - words.length + 1; z++) {
            parts[w + z] = 0;
          }
          offset = z - 1;
        } else {
          parts[w + offset] = _htons(parseInt(words[w], 16));
        }
      } else {
        parts[w + offset] = words[w];
      }
    }
    return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
  };
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
    switch (family) {
      case 2:
        addr = inetPton4(addr);
        zeroMemory(sa, 16);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 16;
        }
        HEAP16[sa >> 1] = family;
        HEAP32[sa + 4 >> 2] = addr;
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      case 10:
        addr = inetPton6(addr);
        zeroMemory(sa, 28);
        if (addrlen) {
          HEAP32[addrlen >> 2] = 28;
        }
        HEAP32[sa >> 2] = family;
        HEAP32[sa + 8 >> 2] = addr[0];
        HEAP32[sa + 12 >> 2] = addr[1];
        HEAP32[sa + 16 >> 2] = addr[2];
        HEAP32[sa + 20 >> 2] = addr[3];
        HEAP16[sa + 2 >> 1] = _htons(port);
        break;
      default:
        return 5;
    }
    return 0;
  };
  var DNS = {
    address_map: {
      id: 1,
      addrs: {},
      names: {}
    },
    lookup_name(name) {
      var res = inetPton4(name);
      if (res !== null) {
        return name;
      }
      res = inetPton6(name);
      if (res !== null) {
        return name;
      }
      var addr;
      if (DNS.address_map.addrs[name]) {
        addr = DNS.address_map.addrs[name];
      } else {
        var id = DNS.address_map.id++;
        assert(id < 65535, "exceeded max address mappings of 65535");
        addr = "172.29." + (id & 255) + "." + (id & 65280);
        DNS.address_map.names[addr] = name;
        DNS.address_map.addrs[name] = addr;
      }
      return addr;
    },
    lookup_addr(addr) {
      if (DNS.address_map.names[addr]) {
        return DNS.address_map.names[addr];
      }
      return null;
    }
  };
  function ___syscall_accept4(fd, addr, addrlen, flags, d1, d2) {
    try {
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
      }
      return newsock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var inetNtop4 = (addr) => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
  var inetNtop6 = (ints) => {
    var str = "";
    var word = 0;
    var longest = 0;
    var lastzero = 0;
    var zstart = 0;
    var len = 0;
    var i = 0;
    var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
    var hasipv4 = true;
    var v4part = "";
    for (i = 0; i < 5; i++) {
      if (parts[i] !== 0) {
        hasipv4 = false;
        break;
      }
    }
    if (hasipv4) {
      v4part = inetNtop4(parts[6] | parts[7] << 16);
      if (parts[5] === -1) {
        str = "::ffff:";
        str += v4part;
        return str;
      }
      if (parts[5] === 0) {
        str = "::";
        if (v4part === "0.0.0.0")
          v4part = "";
        if (v4part === "0.0.0.1")
          v4part = "1";
        str += v4part;
        return str;
      }
    }
    for (word = 0; word < 8; word++) {
      if (parts[word] === 0) {
        if (word - lastzero > 1) {
          len = 0;
        }
        lastzero = word;
        len++;
      }
      if (len > longest) {
        longest = len;
        zstart = word - longest + 1;
      }
    }
    for (word = 0; word < 8; word++) {
      if (longest > 1) {
        if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
          if (word === zstart) {
            str += ":";
            if (zstart === 0)
              str += ":";
          }
          continue;
        }
      }
      str += Number(_ntohs(parts[word] & 65535)).toString(16);
      str += word < 7 ? ":" : "";
    }
    return str;
  };
  var readSockaddr = (sa, salen) => {
    var family = HEAP16[sa >> 1];
    var port = _ntohs(HEAPU16[sa + 2 >> 1]);
    var addr;
    switch (family) {
      case 2:
        if (salen !== 16) {
          return {
            errno: 28
          };
        }
        addr = HEAP32[sa + 4 >> 2];
        addr = inetNtop4(addr);
        break;
      case 10:
        if (salen !== 28) {
          return {
            errno: 28
          };
        }
        addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]];
        addr = inetNtop6(addr);
        break;
      default:
        return {
          errno: 5
        };
    }
    return {
      family,
      addr,
      port
    };
  };
  var getSocketAddress = (addrp, addrlen, allowNull) => {
    if (allowNull && addrp === 0)
      return null;
    var info = readSockaddr(addrp, addrlen);
    if (info.errno)
      throw new FS.ErrnoError(info.errno);
    info.addr = DNS.lookup_addr(info.addr) || info.addr;
    return info;
  };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir;
      }
      return PATH.join2(dir, path);
    },
    doStat(func, path, buf) {
      var stat = func(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    },
    doMsync(addr, stream, len, flags, offset) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer = HEAPU8.slice(addr, addr + len);
      FS.msync(stream, buffer, offset, len, flags);
    },
    getStreamFromFD(fd) {
      var stream = FS.getStreamChecked(fd);
      return stream;
    },
    varargs: void 0,
    getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    }
  };
  function ___syscall_chdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_chmod(path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup(fd) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_dup3(fd, newfd, flags) {
    try {
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd)
        return -28;
      var existing = FS.getStream(newfd);
      if (existing)
        FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_faccessat(dirfd, path, amode, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        return -28;
      }
      var lookup3 = FS.lookupPath(path, {
        follow: true
      });
      var node = lookup3.node;
      if (!node) {
        return -44;
      }
      var perms = "";
      if (amode & 4)
        perms += "r";
      if (amode & 2)
        perms += "w";
      if (amode & 1)
        perms += "x";
      if (perms && /* otherwise, they've just passed F_OK */
      FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchmod(fd, mode) {
    try {
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchown32(fd, owner, group) {
    try {
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fchownat(dirfd, path, owner, group, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      flags = flags & ~256;
      path = SYSCALLS.calculateAt(dirfd, path);
      (nofollow ? FS.lchown : FS.chown)(path, owner, group);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function syscallGetVarargI() {
    var ret = HEAP32[+SYSCALLS.varargs >> 2];
    SYSCALLS.varargs += 4;
    return ret;
  }
  var syscallGetVarargP = syscallGetVarargI;
  function ___syscall_fcntl64(fd, cmd, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          HEAP16[arg + offset >> 1] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0;
      }
      return -28;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_fstat64(fd, buf) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
  function ___syscall_ftruncate64(fd, length_low, length_high) {
    var length = convertI32PairToI53Checked(length_low, length_high);
    try {
      if (isNaN(length))
        return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  Module["stringToUTF8"] = stringToUTF8;
  function ___syscall_getcwd(buf, size) {
    try {
      if (size === 0)
        return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes)
        return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getdents64(fd, dirp, count) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      stream.getdents ||= FS.readdir(stream.path);
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
      var idx = Math.floor(off / struct_size);
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === ".") {
          id = stream.node.id;
          type = 4;
        } else if (name === "..") {
          var lookup3 = FS.lookupPath(stream.path, {
            parent: true
          });
          id = lookup3.node.id;
          type = 4;
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
        }
        tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];
        tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];
        HEAP16[dirp + pos + 16 >> 1] = 280;
        HEAP8[dirp + pos + 18] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      if (!sock.daddr) {
        return -53;
      }
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
    try {
      var sock = getSocketFromFD(fd);
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport, addrlen);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
    try {
      var sock = getSocketFromFD(fd);
      if (level === 1) {
        if (optname === 4) {
          HEAP32[optval >> 2] = sock.error;
          HEAP32[optlen >> 2] = 4;
          sock.error = null;
          return 0;
        }
      }
      return -50;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_ioctl(fd, op, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = termios.c_iflag || 0;
            HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
            HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
            HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[argp >> 2];
            var c_oflag = HEAP32[argp + 4 >> 2];
            var c_cflag = HEAP32[argp + 8 >> 2];
            var c_lflag = HEAP32[argp + 12 >> 2];
            var c_cc = [];
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[argp + i + 17]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
              c_iflag,
              c_oflag,
              c_cflag,
              c_lflag,
              c_cc
            });
          }
          return 0;
        }
        case 21519: {
          if (!stream.tty)
            return -59;
          var argp = syscallGetVarargP();
          HEAP32[argp >> 2] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty)
            return -59;
          return -28;
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          if (!stream.tty)
            return -59;
          if (stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[argp >> 1] = winsize[0];
            HEAP16[argp + 2 >> 1] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty)
            return -59;
          return 0;
        }
        default:
          return -28;
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_listen(fd, backlog) {
    try {
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_lstat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_mkdirat(dirfd, path, mode) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      path = PATH.normalize(path);
      if (path[path.length - 1] === "/")
        path = path.substr(0, path.length - 1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_newfstatat(dirfd, path, buf, flags) {
    try {
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & ~6400;
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_openat(dirfd, path, flags, varargs) {
    SYSCALLS.varargs = varargs;
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var PIPEFS = {
    BUCKET_BUFFER_SIZE: 8192,
    mount(mount) {
      return FS.createNode(
        null,
        "/",
        16384 | 511,
        /* 0777 */
        0
      );
    },
    createPipe() {
      var pipe = {
        buckets: [],
        refcnt: 2
      };
      pipe.buckets.push({
        buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
        offset: 0,
        roffset: 0
      });
      var rName = PIPEFS.nextname();
      var wName = PIPEFS.nextname();
      var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
      var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
      rNode.pipe = pipe;
      wNode.pipe = pipe;
      var readableStream = FS.createStream({
        path: rName,
        node: rNode,
        flags: 0,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      rNode.stream = readableStream;
      var writableStream = FS.createStream({
        path: wName,
        node: wNode,
        flags: 1,
        seekable: false,
        stream_ops: PIPEFS.stream_ops
      });
      wNode.stream = writableStream;
      return {
        readable_fd: readableStream.fd,
        writable_fd: writableStream.fd
      };
    },
    stream_ops: {
      poll(stream) {
        var pipe = stream.node.pipe;
        if ((stream.flags & 2097155) === 1) {
          return 256 | 4;
        }
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return 64 | 1;
            }
          }
        }
        return 0;
      },
      ioctl(stream, request, varargs) {
        return 28;
      },
      fsync(stream) {
        return 28;
      },
      read(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var currentLength = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var bucket = pipe.buckets[i];
          currentLength += bucket.offset - bucket.roffset;
        }
        var data = buffer.subarray(offset, offset + length);
        if (length <= 0) {
          return 0;
        }
        if (currentLength == 0) {
          throw new FS.ErrnoError(6);
        }
        var toRead = Math.min(currentLength, length);
        var totalRead = toRead;
        var toRemove = 0;
        for (var i = 0; i < pipe.buckets.length; i++) {
          var currBucket = pipe.buckets[i];
          var bucketSize = currBucket.offset - currBucket.roffset;
          if (toRead <= bucketSize) {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            if (toRead < bucketSize) {
              tmpSlice = tmpSlice.subarray(0, toRead);
              currBucket.roffset += toRead;
            } else {
              toRemove++;
            }
            data.set(tmpSlice);
            break;
          } else {
            var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
            data.set(tmpSlice);
            data = data.subarray(tmpSlice.byteLength);
            toRead -= tmpSlice.byteLength;
            toRemove++;
          }
        }
        if (toRemove && toRemove == pipe.buckets.length) {
          toRemove--;
          pipe.buckets[toRemove].offset = 0;
          pipe.buckets[toRemove].roffset = 0;
        }
        pipe.buckets.splice(0, toRemove);
        return totalRead;
      },
      write(stream, buffer, offset, length, position) {
        var pipe = stream.node.pipe;
        var data = buffer.subarray(offset, offset + length);
        var dataLen = data.byteLength;
        if (dataLen <= 0) {
          return 0;
        }
        var currBucket = null;
        if (pipe.buckets.length == 0) {
          currBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: 0,
            roffset: 0
          };
          pipe.buckets.push(currBucket);
        } else {
          currBucket = pipe.buckets[pipe.buckets.length - 1];
        }
        assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
        var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
        if (freeBytesInCurrBuffer >= dataLen) {
          currBucket.buffer.set(data, currBucket.offset);
          currBucket.offset += dataLen;
          return dataLen;
        } else if (freeBytesInCurrBuffer > 0) {
          currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
          currBucket.offset += freeBytesInCurrBuffer;
          data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
        }
        var numBuckets = data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0;
        var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
        for (var i = 0; i < numBuckets; i++) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: PIPEFS.BUCKET_BUFFER_SIZE,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
          data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
        }
        if (remElements > 0) {
          var newBucket = {
            buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
            offset: data.byteLength,
            roffset: 0
          };
          pipe.buckets.push(newBucket);
          newBucket.buffer.set(data);
        }
        return dataLen;
      },
      close(stream) {
        var pipe = stream.node.pipe;
        pipe.refcnt--;
        if (pipe.refcnt === 0) {
          pipe.buckets = null;
        }
      }
    },
    nextname() {
      if (!PIPEFS.nextname.current) {
        PIPEFS.nextname.current = 0;
      }
      return "pipe[" + PIPEFS.nextname.current++ + "]";
    }
  };
  function ___syscall_pipe(fdPtr) {
    try {
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
      var res = PIPEFS.createPipe();
      HEAP32[fdPtr >> 2] = res.readable_fd;
      HEAP32[fdPtr + 4 >> 2] = res.writable_fd;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_poll(fds, nfds, timeout) {
    try {
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[pollfd >> 2];
        var events = HEAP16[pollfd + 4 >> 1];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops?.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask)
          nonzero++;
        HEAP16[pollfd + 6 >> 1] = mask;
      }
      return nonzero;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0)
        return -28;
      var ret = FS.readlink(path);
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf + len];
      stringToUTF8(ret, buf, bufsize + 1);
      HEAP8[buf + len] = endChar;
      return len;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
    try {
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len, typeof flags !== "undefined" ? flags : 0);
      if (!msg)
        return 0;
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
    try {
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_rmdir(path) {
    try {
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
    try {
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        return FS.write(sock.stream, HEAP8, message, length);
      }
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_socket(domain, type, protocol) {
    try {
      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_stat64(path, buf) {
    try {
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_statfs64(path, size, buf) {
    try {
      path = SYSCALLS.getStr(path);
      HEAP32[buf + 4 >> 2] = 4096;
      HEAP32[buf + 40 >> 2] = 4096;
      HEAP32[buf + 8 >> 2] = 1e6;
      HEAP32[buf + 12 >> 2] = 5e5;
      HEAP32[buf + 16 >> 2] = 5e5;
      HEAP32[buf + 20 >> 2] = FS.nextInode;
      HEAP32[buf + 24 >> 2] = 1e6;
      HEAP32[buf + 28 >> 2] = 42;
      HEAP32[buf + 44 >> 2] = 2;
      HEAP32[buf + 36 >> 2] = 255;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_symlink(target, linkpath) {
    try {
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function ___syscall_unlinkat(dirfd, path, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort("Invalid flags passed to unlinkat");
      }
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
  function ___syscall_utimensat(dirfd, path, times, flags) {
    try {
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[times + 8 >> 2];
        atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[times + 8 >> 2];
        mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var __abort_js = () => {
    abort("");
  };
  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  var __emscripten_lookup_name = (name) => {
    var nameString = UTF8ToString(name);
    return inetPton4(DNS.lookup_name(nameString));
  };
  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
  var __emscripten_runtime_keepalive_clear = () => {
    noExitRuntime = false;
    runtimeKeepaliveCounter = 0;
  };
  var __emscripten_throw_longjmp = () => {
    throw Infinity;
  };
  function __gmtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
  }
  var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var ydayFromDate = (date) => {
    var leap = isLeapYear(date.getFullYear());
    var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
    var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
    return yday;
  };
  function __localtime_js(time_low, time_high, tmPtr) {
    var time = convertI32PairToI53Checked(time_low, time_high);
    var date = new Date(time * 1e3);
    HEAP32[tmPtr >> 2] = date.getSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getHours();
    HEAP32[tmPtr + 12 >> 2] = date.getDate();
    HEAP32[tmPtr + 16 >> 2] = date.getMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getDay();
    var yday = ydayFromDate(date) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
    var start = new Date(date.getFullYear(), 0, 1);
    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
    var winterOffset = start.getTimezoneOffset();
    var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
    HEAP32[tmPtr + 32 >> 2] = dst;
  }
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var __mktime_js = function(tmPtr) {
    var ret = (() => {
      var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0);
      var dst = HEAP32[tmPtr + 32 >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getYear();
      var timeMs = date.getTime();
      if (isNaN(timeMs)) {
        return -1;
      }
      return timeMs / 1e3;
    })();
    return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0;
  };
  function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[allocated >> 2] = res.allocated;
      HEAPU32[addr >> 2] = ptr;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return -e.errno;
    }
  }
  var timers = {};
  var handleException = (e) => {
    if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
    }
    quit_(1, e);
  };
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
    EXITSTATUS = code;
    if (!keepRuntimeAlive()) {
      Module["onExit"]?.(code);
      ABORT = true;
    }
    quit_(code, new ExitStatus(code));
  };
  var exitJS = (status, implicit) => {
    EXITSTATUS = status;
    if (!keepRuntimeAlive()) {
      exitRuntime();
    }
    _proc_exit(status);
  };
  var _exit = exitJS;
  Module["_exit"] = _exit;
  var maybeExit = () => {
    if (runtimeExited) {
      return;
    }
    if (!keepRuntimeAlive()) {
      try {
        _exit(EXITSTATUS);
      } catch (e) {
        handleException(e);
      }
    }
  };
  var callUserCallback = (func) => {
    if (runtimeExited || ABORT) {
      return;
    }
    try {
      func();
      maybeExit();
    } catch (e) {
      handleException(e);
    }
  };
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  var __setitimer_js = (which, timeout_ms) => {
    if (timers[which]) {
      clearTimeout(timers[which].id);
      delete timers[which];
    }
    if (!timeout_ms)
      return 0;
    var id = setTimeout(() => {
      delete timers[which];
      callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
    }, timeout_ms);
    timers[which] = {
      id,
      timeout_ms
    };
    return 0;
  };
  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    var winter = new Date(currentYear, 0, 1);
    var summer = new Date(currentYear, 6, 1);
    var winterOffset = winter.getTimezoneOffset();
    var summerOffset = summer.getTimezoneOffset();
    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
    HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
    var extractZone = (date) => date.toLocaleTimeString(void 0, {
      hour12: false,
      timeZoneName: "short"
    }).split(" ")[1];
    var winterName = extractZone(winter);
    var summerName = extractZone(summer);
    if (summerOffset < winterOffset) {
      stringToUTF8(winterName, std_name, 17);
      stringToUTF8(summerName, dst_name, 17);
    } else {
      stringToUTF8(winterName, dst_name, 17);
      stringToUTF8(summerName, std_name, 17);
    }
  };
  var _emscripten_date_now = () => Date.now();
  var getHeapMax = () => 2147483648;
  var _emscripten_get_heap_max = () => getHeapMax();
  var growMemory = (size) => {
    var b = wasmMemory.buffer;
    var pages = (size - b.byteLength + 65535) / 65536;
    try {
      wasmMemory.grow(pages);
      updateMemoryViews();
      return 1;
    } catch (e) {
    }
  };
  var _emscripten_resize_heap = (requestedSize) => {
    var oldSize = HEAPU8.length;
    requestedSize >>>= 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      var replacement = growMemory(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  };
  var runtimeKeepalivePush = () => {
    runtimeKeepaliveCounter += 1;
  };
  var runtimeKeepalivePop = () => {
    runtimeKeepaliveCounter -= 1;
  };
  var safeSetTimeout = (func, timeout) => {
    runtimeKeepalivePush();
    return setTimeout(() => {
      runtimeKeepalivePop();
      callUserCallback(func);
    }, timeout);
  };
  var _emscripten_sleep = (ms) => Asyncify.handleSleep((wakeUp) => safeSetTimeout(wakeUp, ms));
  Module["_emscripten_sleep"] = _emscripten_sleep;
  _emscripten_sleep.isAsync = true;
  var ENV = PHPLoader.ENV || {};
  var getExecutableName = () => thisProgram || "./this.program";
  var getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        "USER": "web_user",
        "LOGNAME": "web_user",
        "PATH": "/",
        "PWD": "/",
        "HOME": "/home/web_user",
        "LANG": lang,
        "_": getExecutableName()
      };
      for (var x in ENV) {
        if (ENV[x] === void 0)
          delete env[x];
        else
          env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
        strings.push(`${x}=${env[x]}`);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  };
  var stringToAscii = (str, buffer) => {
    for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++] = str.charCodeAt(i);
    }
    HEAP8[buffer] = 0;
  };
  var _environ_get = (__environ, environ_buf) => {
    var bufSize = 0;
    getEnvStrings().forEach((string, i) => {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i * 4 >> 2] = ptr;
      stringToAscii(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  };
  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach((string) => bufSize += string.length + 1);
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  };
  function _fd_close(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_fdstat_get(fd, pbuf) {
    try {
      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
      }
      HEAP8[pbuf] = type;
      HEAP16[pbuf + 2 >> 1] = flags;
      tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
      tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var doReadv = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (curr < len)
        break;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_read(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
    try {
      if (isNaN(offset))
        return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
      if (stream.getdents && offset === 0 && whence === 0)
        stream.getdents = null;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _fd_sync = function(fd) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep((wakeUp) => {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, (err2) => {
          if (err2) {
            wakeUp(29);
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  };
  _fd_sync.isAsync = true;
  var doWritev = (stream, iov, iovcnt, offset) => {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0)
        return -1;
      ret += curr;
      if (typeof offset != "undefined") {
        offset += curr;
      }
    }
    return ret;
  };
  function _fd_write(fd, iov, iovcnt, pnum) {
    try {
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[pnum >> 2] = num;
      return 0;
    } catch (e) {
      if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
        throw e;
      return e.errno;
    }
  }
  var _getaddrinfo = (node, service, hint, out2) => {
    var addr = 0;
    var port = 0;
    var flags = 0;
    var family = 0;
    var type = 0;
    var proto = 0;
    var ai;
    function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
      var sa, salen, ai2;
      var errno;
      salen = family2 === 10 ? 28 : 16;
      addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
      sa = _malloc(salen);
      errno = writeSockaddr(sa, family2, addr2, port2);
      assert(!errno);
      ai2 = _malloc(32);
      HEAP32[ai2 + 4 >> 2] = family2;
      HEAP32[ai2 + 8 >> 2] = type2;
      HEAP32[ai2 + 12 >> 2] = proto2;
      HEAPU32[ai2 + 24 >> 2] = canon;
      HEAPU32[ai2 + 20 >> 2] = sa;
      if (family2 === 10) {
        HEAP32[ai2 + 16 >> 2] = 28;
      } else {
        HEAP32[ai2 + 16 >> 2] = 16;
      }
      HEAP32[ai2 + 28 >> 2] = 0;
      return ai2;
    }
    if (hint) {
      flags = HEAP32[hint >> 2];
      family = HEAP32[hint + 4 >> 2];
      type = HEAP32[hint + 8 >> 2];
      proto = HEAP32[hint + 12 >> 2];
    }
    if (type && !proto) {
      proto = type === 2 ? 17 : 6;
    }
    if (!type && proto) {
      type = proto === 17 ? 2 : 1;
    }
    if (proto === 0) {
      proto = 6;
    }
    if (type === 0) {
      type = 1;
    }
    if (!node && !service) {
      return -2;
    }
    if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
      return -1;
    }
    if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) {
      return -1;
    }
    if (flags & 32) {
      return -2;
    }
    if (type !== 0 && type !== 1 && type !== 2) {
      return -7;
    }
    if (family !== 0 && family !== 2 && family !== 10) {
      return -6;
    }
    if (service) {
      service = UTF8ToString(service);
      port = parseInt(service, 10);
      if (isNaN(port)) {
        if (flags & 1024) {
          return -2;
        }
        return -8;
      }
    }
    if (!node) {
      if (family === 0) {
        family = 2;
      }
      if ((flags & 1) === 0) {
        if (family === 2) {
          addr = _htonl(2130706433);
        } else {
          addr = [0, 0, 0, 1];
        }
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    node = UTF8ToString(node);
    addr = inetPton4(node);
    if (addr !== null) {
      if (family === 0 || family === 2) {
        family = 2;
      } else if (family === 10 && flags & 8) {
        addr = [0, 0, _htonl(65535), addr];
        family = 10;
      } else {
        return -2;
      }
    } else {
      addr = inetPton6(node);
      if (addr !== null) {
        if (family === 0 || family === 10) {
          family = 10;
        } else {
          return -2;
        }
      }
    }
    if (addr != null) {
      ai = allocaddrinfo(family, type, proto, node, addr, port);
      HEAPU32[out2 >> 2] = ai;
      return 0;
    }
    if (flags & 4) {
      return -2;
    }
    node = DNS.lookup_name(node);
    addr = inetPton4(node);
    if (family === 0) {
      family = 2;
    } else if (family === 10) {
      addr = [0, 0, _htonl(65535), addr];
    }
    ai = allocaddrinfo(family, type, proto, null, addr, port);
    HEAPU32[out2 >> 2] = ai;
    return 0;
  };
  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
    var info = readSockaddr(sa, salen);
    if (info.errno) {
      return -6;
    }
    var port = info.port;
    var addr = info.addr;
    var overflowed = false;
    if (node && nodelen) {
      var lookup3;
      if (flags & 1 || !(lookup3 = DNS.lookup_addr(addr))) {
        if (flags & 8) {
          return -2;
        }
      } else {
        addr = lookup3;
      }
      var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
      if (numBytesWrittenExclNull + 1 >= nodelen) {
        overflowed = true;
      }
    }
    if (serv && servlen) {
      port = "" + port;
      var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
      if (numBytesWrittenExclNull + 1 >= servlen) {
        overflowed = true;
      }
    }
    if (overflowed) {
      return -12;
    }
    return 0;
  };
  var Protocols = {
    list: [],
    map: {}
  };
  var _setprotoent = (stayopen) => {
    function allocprotoent(name, proto, aliases) {
      var nameBuf = _malloc(name.length + 1);
      stringToAscii(name, nameBuf);
      var j = 0;
      var length = aliases.length;
      var aliasListBuf = _malloc((length + 1) * 4);
      for (var i = 0; i < length; i++, j += 4) {
        var alias = aliases[i];
        var aliasBuf = _malloc(alias.length + 1);
        stringToAscii(alias, aliasBuf);
        HEAPU32[aliasListBuf + j >> 2] = aliasBuf;
      }
      HEAPU32[aliasListBuf + j >> 2] = 0;
      var pe = _malloc(12);
      HEAPU32[pe >> 2] = nameBuf;
      HEAPU32[pe + 4 >> 2] = aliasListBuf;
      HEAP32[pe + 8 >> 2] = proto;
      return pe;
    }
    var list = Protocols.list;
    var map = Protocols.map;
    if (list.length === 0) {
      var entry = allocprotoent("tcp", 6, ["TCP"]);
      list.push(entry);
      map["tcp"] = map["6"] = entry;
      entry = allocprotoent("udp", 17, ["UDP"]);
      list.push(entry);
      map["udp"] = map["17"] = entry;
    }
    _setprotoent.index = 0;
  };
  var _getprotobyname = (name) => {
    name = UTF8ToString(name);
    _setprotoent(true);
    var result = Protocols.map[name];
    return result;
  };
  var _getprotobynumber = (number) => {
    _setprotoent(true);
    var result = Protocols.map[number];
    return result;
  };
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
    var size = lengthBytesUTF8(str) + 1;
    var ret = stackAlloc(size);
    stringToUTF8(str, ret, size);
    return ret;
  };
  var allocateUTF8OnStack = stringToUTF8OnStack;
  var PHPWASM = {
    init: function() {
      FS.mkdir("/internal");
      FS.mkdir("/internal/shared");
      FS.mkdir("/internal/shared/preload");
      PHPWASM.EventEmitter = ENVIRONMENT_IS_NODE ? require("events").EventEmitter : class EventEmitter {
        constructor() {
          this.listeners = {};
        }
        emit(eventName, data) {
          if (this.listeners[eventName]) {
            this.listeners[eventName].forEach((callback) => {
              callback(data);
            });
          }
        }
        once(eventName, callback) {
          const self2 = this;
          function removedCallback() {
            callback(...arguments);
            self2.removeListener(eventName, removedCallback);
          }
          this.on(eventName, removedCallback);
        }
        removeAllListeners(eventName) {
          if (eventName) {
            delete this.listeners[eventName];
          } else {
            this.listeners = {};
          }
        }
        removeListener(eventName, callback) {
          if (this.listeners[eventName]) {
            const idx = this.listeners[eventName].indexOf(callback);
            if (idx !== -1) {
              this.listeners[eventName].splice(idx, 1);
            }
          }
        }
      };
      PHPWASM.child_proc_by_fd = {};
      PHPWASM.child_proc_by_pid = {};
      PHPWASM.input_devices = {};
    },
    getAllWebSockets: function(sock) {
      const webSockets = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.server.clients.forEach((ws) => {
          webSockets.add(ws);
        });
      }
      for (const peer of PHPWASM.getAllPeers(sock)) {
        webSockets.add(peer.socket);
      }
      return Array.from(webSockets);
    },
    getAllPeers: function(sock) {
      const peers = /* @__PURE__ */ new Set();
      if (sock.server) {
        sock.pending.filter((pending) => pending.peers).forEach((pending) => {
          for (const peer of Object.values(pending.peers)) {
            peers.add(peer);
          }
        });
      }
      if (sock.peers) {
        for (const peer of Object.values(sock.peers)) {
          peers.add(peer);
        }
      }
      return Array.from(peers);
    },
    awaitData: function(ws) {
      return PHPWASM.awaitEvent(ws, "message");
    },
    awaitConnection: function(ws) {
      if (ws.OPEN === ws.readyState) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "open");
    },
    awaitClose: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "close");
    },
    awaitError: function(ws) {
      if ([ws.CLOSING, ws.CLOSED].includes(ws.readyState)) {
        return [Promise.resolve(), PHPWASM.noop];
      }
      return PHPWASM.awaitEvent(ws, "error");
    },
    awaitEvent: function(ws, event) {
      let resolve;
      const listener = () => {
        resolve();
      };
      const promise = new Promise(function(_resolve) {
        resolve = _resolve;
        ws.once(event, listener);
      });
      const cancel = () => {
        ws.removeListener(event, listener);
        setTimeout(resolve);
      };
      return [promise, cancel];
    },
    noop: function() {
    },
    spawnProcess: function(command, args, options) {
      if (Module["spawnProcess"]) {
        const spawnedPromise = Module["spawnProcess"](command, args, options);
        return Promise.resolve(spawnedPromise).then(function(spawned) {
          if (!spawned || !spawned.on) {
            throw new Error("spawnProcess() must return an EventEmitter but returned a different type.");
          }
          return spawned;
        });
      }
      if (ENVIRONMENT_IS_NODE) {
        return require("child_process").spawn(command, args, {
          ...options,
          shell: true,
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 100
        });
      }
      const e = new Error("popen(), proc_open() etc. are unsupported in the browser. Call php.setSpawnHandler() and provide a callback to handle spawning processes, or disable a popen(), proc_open() and similar functions via php.ini.");
      e.code = "SPAWN_UNSUPPORTED";
      throw e;
    },
    shutdownSocket: function(socketd, how) {
      const sock = getSocketFromFD(socketd);
      const peer = Object.values(sock.peers)[0];
      if (!peer) {
        return -1;
      }
      try {
        peer.socket.close();
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
        return 0;
      } catch (e) {
        console.log("Socket shutdown error", e);
        return -1;
      }
    }
  };
  function _js_create_input_device(deviceId) {
    let dataBuffer = [];
    let dataCallback;
    const filename = "proc_id_" + deviceId;
    const device = FS.createDevice("/dev", filename, function() {
    }, function(byte) {
      try {
        dataBuffer.push(byte);
        if (dataCallback) {
          dataCallback(new Uint8Array(dataBuffer));
          dataBuffer = [];
        }
      } catch (e) {
        console.error(e);
        throw e;
      }
    });
    const devicePath = "/dev/" + filename;
    PHPWASM.input_devices[deviceId] = {
      devicePath,
      onData: function(cb) {
        dataCallback = cb;
        dataBuffer.forEach(function(data) {
          cb(data);
        });
        dataBuffer.length = 0;
      }
    };
    return allocateUTF8OnStack(devicePath);
  }
  function _js_fd_read(fd, iov, iovcnt, pnum) {
    if (Asyncify.state === Asyncify.State.Normal) {
      var returnCode;
      var stream;
      let num = 0;
      try {
        stream = SYSCALLS.getStreamFromFD(fd);
        const num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
          throw e;
        }
        if (e.errno !== 6 || !(stream?.fd in PHPWASM.child_proc_by_fd)) {
          HEAPU32[pnum >> 2] = 0;
          return returnCode;
        }
      }
    }
    return Asyncify.handleSleep(function(wakeUp) {
      var retries = 0;
      var interval = 50;
      var timeout = 5e3;
      var maxRetries = timeout / interval;
      function poll() {
        var returnCode2;
        var stream2;
        let num;
        try {
          stream2 = SYSCALLS.getStreamFromFD(fd);
          num = doReadv(stream2, iov, iovcnt);
          returnCode2 = 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) {
            console.error(e);
            throw e;
          }
          returnCode2 = e.errno;
        }
        const success = returnCode2 === 0;
        const failure = ++retries > maxRetries || !(fd in PHPWASM.child_proc_by_fd) || PHPWASM.child_proc_by_fd[fd]?.exited || FS.isClosed(stream2);
        if (success) {
          HEAPU32[pnum >> 2] = num;
          wakeUp(0);
        } else if (failure) {
          HEAPU32[pnum >> 2] = 0;
          wakeUp(returnCode2 === 6 ? 0 : returnCode2);
        } else {
          setTimeout(poll, interval);
        }
      }
      poll();
    });
  }
  function _js_module_onMessage(data, bufPtr) {
    if (typeof Asyncify === "undefined") {
      return;
    }
    if (Module["onMessage"]) {
      const dataStr = UTF8ToString(data);
      return Asyncify.handleSleep((wakeUp) => {
        Module["onMessage"](dataStr).then((response) => {
          const responseBytes = typeof response === "string" ? new TextEncoder().encode(response) : response;
          const responseSize = responseBytes.byteLength;
          const responsePtr = _malloc(responseSize + 1);
          HEAPU8.set(responseBytes, responsePtr);
          HEAPU8[responsePtr + responseSize] = 0;
          HEAPU8[bufPtr] = responsePtr;
          HEAPU8[bufPtr + 1] = responsePtr >> 8;
          HEAPU8[bufPtr + 2] = responsePtr >> 16;
          HEAPU8[bufPtr + 3] = responsePtr >> 24;
          wakeUp(responseSize);
        }).catch((e) => {
          console.error(e);
          wakeUp(-1);
        });
      });
    }
  }
  function _js_open_process(command, argsPtr, argsLength, descriptorsPtr, descriptorsLength, cwdPtr, cwdLength, envPtr, envLength) {
    if (!command) {
      return 1;
    }
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length) {
      return 0;
    }
    let argsArray = [];
    if (argsLength) {
      for (var i = 0; i < argsLength; i++) {
        const charPointer = argsPtr + i * 4;
        argsArray.push(UTF8ToString(HEAPU32[charPointer >> 2]));
      }
    }
    const cwdstr = cwdPtr ? UTF8ToString(cwdPtr) : null;
    let envObject = null;
    if (envLength) {
      envObject = {};
      for (var i = 0; i < envLength; i++) {
        const envPointer = envPtr + i * 4;
        const envEntry = UTF8ToString(HEAPU32[envPointer >> 2]);
        const splitAt = envEntry.indexOf("=");
        if (splitAt === -1) {
          continue;
        }
        const key = envEntry.substring(0, splitAt);
        const value = envEntry.substring(splitAt + 1);
        envObject[key] = value;
      }
    }
    var std = {};
    for (var i = 0; i < descriptorsLength; i++) {
      const descriptorPtr = HEAPU32[descriptorsPtr + i * 4 >> 2];
      std[HEAPU32[descriptorPtr >> 2]] = {
        child: HEAPU32[descriptorPtr + 4 >> 2],
        parent: HEAPU32[descriptorPtr + 8 >> 2]
      };
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        const options = {};
        if (cwdstr !== null) {
          options.cwd = cwdstr;
        }
        if (envObject !== null) {
          options.env = envObject;
        }
        cp = PHPWASM.spawnProcess(cmdstr, argsArray, options);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        if (e.code === "SPAWN_UNSUPPORTED") {
          wakeUp(1);
          return;
        }
        console.error(e);
        wakeUp(1);
        throw e;
      }
      const ProcInfo = {
        pid: cp.pid,
        exited: false,
        stdinFd: std[0]?.child,
        stdinIsDevice: std[0]?.child in PHPWASM.input_devices,
        stdoutChildFd: std[1]?.child,
        stdoutParentFd: std[1]?.parent,
        stderrChildFd: std[2]?.child,
        stderrParentFd: std[2]?.parent,
        stdout: new PHPWASM.EventEmitter(),
        stderr: new PHPWASM.EventEmitter()
      };
      if (ProcInfo.stdoutChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutChildFd] = ProcInfo;
      if (ProcInfo.stderrChildFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrChildFd] = ProcInfo;
      if (ProcInfo.stdoutParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stdoutParentFd] = ProcInfo;
      if (ProcInfo.stderrParentFd)
        PHPWASM.child_proc_by_fd[ProcInfo.stderrParentFd] = ProcInfo;
      PHPWASM.child_proc_by_pid[ProcInfo.pid] = ProcInfo;
      cp.on("exit", function(code) {
        ProcInfo.exitCode = code;
        ProcInfo.exited = true;
        ProcInfo.stdout.emit("data");
        ProcInfo.stderr.emit("data");
      });
      if (ProcInfo.stdoutChildFd) {
        const stdoutStream = SYSCALLS.getStreamFromFD(ProcInfo.stdoutChildFd);
        let stdoutAt = 0;
        cp.stdout.on("data", function(data) {
          ProcInfo.stdout.emit("data", data);
          stdoutStream.stream_ops.write(stdoutStream, data, 0, data.length, stdoutAt);
          stdoutAt += data.length;
        });
      }
      if (ProcInfo.stderrChildFd) {
        const stderrStream = SYSCALLS.getStreamFromFD(ProcInfo.stderrChildFd);
        let stderrAt = 0;
        cp.stderr.on("data", function(data) {
          ProcInfo.stderr.emit("data", data);
          stderrStream.stream_ops.write(stderrStream, data, 0, data.length, stderrAt);
          stderrAt += data.length;
        });
      }
      try {
        await new Promise((resolve, reject) => {
          cp.on("spawn", resolve);
          cp.on("error", reject);
        });
      } catch (e) {
        console.error(e);
        wakeUp(1);
        return;
      }
      if (ProcInfo.stdinIsDevice) {
        PHPWASM.input_devices[ProcInfo.stdinFd].onData(function(data) {
          if (!data)
            return;
          const dataStr = new TextDecoder("utf-8").decode(data);
          cp.stdin.write(dataStr);
        });
        wakeUp(ProcInfo.pid);
        return;
      }
      if (ProcInfo.stdinFd) {
        const stdinStream = SYSCALLS.getStreamFromFD(ProcInfo.stdinFd);
        if (stdinStream.node) {
          const CHUNK_SIZE = 1024;
          const buffer = new Uint8Array(CHUNK_SIZE);
          let offset = 0;
          while (true) {
            const bytesRead = stdinStream.stream_ops.read(stdinStream, buffer, 0, CHUNK_SIZE, offset);
            if (bytesRead === null || bytesRead === 0) {
              break;
            }
            try {
              cp.stdin.write(buffer.subarray(0, bytesRead));
            } catch (e) {
              console.error(e);
              return 1;
            }
            if (bytesRead < CHUNK_SIZE) {
              break;
            }
            offset += bytesRead;
          }
          wakeUp(ProcInfo.pid);
          return;
        }
      }
      wakeUp(ProcInfo.pid);
    });
  }
  function _js_popen_to_file(command, mode, exitCodePtr) {
    if (!command)
      return 1;
    const cmdstr = UTF8ToString(command);
    if (!cmdstr.length)
      return 0;
    const modestr = UTF8ToString(mode);
    if (!modestr.length)
      return 0;
    if (modestr === "w") {
      console.error('popen($cmd, "w") is not implemented yet');
    }
    return Asyncify.handleSleep(async (wakeUp) => {
      let cp;
      try {
        cp = PHPWASM.spawnProcess(cmdstr, []);
        if (cp instanceof Promise) {
          cp = await cp;
        }
      } catch (e) {
        console.error(e);
        if (e.code === "SPAWN_UNSUPPORTED") {
          return 1;
        }
        throw e;
      }
      const outByteArrays = [];
      cp.stdout.on("data", function(data) {
        outByteArrays.push(data);
      });
      const outputPath = "/tmp/popen_output";
      cp.on("exit", function(exitCode) {
        const outBytes = new Uint8Array(outByteArrays.reduce((acc, curr) => acc + curr.length, 0));
        let offset = 0;
        for (const byteArray of outByteArrays) {
          outBytes.set(byteArray, offset);
          offset += byteArray.length;
        }
        FS.writeFile(outputPath, outBytes);
        HEAPU8[exitCodePtr] = exitCode;
        wakeUp(allocateUTF8OnStack(outputPath));
      });
    });
  }
  function _js_process_status(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    if (PHPWASM.child_proc_by_pid[pid].exited) {
      HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
      return 1;
    }
    return 0;
  }
  function _js_waitpid(pid, exitCodePtr) {
    if (!PHPWASM.child_proc_by_pid[pid]) {
      return -1;
    }
    return Asyncify.handleSleep((wakeUp) => {
      const poll = function() {
        if (PHPWASM.child_proc_by_pid[pid]?.exited) {
          HEAPU32[exitCodePtr >> 2] = PHPWASM.child_proc_by_pid[pid].exitCode;
          wakeUp(pid);
        } else {
          setTimeout(poll, 50);
        }
      };
      poll();
    });
  }
  var arraySum = (array, index) => {
    var sum = 0;
    for (var i = 0; i <= index; sum += array[i++]) {
    }
    return sum;
  };
  var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var addDays = (date, days) => {
    var newDate = new Date(date.getTime());
    while (days > 0) {
      var leap = isLeapYear(newDate.getFullYear());
      var currentMonth = newDate.getMonth();
      var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
      if (days > daysInCurrentMonth - newDate.getDate()) {
        days -= daysInCurrentMonth - newDate.getDate() + 1;
        newDate.setDate(1);
        if (currentMonth < 11) {
          newDate.setMonth(currentMonth + 1);
        } else {
          newDate.setMonth(0);
          newDate.setFullYear(newDate.getFullYear() + 1);
        }
      } else {
        newDate.setDate(newDate.getDate() + days);
        return newDate;
      }
    }
    return newDate;
  };
  var writeArrayToMemory = (array, buffer) => {
    HEAP8.set(array, buffer);
  };
  var _strftime = (s, maxsize, format, tm) => {
    var tm_zone = HEAPU32[tm + 40 >> 2];
    var date = {
      tm_sec: HEAP32[tm >> 2],
      tm_min: HEAP32[tm + 4 >> 2],
      tm_hour: HEAP32[tm + 8 >> 2],
      tm_mday: HEAP32[tm + 12 >> 2],
      tm_mon: HEAP32[tm + 16 >> 2],
      tm_year: HEAP32[tm + 20 >> 2],
      tm_wday: HEAP32[tm + 24 >> 2],
      tm_yday: HEAP32[tm + 28 >> 2],
      tm_isdst: HEAP32[tm + 32 >> 2],
      tm_gmtoff: HEAP32[tm + 36 >> 2],
      tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
    };
    var pattern = UTF8ToString(format);
    var EXPANSION_RULES_1 = {
      "%c": "%a %b %d %H:%M:%S %Y",
      "%D": "%m/%d/%y",
      "%F": "%Y-%m-%d",
      "%h": "%b",
      "%r": "%I:%M:%S %p",
      "%R": "%H:%M",
      "%T": "%H:%M:%S",
      "%x": "%m/%d/%y",
      "%X": "%H:%M:%S",
      "%Ec": "%c",
      "%EC": "%C",
      "%Ex": "%m/%d/%y",
      "%EX": "%H:%M:%S",
      "%Ey": "%y",
      "%EY": "%Y",
      "%Od": "%d",
      "%Oe": "%e",
      "%OH": "%H",
      "%OI": "%I",
      "%Om": "%m",
      "%OM": "%M",
      "%OS": "%S",
      "%Ou": "%u",
      "%OU": "%U",
      "%OV": "%V",
      "%Ow": "%w",
      "%OW": "%W",
      "%Oy": "%y"
    };
    for (var rule in EXPANSION_RULES_1) {
      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
    }
    var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function leadingSomething(value, digits, character) {
      var str = typeof value == "number" ? value.toString() : value || "";
      while (str.length < digits) {
        str = character[0] + str;
      }
      return str;
    }
    function leadingNulls(value, digits) {
      return leadingSomething(value, digits, "0");
    }
    function compareByDay(date1, date2) {
      function sgn(value) {
        return value < 0 ? -1 : value > 0 ? 1 : 0;
      }
      var compare;
      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
          compare = sgn(date1.getDate() - date2.getDate());
        }
      }
      return compare;
    }
    function getFirstWeekStartDate(janFourth) {
      switch (janFourth.getDay()) {
        case 0:
          return new Date(janFourth.getFullYear() - 1, 11, 29);
        case 1:
          return janFourth;
        case 2:
          return new Date(janFourth.getFullYear(), 0, 3);
        case 3:
          return new Date(janFourth.getFullYear(), 0, 2);
        case 4:
          return new Date(janFourth.getFullYear(), 0, 1);
        case 5:
          return new Date(janFourth.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(janFourth.getFullYear() - 1, 11, 30);
      }
    }
    function getWeekBasedYear(date2) {
      var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
          return thisDate.getFullYear() + 1;
        }
        return thisDate.getFullYear();
      }
      return thisDate.getFullYear() - 1;
    }
    var EXPANSION_RULES_2 = {
      "%a": (date2) => WEEKDAYS[date2.tm_wday].substring(0, 3),
      "%A": (date2) => WEEKDAYS[date2.tm_wday],
      "%b": (date2) => MONTHS[date2.tm_mon].substring(0, 3),
      "%B": (date2) => MONTHS[date2.tm_mon],
      "%C": (date2) => {
        var year = date2.tm_year + 1900;
        return leadingNulls(year / 100 | 0, 2);
      },
      "%d": (date2) => leadingNulls(date2.tm_mday, 2),
      "%e": (date2) => leadingSomething(date2.tm_mday, 2, " "),
      "%g": (date2) => getWeekBasedYear(date2).toString().substring(2),
      "%G": getWeekBasedYear,
      "%H": (date2) => leadingNulls(date2.tm_hour, 2),
      "%I": (date2) => {
        var twelveHour = date2.tm_hour;
        if (twelveHour == 0)
          twelveHour = 12;
        else if (twelveHour > 12)
          twelveHour -= 12;
        return leadingNulls(twelveHour, 2);
      },
      "%j": (date2) => leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3),
      "%m": (date2) => leadingNulls(date2.tm_mon + 1, 2),
      "%M": (date2) => leadingNulls(date2.tm_min, 2),
      "%n": () => "\n",
      "%p": (date2) => {
        if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
          return "AM";
        }
        return "PM";
      },
      "%S": (date2) => leadingNulls(date2.tm_sec, 2),
      "%t": () => "	",
      "%u": (date2) => date2.tm_wday || 7,
      "%U": (date2) => {
        var days = date2.tm_yday + 7 - date2.tm_wday;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%V": (date2) => {
        var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
        if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
          val++;
        }
        if (!val) {
          val = 52;
          var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
          if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
            val++;
          }
        } else if (val == 53) {
          var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
          if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
            val = 1;
        }
        return leadingNulls(val, 2);
      },
      "%w": (date2) => date2.tm_wday,
      "%W": (date2) => {
        var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
        return leadingNulls(Math.floor(days / 7), 2);
      },
      "%y": (date2) => (date2.tm_year + 1900).toString().substring(2),
      "%Y": (date2) => date2.tm_year + 1900,
      "%z": (date2) => {
        var off = date2.tm_gmtoff;
        var ahead = off >= 0;
        off = Math.abs(off) / 60;
        off = off / 60 * 100 + off % 60;
        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
      },
      "%Z": (date2) => date2.tm_zone,
      "%%": () => "%"
    };
    pattern = pattern.replace(/%%/g, "\0\0");
    for (var rule in EXPANSION_RULES_2) {
      if (pattern.includes(rule)) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
      }
    }
    pattern = pattern.replace(/\0\0/g, "%");
    var bytes = intArrayFromString(pattern, false);
    if (bytes.length > maxsize) {
      return 0;
    }
    writeArrayToMemory(bytes, s);
    return bytes.length - 1;
  };
  var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);
  var _strptime = (buf, format, tm) => {
    var pattern = UTF8ToString(format);
    var SPECIAL_CHARS = "\\!@#$^&*()+=-[]/{}|:<>?,.";
    for (var i = 0, ii = SPECIAL_CHARS.length; i < ii; ++i) {
      pattern = pattern.replace(new RegExp("\\" + SPECIAL_CHARS[i], "g"), "\\" + SPECIAL_CHARS[i]);
    }
    var EQUIVALENT_MATCHERS = {
      "A": "%a",
      "B": "%b",
      "c": "%a %b %d %H:%M:%S %Y",
      "D": "%m\\/%d\\/%y",
      "e": "%d",
      "F": "%Y-%m-%d",
      "h": "%b",
      "R": "%H\\:%M",
      "r": "%I\\:%M\\:%S\\s%p",
      "T": "%H\\:%M\\:%S",
      "x": "%m\\/%d\\/(?:%y|%Y)",
      "X": "%H\\:%M\\:%S"
    };
    var DATE_PATTERNS = {
      /* weekday name */
      "a": "(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",
      /* month name */
      "b": "(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",
      /* century */
      "C": "\\d\\d",
      /* day of month */
      "d": "0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",
      /* hour (24hr) */
      "H": "\\d(?!\\d)|[0,1]\\d|20|21|22|23",
      /* hour (12hr) */
      "I": "\\d(?!\\d)|0\\d|10|11|12",
      /* day of year */
      "j": "00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",
      /* month */
      "m": "0[1-9]|[1-9](?!\\d)|10|11|12",
      /* minutes */
      "M": "0\\d|\\d(?!\\d)|[1-5]\\d",
      /* whitespace */
      "n": " ",
      /* AM/PM */
      "p": "AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",
      /* seconds */
      "S": "0\\d|\\d(?!\\d)|[1-5]\\d|60",
      /* week number */
      "U": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* week number */
      "W": "0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",
      /* weekday number */
      "w": "[0-6]",
      /* 2-digit year */
      "y": "\\d\\d",
      /* 4-digit year */
      "Y": "\\d\\d\\d\\d",
      /* whitespace */
      "t": " ",
      /* time zone */
      "z": "Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"
    };
    var MONTH_NUMBERS = {
      JAN: 0,
      FEB: 1,
      MAR: 2,
      APR: 3,
      MAY: 4,
      JUN: 5,
      JUL: 6,
      AUG: 7,
      SEP: 8,
      OCT: 9,
      NOV: 10,
      DEC: 11
    };
    var DAY_NUMBERS_SUN_FIRST = {
      SUN: 0,
      MON: 1,
      TUE: 2,
      WED: 3,
      THU: 4,
      FRI: 5,
      SAT: 6
    };
    var DAY_NUMBERS_MON_FIRST = {
      MON: 0,
      TUE: 1,
      WED: 2,
      THU: 3,
      FRI: 4,
      SAT: 5,
      SUN: 6
    };
    var capture = [];
    var pattern_out = pattern.replace(/%(.)/g, (m, c) => EQUIVALENT_MATCHERS[c] || m).replace(/%(.)/g, (_, c) => {
      let pat = DATE_PATTERNS[c];
      if (pat) {
        capture.push(c);
        return `(${pat})`;
      } else {
        return c;
      }
    }).replace(/\s+/g, "\\s*");
    var matches = new RegExp("^" + pattern_out, "i").exec(UTF8ToString(buf));
    function initDate() {
      function fixup(value2, min, max) {
        return typeof value2 != "number" || isNaN(value2) ? min : value2 >= min ? value2 <= max ? value2 : max : min;
      }
      return {
        year: fixup(HEAP32[tm + 20 >> 2] + 1900, 1970, 9999),
        month: fixup(HEAP32[tm + 16 >> 2], 0, 11),
        day: fixup(HEAP32[tm + 12 >> 2], 1, 31),
        hour: fixup(HEAP32[tm + 8 >> 2], 0, 23),
        min: fixup(HEAP32[tm + 4 >> 2], 0, 59),
        sec: fixup(HEAP32[tm >> 2], 0, 59),
        gmtoff: 0
      };
    }
    if (matches) {
      var date = initDate();
      var value;
      var getMatch = (symbol) => {
        var pos = capture.indexOf(symbol);
        if (pos >= 0) {
          return matches[pos + 1];
        }
        return;
      };
      if (value = getMatch("S")) {
        date.sec = jstoi_q(value);
      }
      if (value = getMatch("M")) {
        date.min = jstoi_q(value);
      }
      if (value = getMatch("H")) {
        date.hour = jstoi_q(value);
      } else if (value = getMatch("I")) {
        var hour = jstoi_q(value);
        if (value = getMatch("p")) {
          hour += value.toUpperCase()[0] === "P" ? 12 : 0;
        }
        date.hour = hour;
      }
      if (value = getMatch("Y")) {
        date.year = jstoi_q(value);
      } else if (value = getMatch("y")) {
        var year = jstoi_q(value);
        if (value = getMatch("C")) {
          year += jstoi_q(value) * 100;
        } else {
          year += year < 69 ? 2e3 : 1900;
        }
        date.year = year;
      }
      if (value = getMatch("m")) {
        date.month = jstoi_q(value) - 1;
      } else if (value = getMatch("b")) {
        date.month = MONTH_NUMBERS[value.substring(0, 3).toUpperCase()] || 0;
      }
      if (value = getMatch("d")) {
        date.day = jstoi_q(value);
      } else if (value = getMatch("j")) {
        var day = jstoi_q(value);
        var leapYear = isLeapYear(date.year);
        for (var month = 0; month < 12; ++month) {
          var daysUntilMonth = arraySum(leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, month - 1);
          if (day <= daysUntilMonth + (leapYear ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[month]) {
            date.day = day - daysUntilMonth;
          }
        }
      } else if (value = getMatch("a")) {
        var weekDay = value.substring(0, 3).toUpperCase();
        if (value = getMatch("U")) {
          var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 0) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        } else if (value = getMatch("W")) {
          var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
          var weekNumber = jstoi_q(value);
          var janFirst = new Date(date.year, 0, 1);
          var endDate;
          if (janFirst.getDay() === 1) {
            endDate = addDays(janFirst, weekDayNumber + 7 * (weekNumber - 1));
          } else {
            endDate = addDays(janFirst, 7 - janFirst.getDay() + 1 + weekDayNumber + 7 * (weekNumber - 1));
          }
          date.day = endDate.getDate();
          date.month = endDate.getMonth();
        }
      }
      if (value = getMatch("z")) {
        if (value.toLowerCase() === "z") {
          date.gmtoff = 0;
        } else {
          var match = value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);
          date.gmtoff = match[1] * 3600;
          if (match[2]) {
            date.gmtoff += date.gmtoff > 0 ? match[2] * 60 : -match[2] * 60;
          }
        }
      }
      var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
      HEAP32[tm >> 2] = fullDate.getSeconds();
      HEAP32[tm + 4 >> 2] = fullDate.getMinutes();
      HEAP32[tm + 8 >> 2] = fullDate.getHours();
      HEAP32[tm + 12 >> 2] = fullDate.getDate();
      HEAP32[tm + 16 >> 2] = fullDate.getMonth();
      HEAP32[tm + 20 >> 2] = fullDate.getFullYear() - 1900;
      HEAP32[tm + 24 >> 2] = fullDate.getDay();
      HEAP32[tm + 28 >> 2] = arraySum(isLeapYear(fullDate.getFullYear()) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, fullDate.getMonth() - 1) + fullDate.getDate() - 1;
      HEAP32[tm + 32 >> 2] = 0;
      HEAP32[tm + 36 >> 2] = date.gmtoff;
      return buf + intArrayFromString(matches[0]).length - 1;
    }
    return 0;
  };
  function _wasm_close(socketd) {
    return PHPWASM.shutdownSocket(socketd, 2);
  }
  function _wasm_poll_socket(socketd, events, timeout) {
    if (typeof Asyncify === "undefined") {
      return 0;
    }
    const POLLIN = 1;
    const POLLPRI = 2;
    const POLLOUT = 4;
    const POLLERR = 8;
    const POLLHUP = 16;
    const POLLNVAL = 32;
    return Asyncify.handleSleep((wakeUp) => {
      const polls = [];
      if (socketd in PHPWASM.child_proc_by_fd) {
        const procInfo = PHPWASM.child_proc_by_fd[socketd];
        if (procInfo.exited) {
          wakeUp(0);
          return;
        }
        polls.push(PHPWASM.awaitEvent(procInfo.stdout, "data"));
      } else if (FS.isSocket(FS.getStream(socketd).node.mode)) {
        const sock = getSocketFromFD(socketd);
        if (!sock) {
          wakeUp(0);
          return;
        }
        const lookingFor = /* @__PURE__ */ new Set();
        if (events & POLLIN || events & POLLPRI) {
          if (sock.server) {
            for (const client of sock.pending) {
              if ((client.recv_queue || []).length > 0) {
                wakeUp(1);
                return;
              }
            }
          } else if ((sock.recv_queue || []).length > 0) {
            wakeUp(1);
            return;
          }
        }
        const webSockets = PHPWASM.getAllWebSockets(sock);
        if (!webSockets.length) {
          wakeUp(0);
          return;
        }
        for (const ws of webSockets) {
          if (events & POLLIN || events & POLLPRI) {
            polls.push(PHPWASM.awaitData(ws));
            lookingFor.add("POLLIN");
          }
          if (events & POLLOUT) {
            polls.push(PHPWASM.awaitConnection(ws));
            lookingFor.add("POLLOUT");
          }
          if (events & POLLHUP) {
            polls.push(PHPWASM.awaitClose(ws));
            lookingFor.add("POLLHUP");
          }
          if (events & POLLERR || events & POLLNVAL) {
            polls.push(PHPWASM.awaitError(ws));
            lookingFor.add("POLLERR");
          }
        }
      } else {
        setTimeout(function() {
          wakeUp(1);
        }, timeout);
        return;
      }
      if (polls.length === 0) {
        console.warn("Unsupported poll event " + events + ", defaulting to setTimeout().");
        setTimeout(function() {
          wakeUp(0);
        }, timeout);
        return;
      }
      const promises = polls.map(([promise]) => promise);
      const clearPolling = () => polls.forEach(([, clear]) => clear());
      let awaken = false;
      let timeoutId;
      Promise.race(promises).then(function(results) {
        if (!awaken) {
          awaken = true;
          wakeUp(1);
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          clearPolling();
        }
      });
      if (timeout !== -1) {
        timeoutId = setTimeout(function() {
          if (!awaken) {
            awaken = true;
            wakeUp(0);
            clearPolling();
          }
        }, timeout);
      }
    });
  }
  function _wasm_setsockopt(socketd, level, optionName, optionValuePtr, optionLen) {
    const optionValue = HEAPU8[optionValuePtr];
    const SOL_SOCKET = 1;
    const SO_KEEPALIVE = 9;
    const IPPROTO_TCP = 6;
    const TCP_NODELAY = 1;
    const isSupported = level === SOL_SOCKET && optionName === SO_KEEPALIVE || level === IPPROTO_TCP && optionName === TCP_NODELAY;
    if (!isSupported) {
      console.warn(`Unsupported socket option: ${level}, ${optionName}, ${optionValue}`);
      return -1;
    }
    const ws = PHPWASM.getAllWebSockets(socketd)[0];
    if (!ws) {
      return -1;
    }
    ws.setSocketOpt(level, optionName, optionValuePtr);
    return 0;
  }
  var wasmTable;
  var runAndAbortIfError = (func) => {
    try {
      return func();
    } catch (e) {
      abort(e);
    }
  };
  var Asyncify = {
    instrumentWasmImports(imports) {
      var importPattern = /^(_dlopen_js|invoke_i|invoke_ii|invoke_iii|invoke_iiii|invoke_iiiii|invoke_iiiiii|invoke_iiiiiii|invoke_iiiiiiii|invoke_iiiiiiiiii|invoke_v|invoke_vi|invoke_vii|invoke_viidii|invoke_viii|invoke_viiii|invoke_viiiii|invoke_viiiiii|invoke_viiiiiii|invoke_viiiiiiiii|js_open_process|js_popen_to_file|js_fd_read|js_module_onMessage|js_waitpid|wasm_poll_socket|wasm_shutdown|__asyncjs__.*)$/;
      for (let [x, original] of Object.entries(imports)) {
        if (typeof original == "function") {
          let isAsyncifyImport = original.isAsync || importPattern.test(x);
        }
      }
    },
    instrumentWasmExports(exports) {
      var ret = {};
      for (let [x, original] of Object.entries(exports)) {
        if (typeof original == "function") {
          ret[x] = (...args) => {
            Asyncify.exportCallStack.push(x);
            try {
              return original(...args);
            } finally {
              if (!ABORT) {
                var y = Asyncify.exportCallStack.pop();
                Asyncify.maybeStopUnwind();
              }
            }
          };
        } else {
          ret[x] = original;
        }
      }
      return ret;
    },
    State: {
      Normal: 0,
      Unwinding: 1,
      Rewinding: 2,
      Disabled: 3
    },
    state: 0,
    StackSize: 4096,
    currData: null,
    handleSleepReturnValue: 0,
    exportCallStack: [],
    callStackNameToId: {},
    callStackIdToName: {},
    callStackId: 0,
    asyncPromiseHandlers: null,
    sleepCallbacks: [],
    getCallStackId(funcName) {
      var id = Asyncify.callStackNameToId[funcName];
      if (id === void 0) {
        id = Asyncify.callStackId++;
        Asyncify.callStackNameToId[funcName] = id;
        Asyncify.callStackIdToName[id] = funcName;
      }
      return id;
    },
    maybeStopUnwind() {
      if (Asyncify.currData && Asyncify.state === Asyncify.State.Unwinding && Asyncify.exportCallStack.length === 0) {
        Asyncify.state = Asyncify.State.Normal;
        runtimeKeepalivePush();
        runAndAbortIfError(_asyncify_stop_unwind);
        if (typeof Fibers != "undefined") {
          Fibers.trampoline();
        }
      }
    },
    whenDone() {
      return new Promise((resolve, reject) => {
        Asyncify.asyncPromiseHandlers = {
          resolve,
          reject
        };
      });
    },
    allocateData() {
      var ptr = _malloc(12 + Asyncify.StackSize);
      Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
      Asyncify.setDataRewindFunc(ptr);
      return ptr;
    },
    setDataHeader(ptr, stack, stackSize) {
      HEAPU32[ptr >> 2] = stack;
      HEAPU32[ptr + 4 >> 2] = stack + stackSize;
    },
    setDataRewindFunc(ptr) {
      var bottomOfCallStack = Asyncify.exportCallStack[0];
      var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
      HEAP32[ptr + 8 >> 2] = rewindId;
    },
    getDataRewindFuncName(ptr) {
      var id = HEAP32[ptr + 8 >> 2];
      var name = Asyncify.callStackIdToName[id];
      return name;
    },
    getDataRewindFunc(name) {
      var func = wasmExports[name];
      return func;
    },
    doRewind(ptr) {
      var name = Asyncify.getDataRewindFuncName(ptr);
      var func = Asyncify.getDataRewindFunc(name);
      runtimeKeepalivePop();
      return func();
    },
    handleSleep(startAsync) {
      if (ABORT)
        return;
      if (Asyncify.state === Asyncify.State.Normal) {
        var reachedCallback = false;
        var reachedAfterCallback = false;
        startAsync((handleSleepReturnValue = 0) => {
          if (ABORT)
            return;
          Asyncify.handleSleepReturnValue = handleSleepReturnValue;
          reachedCallback = true;
          if (!reachedAfterCallback) {
            return;
          }
          Asyncify.state = Asyncify.State.Rewinding;
          runAndAbortIfError(() => _asyncify_start_rewind(Asyncify.currData));
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.resume();
          }
          var asyncWasmReturnValue, isError = false;
          try {
            asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
          } catch (err2) {
            asyncWasmReturnValue = err2;
            isError = true;
          }
          var handled = false;
          if (!Asyncify.currData) {
            var asyncPromiseHandlers = Asyncify.asyncPromiseHandlers;
            if (asyncPromiseHandlers) {
              Asyncify.asyncPromiseHandlers = null;
              (isError ? asyncPromiseHandlers.reject : asyncPromiseHandlers.resolve)(asyncWasmReturnValue);
              handled = true;
            }
          }
          if (isError && !handled) {
            throw asyncWasmReturnValue;
          }
        });
        reachedAfterCallback = true;
        if (!reachedCallback) {
          Asyncify.state = Asyncify.State.Unwinding;
          Asyncify.currData = Asyncify.allocateData();
          if (typeof Browser != "undefined" && Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          runAndAbortIfError(() => _asyncify_start_unwind(Asyncify.currData));
        }
      } else if (Asyncify.state === Asyncify.State.Rewinding) {
        Asyncify.state = Asyncify.State.Normal;
        runAndAbortIfError(_asyncify_stop_rewind);
        _free(Asyncify.currData);
        Asyncify.currData = null;
        Asyncify.sleepCallbacks.forEach(callUserCallback);
      } else {
        abort(`invalid state: ${Asyncify.state}`);
      }
      return Asyncify.handleSleepReturnValue;
    },
    handleAsync(startAsync) {
      return Asyncify.handleSleep((wakeUp) => {
        startAsync().then(wakeUp);
      });
    }
  };
  var getCFunc = (ident) => {
    var func = Module["_" + ident];
    return func;
  };
  var ccall = (ident, returnType, argTypes, args, opts) => {
    var toC = {
      "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      },
      "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean")
        return Boolean(ret2);
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0)
            stack = stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var previousAsync = Asyncify.currData;
    var ret = func(...cArgs);
    function onDone(ret2) {
      runtimeKeepalivePop();
      if (stack !== 0)
        stackRestore(stack);
      return convertReturnValue(ret2);
    }
    var asyncMode = opts?.async;
    runtimeKeepalivePush();
    if (Asyncify.currData != previousAsync) {
      return Asyncify.whenDone().then(onDone);
    }
    ret = onDone(ret);
    if (asyncMode)
      return Promise.resolve(ret);
    return ret;
  };
  var FS_createPath = FS.createPath;
  var FS_unlink = (path) => FS.unlink(path);
  var FS_createLazyFile = FS.createLazyFile;
  var FS_createDevice = FS.createDevice;
  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  if (ENVIRONMENT_IS_NODE) {
    NODEFS.staticInit();
  }
  PHPWASM.init();
  var wasmImports = {
    /** @export */
    k: ___assert_fail,
    /** @export */
    Xa: ___call_sighandler,
    /** @export */
    Wa: ___syscall_accept4,
    /** @export */
    Va: ___syscall_bind,
    /** @export */
    Ua: ___syscall_chdir,
    /** @export */
    O: ___syscall_chmod,
    /** @export */
    Ta: ___syscall_connect,
    /** @export */
    Sa: ___syscall_dup,
    /** @export */
    Ra: ___syscall_dup3,
    /** @export */
    Qa: ___syscall_faccessat,
    /** @export */
    Pa: ___syscall_fchmod,
    /** @export */
    Oa: ___syscall_fchown32,
    /** @export */
    N: ___syscall_fchownat,
    /** @export */
    l: ___syscall_fcntl64,
    /** @export */
    Na: ___syscall_fstat64,
    /** @export */
    ba: ___syscall_ftruncate64,
    /** @export */
    Ma: ___syscall_getcwd,
    /** @export */
    La: ___syscall_getdents64,
    /** @export */
    Ka: ___syscall_getpeername,
    /** @export */
    Ja: ___syscall_getsockname,
    /** @export */
    Ia: ___syscall_getsockopt,
    /** @export */
    C: ___syscall_ioctl,
    /** @export */
    Ha: ___syscall_listen,
    /** @export */
    Ga: ___syscall_lstat64,
    /** @export */
    Fa: ___syscall_mkdirat,
    /** @export */
    Ea: ___syscall_newfstatat,
    /** @export */
    B: ___syscall_openat,
    /** @export */
    Da: ___syscall_pipe,
    /** @export */
    Ca: ___syscall_poll,
    /** @export */
    Ba: ___syscall_readlinkat,
    /** @export */
    Aa: ___syscall_recvfrom,
    /** @export */
    za: ___syscall_renameat,
    /** @export */
    M: ___syscall_rmdir,
    /** @export */
    ya: ___syscall_sendto,
    /** @export */
    L: ___syscall_socket,
    /** @export */
    xa: ___syscall_stat64,
    /** @export */
    wa: ___syscall_statfs64,
    /** @export */
    va: ___syscall_symlink,
    /** @export */
    K: ___syscall_unlinkat,
    /** @export */
    ua: ___syscall_utimensat,
    /** @export */
    pa: __abort_js,
    /** @export */
    oa: __emscripten_get_now_is_monotonic,
    /** @export */
    na: __emscripten_lookup_name,
    /** @export */
    ma: __emscripten_memcpy_js,
    /** @export */
    la: __emscripten_runtime_keepalive_clear,
    /** @export */
    ka: __emscripten_throw_longjmp,
    /** @export */
    fa: __gmtime_js,
    /** @export */
    ga: __localtime_js,
    /** @export */
    $: __mktime_js,
    /** @export */
    da: __mmap_js,
    /** @export */
    ea: __munmap_js,
    /** @export */
    H: __setitimer_js,
    /** @export */
    ja: __tzset_js,
    /** @export */
    z: _emscripten_date_now,
    /** @export */
    ia: _emscripten_get_heap_max,
    /** @export */
    u: _emscripten_get_now,
    /** @export */
    ha: _emscripten_resize_heap,
    /** @export */
    G: _emscripten_sleep,
    /** @export */
    ta: _environ_get,
    /** @export */
    sa: _environ_sizes_get,
    /** @export */
    m: _exit,
    /** @export */
    s: _fd_close,
    /** @export */
    J: _fd_fdstat_get,
    /** @export */
    I: _fd_read,
    /** @export */
    aa: _fd_seek,
    /** @export */
    ra: _fd_sync,
    /** @export */
    A: _fd_write,
    /** @export */
    _: _getaddrinfo,
    /** @export */
    F: _getnameinfo,
    /** @export */
    Z: _getprotobyname,
    /** @export */
    Y: _getprotobynumber,
    /** @export */
    i: invoke_i,
    /** @export */
    c: invoke_ii,
    /** @export */
    b: invoke_iii,
    /** @export */
    e: invoke_iiii,
    /** @export */
    g: invoke_iiiii,
    /** @export */
    r: invoke_iiiiii,
    /** @export */
    w: invoke_iiiiiii,
    /** @export */
    v: invoke_iiiiiiii,
    /** @export */
    X: invoke_iiiiiiiii,
    /** @export */
    y: invoke_iiiiiiiiii,
    /** @export */
    ca: invoke_jii,
    /** @export */
    f: invoke_v,
    /** @export */
    a: invoke_vi,
    /** @export */
    d: invoke_vii,
    /** @export */
    h: invoke_viii,
    /** @export */
    o: invoke_viiii,
    /** @export */
    n: invoke_viiiii,
    /** @export */
    j: invoke_viiiiii,
    /** @export */
    x: invoke_viiiiiiiii,
    /** @export */
    E: _js_create_input_device,
    /** @export */
    W: _js_fd_read,
    /** @export */
    V: _js_module_onMessage,
    /** @export */
    D: _js_open_process,
    /** @export */
    U: _js_popen_to_file,
    /** @export */
    T: _js_process_status,
    /** @export */
    S: _js_waitpid,
    /** @export */
    qa: _proc_exit,
    /** @export */
    R: _strftime,
    /** @export */
    Q: _strftime_l,
    /** @export */
    P: _strptime,
    /** @export */
    p: _wasm_close,
    /** @export */
    t: _wasm_poll_socket,
    /** @export */
    q: _wasm_setsockopt
  };
  var wasmExports = createWasm();
  var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["Za"])();
  var _malloc = (a0) => (_malloc = wasmExports["_a"])(a0);
  var _free = (a0) => (_free = wasmExports["$a"])(a0);
  var _wasm_sleep = Module["_wasm_sleep"] = (a0) => (_wasm_sleep = Module["_wasm_sleep"] = wasmExports["bb"])(a0);
  var _ntohs = (a0) => (_ntohs = wasmExports["cb"])(a0);
  var _htons = (a0) => (_htons = wasmExports["db"])(a0);
  var _htonl = (a0) => (_htonl = wasmExports["eb"])(a0);
  var _wasm_read = Module["_wasm_read"] = (a0, a1, a2) => (_wasm_read = Module["_wasm_read"] = wasmExports["fb"])(a0, a1, a2);
  var _fflush = (a0) => (_fflush = wasmExports["gb"])(a0);
  var _wasm_popen = Module["_wasm_popen"] = (a0, a1) => (_wasm_popen = Module["_wasm_popen"] = wasmExports["hb"])(a0, a1);
  var _wasm_php_exec = Module["_wasm_php_exec"] = (a0, a1, a2, a3) => (_wasm_php_exec = Module["_wasm_php_exec"] = wasmExports["ib"])(a0, a1, a2, a3);
  var _php_pollfd_for = Module["_php_pollfd_for"] = (a0, a1, a2) => (_php_pollfd_for = Module["_php_pollfd_for"] = wasmExports["jb"])(a0, a1, a2);
  var ___wrap_select = Module["___wrap_select"] = (a0, a1, a2, a3, a4) => (___wrap_select = Module["___wrap_select"] = wasmExports["kb"])(a0, a1, a2, a3, a4);
  var _wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = (a0) => (_wasm_add_cli_arg = Module["_wasm_add_cli_arg"] = wasmExports["lb"])(a0);
  var _run_cli = Module["_run_cli"] = () => (_run_cli = Module["_run_cli"] = wasmExports["mb"])();
  var _wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = (a0) => (_wasm_set_sapi_name = Module["_wasm_set_sapi_name"] = wasmExports["nb"])(a0);
  var _wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = (a0) => (_wasm_set_phpini_path = Module["_wasm_set_phpini_path"] = wasmExports["ob"])(a0);
  var _wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = (a0, a1) => (_wasm_add_SERVER_entry = Module["_wasm_add_SERVER_entry"] = wasmExports["pb"])(a0, a1);
  var _wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = (a0, a1) => (_wasm_add_ENV_entry = Module["_wasm_add_ENV_entry"] = wasmExports["qb"])(a0, a1);
  var _wasm_set_query_string = Module["_wasm_set_query_string"] = (a0) => (_wasm_set_query_string = Module["_wasm_set_query_string"] = wasmExports["rb"])(a0);
  var _wasm_set_path_translated = Module["_wasm_set_path_translated"] = (a0) => (_wasm_set_path_translated = Module["_wasm_set_path_translated"] = wasmExports["sb"])(a0);
  var _wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = (a0) => (_wasm_set_skip_shebang = Module["_wasm_set_skip_shebang"] = wasmExports["tb"])(a0);
  var _wasm_set_request_uri = Module["_wasm_set_request_uri"] = (a0) => (_wasm_set_request_uri = Module["_wasm_set_request_uri"] = wasmExports["ub"])(a0);
  var _wasm_set_request_method = Module["_wasm_set_request_method"] = (a0) => (_wasm_set_request_method = Module["_wasm_set_request_method"] = wasmExports["vb"])(a0);
  var _wasm_set_request_host = Module["_wasm_set_request_host"] = (a0) => (_wasm_set_request_host = Module["_wasm_set_request_host"] = wasmExports["wb"])(a0);
  var _wasm_set_content_type = Module["_wasm_set_content_type"] = (a0) => (_wasm_set_content_type = Module["_wasm_set_content_type"] = wasmExports["xb"])(a0);
  var _wasm_set_request_body = Module["_wasm_set_request_body"] = (a0) => (_wasm_set_request_body = Module["_wasm_set_request_body"] = wasmExports["yb"])(a0);
  var _wasm_set_content_length = Module["_wasm_set_content_length"] = (a0) => (_wasm_set_content_length = Module["_wasm_set_content_length"] = wasmExports["zb"])(a0);
  var _wasm_set_cookies = Module["_wasm_set_cookies"] = (a0) => (_wasm_set_cookies = Module["_wasm_set_cookies"] = wasmExports["Ab"])(a0);
  var _wasm_set_request_port = Module["_wasm_set_request_port"] = (a0) => (_wasm_set_request_port = Module["_wasm_set_request_port"] = wasmExports["Bb"])(a0);
  var _wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = () => (_wasm_sapi_request_shutdown = Module["_wasm_sapi_request_shutdown"] = wasmExports["Cb"])();
  var _wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = () => (_wasm_sapi_handle_request = Module["_wasm_sapi_handle_request"] = wasmExports["Db"])();
  var _php_wasm_init = Module["_php_wasm_init"] = () => (_php_wasm_init = Module["_php_wasm_init"] = wasmExports["Eb"])();
  var ___funcs_on_exit = () => (___funcs_on_exit = wasmExports["Fb"])();
  var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["Gb"])(a0, a1);
  var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports["Hb"])(a0, a1);
  var _setThrew = (a0, a1) => (_setThrew = wasmExports["Ib"])(a0, a1);
  var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports["Jb"])(a0);
  var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["Kb"])(a0);
  var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["Lb"])(a0);
  var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["Mb"])();
  var dynCall_viii = Module["dynCall_viii"] = (a0, a1, a2, a3) => (dynCall_viii = Module["dynCall_viii"] = wasmExports["Nb"])(a0, a1, a2, a3);
  var dynCall_vii = Module["dynCall_vii"] = (a0, a1, a2) => (dynCall_vii = Module["dynCall_vii"] = wasmExports["Ob"])(a0, a1, a2);
  var dynCall_vi = Module["dynCall_vi"] = (a0, a1) => (dynCall_vi = Module["dynCall_vi"] = wasmExports["Pb"])(a0, a1);
  var dynCall_iii = Module["dynCall_iii"] = (a0, a1, a2) => (dynCall_iii = Module["dynCall_iii"] = wasmExports["Qb"])(a0, a1, a2);
  var dynCall_ii = Module["dynCall_ii"] = (a0, a1) => (dynCall_ii = Module["dynCall_ii"] = wasmExports["Rb"])(a0, a1);
  var dynCall_v = Module["dynCall_v"] = (a0) => (dynCall_v = Module["dynCall_v"] = wasmExports["Sb"])(a0);
  var dynCall_iiii = Module["dynCall_iiii"] = (a0, a1, a2, a3) => (dynCall_iiii = Module["dynCall_iiii"] = wasmExports["Tb"])(a0, a1, a2, a3);
  var dynCall_viiiii = Module["dynCall_viiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_viiiii = Module["dynCall_viiiii"] = wasmExports["Ub"])(a0, a1, a2, a3, a4, a5);
  var dynCall_iiiii = Module["dynCall_iiiii"] = (a0, a1, a2, a3, a4) => (dynCall_iiiii = Module["dynCall_iiiii"] = wasmExports["Vb"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = wasmExports["Wb"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = (a0, a1, a2, a3, a4, a5) => (dynCall_iiiiii = Module["dynCall_iiiiii"] = wasmExports["Xb"])(a0, a1, a2, a3, a4, a5);
  var dynCall_i = Module["dynCall_i"] = (a0) => (dynCall_i = Module["dynCall_i"] = wasmExports["Yb"])(a0);
  var dynCall_viiii = Module["dynCall_viiii"] = (a0, a1, a2, a3, a4) => (dynCall_viiii = Module["dynCall_viiii"] = wasmExports["Zb"])(a0, a1, a2, a3, a4);
  var dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = wasmExports["_b"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
  var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = wasmExports["$b"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viiiiii = Module["dynCall_viiiiii"] = wasmExports["ac"])(a0, a1, a2, a3, a4, a5, a6);
  var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = wasmExports["bc"])(a0, a1, a2, a3, a4, a5, a6, a7);
  var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = wasmExports["cc"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  var dynCall_jii = Module["dynCall_jii"] = (a0, a1, a2) => (dynCall_jii = Module["dynCall_jii"] = wasmExports["dc"])(a0, a1, a2);
  var _asyncify_start_unwind = (a0) => (_asyncify_start_unwind = wasmExports["ec"])(a0);
  var _asyncify_stop_unwind = () => (_asyncify_stop_unwind = wasmExports["fc"])();
  var _asyncify_start_rewind = (a0) => (_asyncify_start_rewind = wasmExports["gc"])(a0);
  var _asyncify_stop_rewind = () => (_asyncify_stop_rewind = wasmExports["hc"])();
  function invoke_viii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      dynCall_viii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    var sp = stackSave();
    try {
      dynCall_vii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_vi(index, a1) {
    var sp = stackSave();
    try {
      dynCall_vi(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_iii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_v(index) {
    var sp = stackSave();
    try {
      dynCall_v(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_ii(index, a1) {
    var sp = stackSave();
    try {
      return dynCall_ii(index, a1);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_i(index) {
    var sp = stackSave();
    try {
      return dynCall_i(index);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      dynCall_viiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiii(index, a1, a2, a3, a4) {
    var sp = stackSave();
    try {
      return dynCall_iiiii(index, a1, a2, a3, a4);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiii(index, a1, a2, a3) {
    var sp = stackSave();
    try {
      return dynCall_iiii(index, a1, a2, a3);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
    var sp = stackSave();
    try {
      dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      dynCall_viiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
    var sp = stackSave();
    try {
      return dynCall_iiiiii(index, a1, a2, a3, a4, a5);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
    var sp = stackSave();
    try {
      dynCall_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
    var sp = stackSave();
    try {
      return dynCall_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  function invoke_jii(index, a1, a2) {
    var sp = stackSave();
    try {
      return dynCall_jii(index, a1, a2);
    } catch (e) {
      stackRestore(sp);
      if (e !== e + 0)
        throw e;
      _setThrew(1, 0);
    }
  }
  Module["addRunDependency"] = addRunDependency;
  Module["removeRunDependency"] = removeRunDependency;
  Module["wasmExports"] = wasmExports;
  Module["ccall"] = ccall;
  Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
  Module["FS_unlink"] = FS_unlink;
  Module["FS_createPath"] = FS_createPath;
  Module["FS_createDevice"] = FS_createDevice;
  Module["FS_createDataFile"] = FS_createDataFile;
  Module["FS_createLazyFile"] = FS_createLazyFile;
  Module["PROXYFS"] = PROXYFS;
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun)
      run();
    if (!calledRun)
      dependenciesFulfilled = runCaller;
  };
  function run() {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun)
        return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      initRuntime();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  DNS.address_map.addrs.localhost = "127.0.0.1";
  PHPLoader.debug = "debug" in PHPLoader ? PHPLoader.debug : true;
  if (PHPLoader.debug && typeof Asyncify !== "undefined") {
    const originalHandleSleep = Asyncify.handleSleep;
    Asyncify.handleSleep = function(startAsync) {
      if (!ABORT) {
        Module["lastAsyncifyStackSource"] = new Error();
      }
      return originalHandleSleep(startAsync);
    };
  }
  const originalRemoveRunDependency = PHPLoader["removeRunDependency"];
  PHPLoader["removeRunDependency"] = function(...args) {
    try {
      originalRemoveRunDependency(...args);
    } catch (e) {
      PHPLoader["onAbort"](e);
    }
  };
  PHPLoader["malloc"] = _malloc;
  PHPLoader["free"] = _free;
  return PHPLoader;
}
var dependencyFilename9, dependenciesTotalSize9;
var init_php_7_0 = __esm({
  "packages/php-wasm/node/public/php_7_0.js"() {
    "use strict";
    dependencyFilename9 = __dirname + "/7_0_33/php_7_0.wasm";
    dependenciesTotalSize9 = 13341609;
  }
});

// packages/php-wasm/node/src/index.ts
var src_exports = {};
__export(src_exports, {
  createNodeFsMountHandler: () => createNodeFsMountHandler,
  getPHPLoaderModule: () => getPHPLoaderModule,
  loadNodeRuntime: () => loadNodeRuntime,
  useHostFilesystem: () => useHostFilesystem,
  withNetworking: () => withNetworking
});
module.exports = __toCommonJS(src_exports);

// packages/php-wasm/node-polyfills/src/lib/current-js-runtime.ts
var currentJsRuntime = function() {
  if (typeof process !== "undefined" && process.release?.name === "node") {
    return "NODE";
  } else if (typeof window !== "undefined") {
    return "WEB";
  } else if (
    // @ts-ignore
    typeof WorkerGlobalScope !== "undefined" && // @ts-ignore
    self instanceof WorkerGlobalScope
  ) {
    return "WORKER";
  } else {
    return "NODE";
  }
}();

// packages/php-wasm/node-polyfills/src/lib/blob.ts
if (currentJsRuntime === "NODE") {
  let asPromise = function(obj) {
    return new Promise(function(resolve, reject) {
      obj.onload = obj.onerror = function(event) {
        obj.onload = obj.onerror = null;
        if (event.type === "load") {
          resolve(obj.result);
        } else {
          reject(new Error("Failed to read the blob/file"));
        }
      };
    });
  }, isByobSupported = function() {
    const inputBytes = new Uint8Array([1, 2, 3, 4]);
    const file = new File([inputBytes], "test");
    const stream = file.stream();
    try {
      stream.getReader({ mode: "byob" });
      return true;
    } catch (e) {
      return false;
    }
  };
  asPromise2 = asPromise, isByobSupported2 = isByobSupported;
  if (typeof File === "undefined") {
    class File2 extends Blob {
      constructor(sources, fileName, options) {
        super(sources);
        let date;
        if (options?.lastModified) {
          date = /* @__PURE__ */ new Date();
        }
        if (!date || isNaN(date.getFullYear())) {
          date = /* @__PURE__ */ new Date();
        }
        this.lastModifiedDate = date;
        this.lastModified = date.getMilliseconds();
        this.name = fileName || "";
      }
    }
    global.File = File2;
  }
  if (typeof Blob.prototype.arrayBuffer === "undefined") {
    Blob.prototype.arrayBuffer = function arrayBuffer() {
      const reader = new FileReader();
      reader.readAsArrayBuffer(this);
      return asPromise(reader);
    };
  }
  if (typeof Blob.prototype.text === "undefined") {
    Blob.prototype.text = function text() {
      const reader = new FileReader();
      reader.readAsText(this);
      return asPromise(reader);
    };
  }
  if (typeof Blob.prototype.stream === "undefined" || !isByobSupported()) {
    Blob.prototype.stream = function() {
      let position = 0;
      const blob = this;
      return new ReadableStream({
        type: "bytes",
        // 0.5 MB seems like a reasonable chunk size, let's adjust
        // this if needed.
        autoAllocateChunkSize: 512 * 1024,
        async pull(controller) {
          const view = controller.byobRequest.view;
          const chunk = blob.slice(
            position,
            position + view.byteLength
          );
          const buffer = await chunk.arrayBuffer();
          const uint8array = new Uint8Array(buffer);
          new Uint8Array(view.buffer).set(uint8array);
          const bytesRead = uint8array.byteLength;
          controller.byobRequest.respond(bytesRead);
          position += bytesRead;
          if (position >= blob.size) {
            controller.close();
          }
        }
      });
    };
  }
}
var asPromise2;
var isByobSupported2;

// packages/php-wasm/node-polyfills/src/lib/custom-event.ts
if (currentJsRuntime === "NODE" && typeof CustomEvent === "undefined") {
  class CustomEvent2 extends Event {
    constructor(name, options = {}) {
      super(name, options);
      this.detail = options.detail;
    }
    initCustomEvent() {
    }
  }
  globalThis.CustomEvent = CustomEvent2;
}

// packages/php-wasm/universal/src/lib/rethrow-file-system-error.ts
var FileErrorCodes = {
  0: "No error occurred. System call completed successfully.",
  1: "Argument list too long.",
  2: "Permission denied.",
  3: "Address in use.",
  4: "Address not available.",
  5: "Address family not supported.",
  6: "Resource unavailable, or operation would block.",
  7: "Connection already in progress.",
  8: "Bad file descriptor.",
  9: "Bad message.",
  10: "Device or resource busy.",
  11: "Operation canceled.",
  12: "No child processes.",
  13: "Connection aborted.",
  14: "Connection refused.",
  15: "Connection reset.",
  16: "Resource deadlock would occur.",
  17: "Destination address required.",
  18: "Mathematics argument out of domain of function.",
  19: "Reserved.",
  20: "File exists.",
  21: "Bad address.",
  22: "File too large.",
  23: "Host is unreachable.",
  24: "Identifier removed.",
  25: "Illegal byte sequence.",
  26: "Operation in progress.",
  27: "Interrupted function.",
  28: "Invalid argument.",
  29: "I/O error.",
  30: "Socket is connected.",
  31: "There is a directory under that path.",
  32: "Too many levels of symbolic links.",
  33: "File descriptor value too large.",
  34: "Too many links.",
  35: "Message too large.",
  36: "Reserved.",
  37: "Filename too long.",
  38: "Network is down.",
  39: "Connection aborted by network.",
  40: "Network unreachable.",
  41: "Too many files open in system.",
  42: "No buffer space available.",
  43: "No such device.",
  44: "There is no such file or directory OR the parent directory does not exist.",
  45: "Executable file format error.",
  46: "No locks available.",
  47: "Reserved.",
  48: "Not enough space.",
  49: "No message of the desired type.",
  50: "Protocol not available.",
  51: "No space left on device.",
  52: "Function not supported.",
  53: "The socket is not connected.",
  54: "Not a directory or a symbolic link to a directory.",
  55: "Directory not empty.",
  56: "State not recoverable.",
  57: "Not a socket.",
  58: "Not supported, or operation not supported on socket.",
  59: "Inappropriate I/O control operation.",
  60: "No such device or address.",
  61: "Value too large to be stored in data type.",
  62: "Previous owner died.",
  63: "Operation not permitted.",
  64: "Broken pipe.",
  65: "Protocol error.",
  66: "Protocol not supported.",
  67: "Protocol wrong type for socket.",
  68: "Result too large.",
  69: "Read-only file system.",
  70: "Invalid seek.",
  71: "No such process.",
  72: "Reserved.",
  73: "Connection timed out.",
  74: "Text file busy.",
  75: "Cross-device link.",
  76: "Extension: Capabilities insufficient."
};
function getEmscriptenFsError(e) {
  const errno = typeof e === "object" ? e?.errno : null;
  if (errno in FileErrorCodes) {
    return FileErrorCodes[errno];
  }
}
function rethrowFileSystemError(messagePrefix = "") {
  return function catchFileSystemError(target, methodName, descriptor) {
    const method = descriptor.value;
    descriptor.value = function(...args) {
      try {
        return method.apply(this, args);
      } catch (e) {
        const errno = typeof e === "object" ? e?.errno : null;
        if (errno in FileErrorCodes) {
          const errmsg = FileErrorCodes[errno];
          const path = typeof args[1] === "string" ? args[1] : null;
          const formattedPrefix = path !== null ? messagePrefix.replaceAll("{path}", path) : messagePrefix;
          throw new Error(`${formattedPrefix}: ${errmsg}`, {
            cause: e
          });
        }
        throw e;
      }
    };
  };
}

// packages/php-wasm/logger/src/lib/handlers/log-event.ts
var logEventType = "playground-log";
var logEvent = (log3, ...args) => {
  logger.dispatchEvent(
    new CustomEvent(logEventType, {
      detail: {
        log: log3,
        args
      }
    })
  );
};

// packages/php-wasm/logger/src/lib/handlers/log-to-console.ts
var logToConsole = (log3, ...args) => {
  if (typeof log3.message === "string") {
    log3.message = prepareLogMessage(log3.message);
  } else if (log3.message.message && typeof log3.message.message === "string") {
    log3.message.message = prepareLogMessage(log3.message.message);
  }
  switch (log3.severity) {
    case "Debug":
      console.debug(log3.message, ...args);
      break;
    case "Info":
      console.info(log3.message, ...args);
      break;
    case "Warn":
      console.warn(log3.message, ...args);
      break;
    case "Error":
      console.error(log3.message, ...args);
      break;
    case "Fatal":
      console.error(log3.message, ...args);
      break;
    default:
      console.log(log3.message, ...args);
  }
};

// packages/php-wasm/logger/src/lib/handlers/log-to-memory.ts
var prepareLogMessage2 = (logMessage) => {
  if (logMessage instanceof Error) {
    return [logMessage.message, logMessage.stack].join("\n");
  }
  return JSON.stringify(logMessage, null, 2);
};
var logs = [];
var addToLogArray = (message) => {
  logs.push(message);
};
var logToMemory = (log3) => {
  if (log3.raw === true) {
    addToLogArray(log3.message);
  } else {
    const message = formatLogEntry(
      typeof log3.message === "object" ? prepareLogMessage2(log3.message) : log3.message,
      log3.severity ?? "Info",
      log3.prefix ?? "JavaScript"
    );
    addToLogArray(message);
  }
};

// packages/php-wasm/logger/src/lib/logger.ts
var Logger = class extends EventTarget {
  // constructor
  constructor(handlers = []) {
    super();
    this.handlers = handlers;
    this.fatalErrorEvent = "playground-fatal-error";
  }
  /**
   * Get all logs.
   * @returns string[]
   */
  getLogs() {
    if (!this.handlers.includes(logToMemory)) {
      this.error(`Logs aren't stored because the logToMemory handler isn't registered.
				If you're using a custom logger instance, make sure to register logToMemory handler.
			`);
      return [];
    }
    return [...logs];
  }
  /**
   * Log message with severity.
   *
   * @param message any
   * @param severity LogSeverity
   * @param raw boolean
   * @param args any
   */
  logMessage(log3, ...args) {
    for (const handler2 of this.handlers) {
      handler2(log3, ...args);
    }
  }
  /**
   * Log message
   *
   * @param message any
   * @param args any
   */
  log(message, ...args) {
    this.logMessage(
      {
        message,
        severity: void 0,
        prefix: "JavaScript",
        raw: false
      },
      ...args
    );
  }
  /**
   * Log debug message
   *
   * @param message any
   * @param args any
   */
  debug(message, ...args) {
    this.logMessage(
      {
        message,
        severity: "Debug",
        prefix: "JavaScript",
        raw: false
      },
      ...args
    );
  }
  /**
   * Log info message
   *
   * @param message any
   * @param args any
   */
  info(message, ...args) {
    this.logMessage(
      {
        message,
        severity: "Info",
        prefix: "JavaScript",
        raw: false
      },
      ...args
    );
  }
  /**
   * Log warning message
   *
   * @param message any
   * @param args any
   */
  warn(message, ...args) {
    this.logMessage(
      {
        message,
        severity: "Warn",
        prefix: "JavaScript",
        raw: false
      },
      ...args
    );
  }
  /**
   * Log error message
   *
   * @param message any
   * @param args any
   */
  error(message, ...args) {
    this.logMessage(
      {
        message,
        severity: "Error",
        prefix: "JavaScript",
        raw: false
      },
      ...args
    );
  }
};
var getDefaultHandlers = () => {
  try {
    if (process.env["NODE_ENV"] === "test") {
      return [logToMemory, logEvent];
    }
  } catch (e) {
  }
  return [logToMemory, logToConsole, logEvent];
};
var logger = new Logger(getDefaultHandlers());
var prepareLogMessage = (message) => {
  return message.replace(/\t/g, "");
};
var formatLogEntry = (message, severity, prefix) => {
  const date = /* @__PURE__ */ new Date();
  const formattedDate = new Intl.DateTimeFormat("en-GB", {
    year: "numeric",
    month: "short",
    day: "2-digit",
    timeZone: "UTC"
  }).format(date).replace(/ /g, "-");
  const formattedTime = new Intl.DateTimeFormat("en-GB", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
    timeZone: "UTC",
    timeZoneName: "short"
  }).format(date);
  const now = formattedDate + " " + formattedTime;
  message = prepareLogMessage(message);
  return `[${now}] ${prefix} ${severity}: ${message}`;
};

// packages/php-wasm/util/src/lib/sleep.ts
var SleepFinished = Symbol("SleepFinished");
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(SleepFinished), ms);
  });
}

// packages/php-wasm/util/src/lib/semaphore.ts
var AcquireTimeoutError = class extends Error {
  constructor() {
    super("Acquiring lock timed out");
  }
};
var Semaphore = class {
  constructor({ concurrency, timeout }) {
    this._running = 0;
    this.concurrency = concurrency;
    this.timeout = timeout;
    this.queue = [];
  }
  get remaining() {
    return this.concurrency - this.running;
  }
  get running() {
    return this._running;
  }
  async acquire() {
    while (true) {
      if (this._running >= this.concurrency) {
        const acquired = new Promise((resolve) => {
          this.queue.push(resolve);
        });
        if (this.timeout !== void 0) {
          await Promise.race([acquired, sleep(this.timeout)]).then(
            (value) => {
              if (value === SleepFinished) {
                throw new AcquireTimeoutError();
              }
            }
          );
        } else {
          await acquired;
        }
      } else {
        this._running++;
        let released = false;
        return () => {
          if (released) {
            return;
          }
          released = true;
          this._running--;
          if (this.queue.length > 0) {
            this.queue.shift()();
          }
        };
      }
    }
  }
  async run(fn) {
    const release = await this.acquire();
    try {
      return await fn();
    } finally {
      release();
    }
  }
};

// packages/php-wasm/util/src/lib/paths.ts
function joinPaths(...paths) {
  let path = paths.join("/");
  const isAbsolute = path[0] === "/";
  const trailingSlash = path.substring(path.length - 1) === "/";
  path = normalizePath(path);
  if (!path && !isAbsolute) {
    path = ".";
  }
  if (path && trailingSlash) {
    path += "/";
  }
  return path;
}
function dirname(path) {
  if (path === "/") {
    return "/";
  }
  path = normalizePath(path);
  const lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) {
    return "";
  } else if (lastSlash === 0) {
    return "/";
  }
  return path.substr(0, lastSlash);
}
function normalizePath(path) {
  const isAbsolute = path[0] === "/";
  path = normalizePathsArray(
    path.split("/").filter((p) => !!p),
    !isAbsolute
  ).join("/");
  return (isAbsolute ? "/" : "") + path.replace(/\/$/, "");
}
function normalizePathsArray(parts, allowAboveRoot) {
  let up = 0;
  for (let i = parts.length - 1; i >= 0; i--) {
    const last = parts[i];
    if (last === ".") {
      parts.splice(i, 1);
    } else if (last === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up; up--) {
      parts.unshift("..");
    }
  }
  return parts;
}

// packages/php-wasm/util/src/lib/split-shell-command.ts
function splitShellCommand(command) {
  const MODE_UNQUOTED = 0;
  const MODE_IN_QUOTE = 1;
  let mode = MODE_UNQUOTED;
  let quote = "";
  const parts = [];
  let currentPart = "";
  for (let i = 0; i < command.length; i++) {
    const char = command[i];
    if (char === "\\") {
      if (command[i + 1] === '"' || command[i + 1] === "'") {
        i++;
      }
      currentPart += command[i];
    } else if (mode === MODE_UNQUOTED) {
      if (char === '"' || char === "'") {
        mode = MODE_IN_QUOTE;
        quote = char;
      } else if (char.match(/\s/)) {
        if (currentPart.trim().length) {
          parts.push(currentPart.trim());
        }
        currentPart = char;
      } else if (parts.length && !currentPart) {
        currentPart = parts.pop() + char;
      } else {
        currentPart += char;
      }
    } else if (mode === MODE_IN_QUOTE) {
      if (char === quote) {
        mode = MODE_UNQUOTED;
        quote = "";
      } else {
        currentPart += char;
      }
    }
  }
  if (currentPart) {
    parts.push(currentPart.trim());
  }
  return parts;
}

// packages/php-wasm/util/src/lib/create-spawn-handler.ts
function createSpawnHandler(program) {
  return function(command, argsArray = [], options = {}) {
    const childProcess = new ChildProcess();
    const processApi = new ProcessApi(childProcess);
    setTimeout(async () => {
      let commandArray = [];
      if (argsArray.length) {
        commandArray = [command, ...argsArray];
      } else if (typeof command === "string") {
        commandArray = splitShellCommand(command);
      } else if (Array.isArray(command)) {
        commandArray = command;
      } else {
        throw new Error("Invalid command ", command);
      }
      try {
        await program(commandArray, processApi, options);
      } catch (e) {
        childProcess.emit("error", e);
        if (typeof e === "object" && e !== null && "message" in e && typeof e.message === "string") {
          processApi.stderr(e.message);
        }
        processApi.exit(1);
      }
      childProcess.emit("spawn", true);
    });
    return childProcess;
  };
}
var EventEmitter = class {
  constructor() {
    this.listeners = {};
  }
  emit(eventName, data) {
    if (this.listeners[eventName]) {
      this.listeners[eventName].forEach(function(listener) {
        listener(data);
      });
    }
  }
  on(eventName, listener) {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
    }
    this.listeners[eventName].push(listener);
  }
};
var ProcessApi = class extends EventEmitter {
  constructor(childProcess) {
    super();
    this.childProcess = childProcess;
    this.exited = false;
    this.stdinData = [];
    childProcess.on("stdin", (data) => {
      if (this.stdinData) {
        this.stdinData.push(data.slice());
      } else {
        this.emit("stdin", data);
      }
    });
  }
  stdout(data) {
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
    }
    this.childProcess.stdout.emit("data", data);
  }
  stdoutEnd() {
    this.childProcess.stdout.emit("end", {});
  }
  stderr(data) {
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
    }
    this.childProcess.stderr.emit("data", data);
  }
  stderrEnd() {
    this.childProcess.stderr.emit("end", {});
  }
  exit(code) {
    if (!this.exited) {
      this.exited = true;
      this.childProcess.emit("exit", code);
    }
  }
  flushStdin() {
    if (this.stdinData) {
      for (let i = 0; i < this.stdinData.length; i++) {
        this.emit("stdin", this.stdinData[i]);
      }
    }
    this.stdinData = null;
  }
};
var lastPid = 9743;
var ChildProcess = class extends EventEmitter {
  constructor(pid = lastPid++) {
    super();
    this.pid = pid;
    this.stdout = new EventEmitter();
    this.stderr = new EventEmitter();
    const self2 = this;
    this.stdin = {
      write: (data) => {
        self2.emit("stdin", data);
      }
    };
  }
};

// packages/php-wasm/universal/src/lib/fs-helpers.ts
var _FSHelpers = class _FSHelpers {
  static readFileAsText(FS, path) {
    return new TextDecoder().decode(_FSHelpers.readFileAsBuffer(FS, path));
  }
  static readFileAsBuffer(FS, path) {
    return FS.readFile(path);
  }
  static writeFile(FS, path, data) {
    FS.writeFile(path, data);
  }
  static unlink(FS, path) {
    FS.unlink(path);
  }
  /**
   * Moves a file or directory in the PHP filesystem to a
   * new location.
   *
   * @param oldPath The path to rename.
   * @param newPath The new path.
   */
  static mv(FS, fromPath, toPath) {
    try {
      const fromMount = FS.lookupPath(fromPath).node.mount;
      const toMount = _FSHelpers.fileExists(FS, toPath) ? FS.lookupPath(toPath).node.mount : FS.lookupPath(dirname(toPath)).node.mount;
      const movingBetweenFilesystems = fromMount.mountpoint !== toMount.mountpoint;
      if (movingBetweenFilesystems) {
        _FSHelpers.copyRecursive(FS, fromPath, toPath);
        _FSHelpers.rmdir(FS, fromPath, { recursive: true });
      } else {
        FS.rename(fromPath, toPath);
      }
    } catch (e) {
      const errmsg = getEmscriptenFsError(e);
      if (!errmsg) {
        throw e;
      }
      throw new Error(
        `Could not move ${fromPath} to ${toPath}: ${errmsg}`,
        {
          cause: e
        }
      );
    }
  }
  static rmdir(FS, path, options = { recursive: true }) {
    if (options?.recursive) {
      _FSHelpers.listFiles(FS, path).forEach((file) => {
        const filePath = `${path}/${file}`;
        if (_FSHelpers.isDir(FS, filePath)) {
          _FSHelpers.rmdir(FS, filePath, options);
        } else {
          _FSHelpers.unlink(FS, filePath);
        }
      });
    }
    FS.rmdir(path);
  }
  static listFiles(FS, path, options = { prependPath: false }) {
    if (!_FSHelpers.fileExists(FS, path)) {
      return [];
    }
    try {
      const files = FS.readdir(path).filter(
        (name) => name !== "." && name !== ".."
      );
      if (options.prependPath) {
        const prepend = path.replace(/\/$/, "");
        return files.map((name) => `${prepend}/${name}`);
      }
      return files;
    } catch (e) {
      logger.error(e, { path });
      return [];
    }
  }
  static isDir(FS, path) {
    if (!_FSHelpers.fileExists(FS, path)) {
      return false;
    }
    return FS.isDir(FS.lookupPath(path).node.mode);
  }
  static fileExists(FS, path) {
    try {
      FS.lookupPath(path);
      return true;
    } catch (e) {
      return false;
    }
  }
  static mkdir(FS, path) {
    FS.mkdirTree(path);
  }
  static copyRecursive(FS, fromPath, toPath) {
    const fromNode = FS.lookupPath(fromPath).node;
    if (FS.isDir(fromNode.mode)) {
      FS.mkdirTree(toPath);
      const filenames = FS.readdir(fromPath).filter(
        (name) => name !== "." && name !== ".."
      );
      for (const filename of filenames) {
        _FSHelpers.copyRecursive(
          FS,
          joinPaths(fromPath, filename),
          joinPaths(toPath, filename)
        );
      }
    } else {
      FS.writeFile(toPath, FS.readFile(fromPath));
    }
  }
};
__decorateClass([
  rethrowFileSystemError('Could not read "{path}"')
], _FSHelpers, "readFileAsText", 1);
__decorateClass([
  rethrowFileSystemError('Could not read "{path}"')
], _FSHelpers, "readFileAsBuffer", 1);
__decorateClass([
  rethrowFileSystemError('Could not write to "{path}"')
], _FSHelpers, "writeFile", 1);
__decorateClass([
  rethrowFileSystemError('Could not unlink "{path}"')
], _FSHelpers, "unlink", 1);
__decorateClass([
  rethrowFileSystemError('Could not remove directory "{path}"')
], _FSHelpers, "rmdir", 1);
__decorateClass([
  rethrowFileSystemError('Could not list files in "{path}"')
], _FSHelpers, "listFiles", 1);
__decorateClass([
  rethrowFileSystemError('Could not stat "{path}"')
], _FSHelpers, "isDir", 1);
__decorateClass([
  rethrowFileSystemError('Could not stat "{path}"')
], _FSHelpers, "fileExists", 1);
__decorateClass([
  rethrowFileSystemError('Could not create directory "{path}"')
], _FSHelpers, "mkdir", 1);
__decorateClass([
  rethrowFileSystemError('Could not copy files from "{path}"')
], _FSHelpers, "copyRecursive", 1);
var FSHelpers = _FSHelpers;

// packages/php-wasm/universal/src/lib/php-response.ts
var responseTexts = {
  500: "Internal Server Error",
  502: "Bad Gateway",
  404: "Not Found",
  403: "Forbidden",
  401: "Unauthorized",
  400: "Bad Request",
  301: "Moved Permanently",
  302: "Found",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  204: "No Content",
  201: "Created",
  200: "OK"
};
var PHPResponse = class _PHPResponse {
  constructor(httpStatusCode, headers, body, errors = "", exitCode = 0) {
    this.httpStatusCode = httpStatusCode;
    this.headers = headers;
    this.bytes = body;
    this.exitCode = exitCode;
    this.errors = errors;
  }
  static forHttpCode(httpStatusCode, text = "") {
    return new _PHPResponse(
      httpStatusCode,
      {},
      new TextEncoder().encode(
        text || responseTexts[httpStatusCode] || ""
      )
    );
  }
  static fromRawData(data) {
    return new _PHPResponse(
      data.httpStatusCode,
      data.headers,
      data.bytes,
      data.errors,
      data.exitCode
    );
  }
  toRawData() {
    return {
      headers: this.headers,
      bytes: this.bytes,
      errors: this.errors,
      exitCode: this.exitCode,
      httpStatusCode: this.httpStatusCode
    };
  }
  /**
   * Response body as JSON.
   */
  get json() {
    return JSON.parse(this.text);
  }
  /**
   * Response body as text.
   */
  get text() {
    return new TextDecoder().decode(this.bytes);
  }
};

// packages/php-wasm/universal/src/lib/load-php-runtime.ts
var RuntimeId = Symbol("RuntimeId");
var loadedRuntimes = /* @__PURE__ */ new Map();
var lastRuntimeId = 0;
async function loadPHPRuntime(phpLoaderModule, phpModuleArgs = {}) {
  const [phpReady, resolvePHP, rejectPHP] = makePromise();
  const PHPRuntime = phpLoaderModule.init(currentJsRuntime2, {
    onAbort(reason) {
      rejectPHP(reason);
      logger.error(reason);
    },
    ENV: {},
    // Emscripten sometimes prepends a '/' to the path, which
    // breaks vite dev mode. An identity `locateFile` function
    // fixes it.
    locateFile: (path) => path,
    ...phpModuleArgs,
    noInitialRun: true,
    onRuntimeInitialized() {
      if (phpModuleArgs.onRuntimeInitialized) {
        phpModuleArgs.onRuntimeInitialized();
      }
      resolvePHP();
    }
  });
  await phpReady;
  const id = ++lastRuntimeId;
  PHPRuntime.id = id;
  PHPRuntime.originalExit = PHPRuntime._exit;
  PHPRuntime._exit = function(code) {
    loadedRuntimes.delete(id);
    return PHPRuntime.originalExit(code);
  };
  PHPRuntime[RuntimeId] = id;
  loadedRuntimes.set(id, PHPRuntime);
  console.log('set loadedRuntimes', loadedRuntimes?.keys())
  return id;
}
function getLoadedRuntime(id) {
  console.log('get loadedRuntimes', loadedRuntimes?.keys());
  return loadedRuntimes.get(id);
}
var currentJsRuntime2 = function() {
  if (typeof process !== "undefined" && process.release?.name === "node") {
    return "NODE";
  } else if (typeof window !== "undefined") {
    return "WEB";
  } else if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return "WORKER";
  } else {
    return "NODE";
  }
}();
var makePromise = () => {
  const methods = [];
  const promise = new Promise((resolve, reject) => {
    methods.push(resolve, reject);
  });
  methods.unshift(promise);
  return methods;
};

// packages/php-wasm/universal/src/lib/error-event-polyfill.ts
var kError = Symbol("error");
var kMessage = Symbol("message");
var ErrorEvent2 = class extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param type The name of the event
   * @param options A dictionary object that allows for setting
   *                  attributes via object members of the same name.
   */
  constructor(type, options = {}) {
    super(type);
    this[kError] = options.error === void 0 ? null : options.error;
    this[kMessage] = options.message === void 0 ? "" : options.message;
  }
  static {
    kError, kMessage;
  }
  get error() {
    return this[kError];
  }
  get message() {
    return this[kMessage];
  }
};
Object.defineProperty(ErrorEvent2.prototype, "error", { enumerable: true });
Object.defineProperty(ErrorEvent2.prototype, "message", { enumerable: true });
var ErrorEvent = typeof globalThis.ErrorEvent === "function" ? globalThis.ErrorEvent : ErrorEvent2;

// packages/php-wasm/universal/src/lib/is-exit-code-zero.ts
function isExitCodeZero(e) {
  if (!(e instanceof Error)) {
    return false;
  }
  return "exitCode" in e && e?.exitCode === 0 || e?.name === "ExitStatus" && "status" in e && e.status === 0;
}

// packages/php-wasm/universal/src/lib/wasm-error-reporting.ts
var UnhandledRejectionsTarget = class extends EventTarget {
  constructor() {
    super(...arguments);
    this.listenersCount = 0;
  }
  addEventListener(type, callback) {
    ++this.listenersCount;
    super.addEventListener(type, callback);
  }
  removeEventListener(type, callback) {
    --this.listenersCount;
    super.removeEventListener(type, callback);
  }
  hasListeners() {
    return this.listenersCount > 0;
  }
};
function improveWASMErrorReporting(runtime) {
  const target = new UnhandledRejectionsTarget();
  for (const key in runtime.wasmExports) {
    if (typeof runtime.wasmExports[key] == "function") {
      const original = runtime.wasmExports[key];
      runtime.wasmExports[key] = function(...args) {
        try {
          return original(...args);
        } catch (e) {
          if (!(e instanceof Error)) {
            throw e;
          }
          const clearMessage = clarifyErrorMessage(
            e,
            runtime.lastAsyncifyStackSource?.stack
          );
          if (runtime.lastAsyncifyStackSource) {
            e.cause = runtime.lastAsyncifyStackSource;
          }
          if (target.hasListeners()) {
            target.dispatchEvent(
              new ErrorEvent("error", {
                error: e,
                message: clearMessage
              })
            );
            return;
          }
          if (!isExitCodeZero(e)) {
            showCriticalErrorBox(clearMessage);
          }
          throw e;
        }
      };
    }
  }
  return target;
}
var functionsMaybeMissingFromAsyncify = [];
function getFunctionsMaybeMissingFromAsyncify() {
  return functionsMaybeMissingFromAsyncify;
}
function clarifyErrorMessage(crypticError, asyncifyStack) {
  if (crypticError.message === "unreachable") {
    let betterMessage = UNREACHABLE_ERROR;
    if (!asyncifyStack) {
      betterMessage += `

This stack trace is lacking. For a better one initialize
the PHP runtime with { debug: true }, e.g. PHPNode.load('8.1', { debug: true }).

`;
    }
    functionsMaybeMissingFromAsyncify = extractPHPFunctionsFromStack(
      asyncifyStack || crypticError.stack || ""
    );
    for (const fn of functionsMaybeMissingFromAsyncify) {
      betterMessage += `    * ${fn}
`;
    }
    return betterMessage;
  }
  return crypticError.message;
}
var UNREACHABLE_ERROR = `
"unreachable" WASM instruction executed.

The typical reason is a PHP function missing from the ASYNCIFY_ONLY
list when building PHP.wasm.

You will need to file a new issue in the WordPress Playground repository
and paste this error message there:

https://github.com/WordPress/wordpress-playground/issues/new

If you're a core developer, the typical fix is to:

* Isolate a minimal reproduction of the error
* Add a reproduction of the error to php-asyncify.spec.ts in the WordPress Playground repository
* Run 'npm run fix-asyncify'
* Commit the changes, push to the repo, release updated NPM packages

Below is a list of all the PHP functions found in the stack trace to
help with the minimal reproduction. If they're all already listed in
the Dockerfile, you'll need to trigger this error again with long stack
traces enabled. In node.js, you can do it using the --stack-trace-limit=100
CLI option:

`;
var redBg = "\x1B[41m";
var bold = "\x1B[1m";
var reset = "\x1B[0m";
var eol = "\x1B[K";
var logged = false;
function showCriticalErrorBox(message) {
  if (logged) {
    return;
  }
  logged = true;
  if (message?.trim().startsWith("Program terminated with exit")) {
    return;
  }
  logger.log(`${redBg}
${eol}
${bold}  WASM ERROR${reset}${redBg}`);
  for (const line of message.split("\n")) {
    logger.log(`${eol}  ${line} `);
  }
  logger.log(`${reset}`);
}
function extractPHPFunctionsFromStack(stack) {
  try {
    const names = stack.split("\n").slice(1).map((line) => {
      const parts = line.trim().substring("at ".length).split(" ");
      return {
        fn: parts.length >= 2 ? parts[0] : "<unknown>",
        isWasm: line.includes("wasm://")
      };
    }).filter(
      ({ fn, isWasm }) => isWasm && !fn.startsWith("dynCall_") && !fn.startsWith("invoke_")
    ).map(({ fn }) => fn);
    return Array.from(new Set(names));
  } catch (err) {
    return [];
  }
}

// packages/php-wasm/universal/src/lib/php.ts
var STRING = "string";
var NUMBER = "number";
var __private__dont__use = Symbol("__private__dont__use");
var PHPExecutionFailureError = class extends Error {
  constructor(message, response, source) {
    super(message);
    this.response = response;
    this.source = source;
  }
};
var PHP_INI_PATH = "/internal/shared/php.ini";
var AUTO_PREPEND_SCRIPT = "/internal/shared/auto_prepend_file.php";
var PHP = class {
  /**
   * Initializes a PHP runtime.
   *
   * @internal
   * @param  PHPRuntime - Optional. PHP Runtime ID as initialized by loadPHPRuntime.
   * @param  requestHandlerOptions - Optional. Options for the PHPRequestHandler. If undefined, no request handler will be initialized.
   */
  constructor(PHPRuntimeId) {
    this.#webSapiInitialized = false;
    this.#wasmErrorsTarget = null;
    this.#eventListeners = /* @__PURE__ */ new Map();
    this.#messageListeners = [];
    this.semaphore = new Semaphore({ concurrency: 1 });
    if (PHPRuntimeId !== void 0) {
      this.initializeRuntime(PHPRuntimeId);
    }
  }
  #sapiName;
  #webSapiInitialized;
  #wasmErrorsTarget;
  #eventListeners;
  #messageListeners;
  /**
   * Adds an event listener for a PHP event.
   * @param eventType - The type of event to listen for.
   * @param listener - The listener function to be called when the event is triggered.
   */
  addEventListener(eventType, listener) {
    if (!this.#eventListeners.has(eventType)) {
      this.#eventListeners.set(eventType, /* @__PURE__ */ new Set());
    }
    this.#eventListeners.get(eventType).add(listener);
  }
  /**
   * Removes an event listener for a PHP event.
   * @param eventType - The type of event to remove the listener from.
   * @param listener - The listener function to be removed.
   */
  removeEventListener(eventType, listener) {
    this.#eventListeners.get(eventType)?.delete(listener);
  }
  dispatchEvent(event) {
    const listeners = this.#eventListeners.get(event.type);
    if (!listeners) {
      return;
    }
    for (const listener of listeners) {
      listener(event);
    }
  }
  /**
   * Listens to message sent by the PHP code.
   *
   * To dispatch messages, call:
   *
   *     post_message_to_js(string $data)
   *
   *     Arguments:
   *         $data (string)  Data to pass to JavaScript.
   *
   * @example
   *
   * ```ts
   * const php = await PHP.load('8.0');
   *
   * php.onMessage(
   *     // The data is always passed as a string
   *     function (data: string) {
   *         // Let's decode and log the data:
   *         console.log(JSON.parse(data));
   *     }
   * );
   *
   * // Now that we have a listener in place, let's
   * // dispatch a message:
   * await php.run({
   *     code: `<?php
   *         post_message_to_js(
   *             json_encode([
   *                 'post_id' => '15',
   *                 'post_title' => 'This is a blog post!'
   *             ])
   *         ));
   *     `,
   * });
   * ```
   *
   * @param listener Callback function to handle the message.
   */
  onMessage(listener) {
    this.#messageListeners.push(listener);
  }
  async setSpawnHandler(handler) {
    if (typeof handler === "string") {
      handler = createSpawnHandler(eval(handler));
    }
    this[__private__dont__use].spawnProcess = handler;
  }
  /** @deprecated Use PHPRequestHandler instead. */
  get absoluteUrl() {
    return this.requestHandler.absoluteUrl;
  }
  /** @deprecated Use PHPRequestHandler instead. */
  get documentRoot() {
    return this.requestHandler.documentRoot;
  }
  /** @deprecated Use PHPRequestHandler instead. */
  pathToInternalUrl(path) {
    return this.requestHandler.pathToInternalUrl(path);
  }
  /** @deprecated Use PHPRequestHandler instead. */
  internalUrlToPath(internalUrl) {
    return this.requestHandler.internalUrlToPath(internalUrl);
  }
  initializeRuntime(runtimeId) {
    if (this[__private__dont__use]) {
      throw new Error("PHP runtime already initialized.");
    }
    const runtime = getLoadedRuntime(runtimeId);
    if (!runtime) {
      throw new Error("Invalid PHP runtime id.");
    }
    this[__private__dont__use] = runtime;
    this[__private__dont__use].ccall(
      "wasm_set_phpini_path",
      null,
      ["string"],
      [PHP_INI_PATH]
    );
    if (!this.fileExists(PHP_INI_PATH)) {
      this.writeFile(
        PHP_INI_PATH,
        [
          "auto_prepend_file=" + AUTO_PREPEND_SCRIPT,
          "memory_limit=256M",
          "ignore_repeated_errors = 1",
          "error_reporting = E_ALL",
          "display_errors = 1",
          "html_errors = 1",
          "display_startup_errors = On",
          "log_errors = 1",
          "always_populate_raw_post_data = -1",
          "upload_max_filesize = 2000M",
          "post_max_size = 2000M",
          "disable_functions = curl_exec,curl_multi_exec",
          "allow_url_fopen = Off",
          "allow_url_include = Off",
          "session.save_path = /home/web_user",
          "implicit_flush = 1",
          "output_buffering = 0",
          "max_execution_time = 0",
          "max_input_time = -1"
        ].join("\n")
      );
    }
    if (!this.fileExists(AUTO_PREPEND_SCRIPT)) {
      this.writeFile(
        AUTO_PREPEND_SCRIPT,
        `<?php
				// Define constants set via defineConstant() calls
				if(file_exists('/internal/shared/consts.json')) {
					$consts = json_decode(file_get_contents('/internal/shared/consts.json'), true);
					foreach ($consts as $const => $value) {
						if (!defined($const) && is_scalar($value)) {
							define($const, $value);
						}
					}
				}
				// Preload all the files from /internal/shared/preload
				foreach (glob('/internal/shared/preload/*.php') as $file) {
					require_once $file;
				}
				`
      );
    }
    runtime["onMessage"] = async (data) => {
      for (const listener of this.#messageListeners) {
        const returnData = await listener(data);
        if (returnData) {
          return returnData;
        }
      }
      return "";
    };
    this.#wasmErrorsTarget = improveWASMErrorReporting(runtime);
    this.dispatchEvent({
      type: "runtime.initialized"
    });
  }
  /** @inheritDoc */
  async setSapiName(newName) {
    const result = this[__private__dont__use].ccall(
      "wasm_set_sapi_name",
      NUMBER,
      [STRING],
      [newName]
    );
    if (result !== 0) {
      throw new Error(
        "Could not set SAPI name. This can only be done before the PHP WASM module is initialized.Did you already dispatch any requests?"
      );
    }
    this.#sapiName = newName;
  }
  /**
   * Changes the current working directory in the PHP filesystem.
   * This is the directory that will be used as the base for relative paths.
   * For example, if the current working directory is `/root/php`, and the
   * path is `data`, the absolute path will be `/root/php/data`.
   *
   * @param  path - The new working directory.
   */
  chdir(path) {
    this[__private__dont__use].FS.chdir(path);
  }
  /**
   * Do not use. Use new PHPRequestHandler() instead.
   * @deprecated
   */
  async request(request) {
    logger.warn(
      "PHP.request() is deprecated. Please use new PHPRequestHandler() instead."
    );
    if (!this.requestHandler) {
      throw new Error("No request handler available.");
    }
    return this.requestHandler.request(request);
  }
  /**
   * Runs PHP code.
   *
   * This low-level method directly interacts with the WebAssembly
   * PHP interpreter.
   *
   * Every time you call run(), it prepares the PHP
   * environment and:
   *
   * * Resets the internal PHP state
   * * Populates superglobals ($_SERVER, $_GET, etc.)
   * * Handles file uploads
   * * Populates input streams (stdin, argv, etc.)
   * * Sets the current working directory
   *
   * You can use run() in two primary modes:
   *
   * ### Code snippet mode
   *
   * In this mode, you pass a string containing PHP code to run.
   *
   * ```ts
   * const result = await php.run({
   * 	code: `<?php echo "Hello world!";`
   * });
   * // result.text === "Hello world!"
   * ```
   *
   * In this mode, information like __DIR__ or __FILE__ isn't very
   * useful because the code is not associated with any file.
   *
   * Under the hood, the PHP snippet is passed to the `zend_eval_string`
   * C function.
   *
   * ### File mode
   *
   * In the file mode, you pass a scriptPath and PHP executes a file
   * found at a that path:
   *
   * ```ts
   * php.writeFile(
   * 	"/www/index.php",
   * 	`<?php echo "Hello world!";"`
   * );
   * const result = await php.run({
   * 	scriptPath: "/www/index.php"
   * });
   * // result.text === "Hello world!"
   * ```
   *
   * In this mode, you can rely on path-related information like __DIR__
   * or __FILE__.
   *
   * Under the hood, the PHP file is executed with the `php_execute_script`
   * C function.
   *
   * The `run()` method cannot be used in conjunction with `cli()`.
   *
   * @example
   * ```js
   * const result = await php.run(`<?php
   *  $fp = fopen('php://stderr', 'w');
   *  fwrite($fp, "Hello, world!");
   * `);
   * // result.errors === "Hello, world!"
   * ```
   *
   * @param  options - PHP runtime options.
   */
  async run(request) {
    const release = await this.semaphore.acquire();
    let heapBodyPointer;
    try {
      if (!this.#webSapiInitialized) {
        this.#initWebRuntime();
        this.#webSapiInitialized = true;
      }
      if (request.scriptPath && !this.fileExists(request.scriptPath)) {
        throw new Error(
          `The script path "${request.scriptPath}" does not exist.`
        );
      }
      this.#setRelativeRequestUri(request.relativeUri || "");
      this.#setRequestMethod(request.method || "GET");
      const headers = normalizeHeaders(request.headers || {});
      const host = headers["host"] || "example.com:443";
      const port = this.#inferPortFromHostAndProtocol(
        host,
        request.protocol || "http"
      );
      this.#setRequestHost(host);
      this.#setRequestPort(port);
      this.#setRequestHeaders(headers);
      if (request.body) {
        heapBodyPointer = this.#setRequestBody(request.body);
      }
      if (typeof request.code === "string") {
        this.writeFile("/internal/eval.php", request.code);
        this.#setScriptPath("/internal/eval.php");
      } else {
        this.#setScriptPath(request.scriptPath || "");
      }
      const $_SERVER = this.#prepareServerEntries(
        request.$_SERVER,
        headers,
        port
      );
      for (const key in $_SERVER) {
        this.#setServerGlobalEntry(key, $_SERVER[key]);
      }
      const env = request.env || {};
      for (const key in env) {
        this.#setEnv(key, env[key]);
      }
      const response = await this.#handleRequest();
      if (response.exitCode !== 0) {
        logger.warn(`PHP.run() output was:`, response.text);
        const error = new PHPExecutionFailureError(
          `PHP.run() failed with exit code ${response.exitCode} and the following output: ` + response.errors,
          response,
          "request"
        );
        logger.error(error);
        throw error;
      }
      return response;
    } catch (e) {
      this.dispatchEvent({
        type: "request.error",
        error: e,
        // Distinguish between PHP request and PHP-wasm errors
        source: e.source ?? "php-wasm"
      });
      throw e;
    } finally {
      try {
        if (heapBodyPointer) {
          this[__private__dont__use].free(heapBodyPointer);
        }
      } finally {
        release();
        this.dispatchEvent({
          type: "request.end"
        });
      }
    }
  }
  /**
   * Prepares the $_SERVER entries for the PHP runtime.
   *
   * @param defaults Default entries to include in $_SERVER.
   * @param headers HTTP headers to include in $_SERVER (as HTTP_ prefixed entries).
   * @param port HTTP port, used to determine infer $_SERVER['HTTPS'] value if none
   *             was provided.
   * @returns Computed $_SERVER entries.
   */
  #prepareServerEntries(defaults, headers, port) {
    const $_SERVER = {
      ...defaults || {}
    };
    $_SERVER["HTTPS"] = $_SERVER["HTTPS"] || port === 443 ? "on" : "off";
    for (const name in headers) {
      let HTTP_prefix = "HTTP_";
      if (["content-type", "content-length"].includes(name.toLowerCase())) {
        HTTP_prefix = "";
      }
      $_SERVER[`${HTTP_prefix}${name.toUpperCase().replace(/-/g, "_")}`] = headers[name];
    }
    return $_SERVER;
  }
  #initWebRuntime() {
    this[__private__dont__use].ccall("php_wasm_init", null, [], []);
  }
  #getResponseHeaders() {
    const headersFilePath = "/internal/headers.json";
    if (!this.fileExists(headersFilePath)) {
      throw new Error(
        "SAPI Error: Could not find response headers file."
      );
    }
    const headersData = JSON.parse(this.readFileAsText(headersFilePath));
    const headers = {};
    for (const line of headersData.headers) {
      if (!line.includes(": ")) {
        continue;
      }
      const colonIndex = line.indexOf(": ");
      const headerName = line.substring(0, colonIndex).toLowerCase();
      const headerValue = line.substring(colonIndex + 2);
      if (!(headerName in headers)) {
        headers[headerName] = [];
      }
      headers[headerName].push(headerValue);
    }
    return {
      headers,
      httpStatusCode: headersData.status
    };
  }
  #setRelativeRequestUri(uri) {
    this[__private__dont__use].ccall(
      "wasm_set_request_uri",
      null,
      [STRING],
      [uri]
    );
    if (uri.includes("?")) {
      const queryString = uri.substring(uri.indexOf("?") + 1);
      this[__private__dont__use].ccall(
        "wasm_set_query_string",
        null,
        [STRING],
        [queryString]
      );
    }
  }
  #setRequestHost(host) {
    this[__private__dont__use].ccall(
      "wasm_set_request_host",
      null,
      [STRING],
      [host]
    );
  }
  #setRequestPort(port) {
    this[__private__dont__use].ccall(
      "wasm_set_request_port",
      null,
      [NUMBER],
      [port]
    );
  }
  #inferPortFromHostAndProtocol(host, protocol) {
    let port;
    try {
      port = parseInt(new URL(host).port, 10);
    } catch (e) {
    }
    if (!port || isNaN(port) || port === 80) {
      port = protocol === "https" ? 443 : 80;
    }
    return port;
  }
  #setRequestMethod(method) {
    this[__private__dont__use].ccall(
      "wasm_set_request_method",
      null,
      [STRING],
      [method]
    );
  }
  #setRequestHeaders(headers) {
    if (headers["cookie"]) {
      this[__private__dont__use].ccall(
        "wasm_set_cookies",
        null,
        [STRING],
        [headers["cookie"]]
      );
    }
    if (headers["content-type"]) {
      this[__private__dont__use].ccall(
        "wasm_set_content_type",
        null,
        [STRING],
        [headers["content-type"]]
      );
    }
    if (headers["content-length"]) {
      this[__private__dont__use].ccall(
        "wasm_set_content_length",
        null,
        [NUMBER],
        [parseInt(headers["content-length"], 10)]
      );
    }
  }
  #setRequestBody(body) {
    let size, contentLength;
    if (typeof body === "string") {
      logger.warn(
        "Passing a string as the request body is deprecated. Please use a Uint8Array instead. See https://github.com/WordPress/wordpress-playground/issues/997 for more details"
      );
      contentLength = this[__private__dont__use].lengthBytesUTF8(body);
      size = contentLength + 1;
    } else {
      contentLength = body.byteLength;
      size = body.byteLength;
    }
    const heapBodyPointer = this[__private__dont__use].malloc(size);
    if (!heapBodyPointer) {
      throw new Error("Could not allocate memory for the request body.");
    }
    if (typeof body === "string") {
      this[__private__dont__use].stringToUTF8(
        body,
        heapBodyPointer,
        size + 1
      );
    } else {
      this[__private__dont__use].HEAPU8.set(body, heapBodyPointer);
    }
    this[__private__dont__use].ccall(
      "wasm_set_request_body",
      null,
      [NUMBER],
      [heapBodyPointer]
    );
    this[__private__dont__use].ccall(
      "wasm_set_content_length",
      null,
      [NUMBER],
      [contentLength]
    );
    return heapBodyPointer;
  }
  #setScriptPath(path) {
    this[__private__dont__use].ccall(
      "wasm_set_path_translated",
      null,
      [STRING],
      [path]
    );
  }
  #setServerGlobalEntry(key, value) {
    this[__private__dont__use].ccall(
      "wasm_add_SERVER_entry",
      null,
      [STRING, STRING],
      [key, value]
    );
  }
  #setEnv(name, value) {
    this[__private__dont__use].ccall(
      "wasm_add_ENV_entry",
      null,
      [STRING, STRING],
      [name, value]
    );
  }
  /**
   * Defines a constant in the PHP runtime.
   * @param key - The name of the constant.
   * @param value - The value of the constant.
   */
  defineConstant(key, value) {
    let consts = {};
    try {
      consts = JSON.parse(
        this.fileExists("/internal/shared/consts.json") ? this.readFileAsText("/internal/shared/consts.json") || "{}" : "{}"
      );
    } catch (e) {
    }
    this.writeFile(
      "/internal/shared/consts.json",
      JSON.stringify({
        ...consts,
        [key]: value
      })
    );
  }
  async #handleRequest() {
    let exitCode;
    let errorListener;
    try {
      exitCode = await new Promise((resolve, reject) => {
        errorListener = (e) => {
          logger.error(e);
          logger.error(e.error);
          const rethrown = new Error("Rethrown");
          rethrown.cause = e.error;
          rethrown.betterMessage = e.message;
          reject(rethrown);
        };
        this.#wasmErrorsTarget?.addEventListener(
          "error",
          errorListener
        );
        const response = this[__private__dont__use].ccall(
          "wasm_sapi_handle_request",
          NUMBER,
          [],
          [],
          { async: true }
        );
        if (response instanceof Promise) {
          return response.then(resolve, reject);
        }
        return resolve(response);
      });
    } catch (e) {
      for (const name in this) {
        if (typeof this[name] === "function") {
          this[name] = () => {
            throw new Error(
              `PHP runtime has crashed \u2013 see the earlier error for details.`
            );
          };
        }
      }
      this.functionsMaybeMissingFromAsyncify = getFunctionsMaybeMissingFromAsyncify();
      const err = e;
      const message = "betterMessage" in err ? err.betterMessage : err.message;
      const rethrown = new Error(message);
      rethrown.cause = err;
      logger.error(rethrown);
      throw rethrown;
    } finally {
      this.#wasmErrorsTarget?.removeEventListener("error", errorListener);
    }
    const { headers, httpStatusCode } = this.#getResponseHeaders();
    return new PHPResponse(
      exitCode === 0 ? httpStatusCode : 500,
      headers,
      this.readFileAsBuffer("/internal/stdout"),
      this.readFileAsText("/internal/stderr"),
      exitCode
    );
  }
  /**
   * Recursively creates a directory with the given path in the PHP filesystem.
   * For example, if the path is `/root/php/data`, and `/root` already exists,
   * it will create the directories `/root/php` and `/root/php/data`.
   *
   * @param  path - The directory path to create.
   */
  mkdir(path) {
    return FSHelpers.mkdir(this[__private__dont__use].FS, path);
  }
  /**
   * @deprecated Use mkdir instead.
   */
  mkdirTree(path) {
    return FSHelpers.mkdir(this[__private__dont__use].FS, path);
  }
  /**
   * Reads a file from the PHP filesystem and returns it as a string.
   *
   * @throws {@link @php-wasm/universal:ErrnoError}  If the file doesn't exist.
   * @param  path - The file path to read.
   * @returns The file contents.
   */
  readFileAsText(path) {
    return FSHelpers.readFileAsText(this[__private__dont__use].FS, path);
  }
  /**
   * Reads a file from the PHP filesystem and returns it as an array buffer.
   *
   * @throws {@link @php-wasm/universal:ErrnoError}  If the file doesn't exist.
   * @param  path - The file path to read.
   * @returns The file contents.
   */
  readFileAsBuffer(path) {
    return FSHelpers.readFileAsBuffer(this[__private__dont__use].FS, path);
  }
  /**
   * Overwrites data in a file in the PHP filesystem.
   * Creates a new file if one doesn't exist yet.
   *
   * @param  path - The file path to write to.
   * @param  data - The data to write to the file.
   */
  writeFile(path, data) {
    return FSHelpers.writeFile(this[__private__dont__use].FS, path, data);
  }
  /**
   * Removes a file from the PHP filesystem.
   *
   * @throws {@link @php-wasm/universal:ErrnoError}  If the file doesn't exist.
   * @param  path - The file path to remove.
   */
  unlink(path) {
    return FSHelpers.unlink(this[__private__dont__use].FS, path);
  }
  /**
   * Moves a file or directory in the PHP filesystem to a
   * new location.
   *
   * @param oldPath The path to rename.
   * @param newPath The new path.
   */
  mv(fromPath, toPath) {
    return FSHelpers.mv(this[__private__dont__use].FS, fromPath, toPath);
  }
  /**
   * Removes a directory from the PHP filesystem.
   *
   * @param path The directory path to remove.
   * @param options Options for the removal.
   */
  rmdir(path, options = { recursive: true }) {
    return FSHelpers.rmdir(this[__private__dont__use].FS, path, options);
  }
  /**
   * Lists the files and directories in the given directory.
   *
   * @param  path - The directory path to list.
   * @param  options - Options for the listing.
   * @returns The list of files and directories in the given directory.
   */
  listFiles(path, options = { prependPath: false }) {
    return FSHelpers.listFiles(
      this[__private__dont__use].FS,
      path,
      options
    );
  }
  /**
   * Checks if a directory exists in the PHP filesystem.
   *
   * @param  path  The path to check.
   * @returns True if the path is a directory, false otherwise.
   */
  isDir(path) {
    return FSHelpers.isDir(this[__private__dont__use].FS, path);
  }
  /**
   * Checks if a file (or a directory) exists in the PHP filesystem.
   *
   * @param  path - The file path to check.
   * @returns True if the file exists, false otherwise.
   */
  fileExists(path) {
    return FSHelpers.fileExists(this[__private__dont__use].FS, path);
  }
  /**
   * Hot-swaps the PHP runtime for a new one without
   * interrupting the operations of this PHP instance.
   *
   * @param runtime
   * @param cwd. Internal, the VFS path to recreate in the new runtime.
   *             This arg is temporary and will be removed once BasePHP
   *             is fully decoupled from the request handler and
   *             accepts a constructor-level cwd argument.
   */
  hotSwapPHPRuntime(runtime, cwd) {
    const oldFS = this[__private__dont__use].FS;
    try {
      this.exit();
    } catch (e) {
    }
    this.initializeRuntime(runtime);
    if (this.#sapiName) {
      this.setSapiName(this.#sapiName);
    }
    if (cwd) {
      copyFS(oldFS, this[__private__dont__use].FS, cwd);
    }
  }
  /**
   * Mounts a filesystem to a given path in the PHP filesystem.
   *
   * @param  virtualFSPath - Where to mount it in the PHP virtual filesystem.
   * @param  mountHandler - The mount handler to use.
   * @return Unmount function to unmount the filesystem.
   */
  async mount(virtualFSPath, mountHandler) {
    return await mountHandler(
      this,
      this[__private__dont__use].FS,
      virtualFSPath
    );
  }
  /**
   * Starts a PHP CLI session with given arguments.
   *
   * This method can only be used when PHP was compiled with the CLI SAPI
   * and it cannot be used in conjunction with `run()`.
   *
   * Once this method finishes running, the PHP instance is no
   * longer usable and should be discarded. This is because PHP
   * internally cleans up all the resources and calls exit().
   *
   * @param  argv - The arguments to pass to the CLI.
   * @returns The exit code of the CLI session.
   */
  async cli(argv) {
    for (const arg of argv) {
      this[__private__dont__use].ccall(
        "wasm_add_cli_arg",
        null,
        [STRING],
        [arg]
      );
    }
    try {
      return await this[__private__dont__use].ccall(
        "run_cli",
        null,
        [],
        [],
        {
          async: true
        }
      );
    } catch (error) {
      if (isExitCodeZero(error)) {
        return 0;
      }
      throw error;
    }
  }
  setSkipShebang(shouldSkip) {
    this[__private__dont__use].ccall(
      "wasm_set_skip_shebang",
      null,
      [NUMBER],
      [shouldSkip ? 1 : 0]
    );
  }
  exit(code = 0) {
    this.dispatchEvent({
      type: "runtime.beforedestroy"
    });
    try {
      this[__private__dont__use]._exit(code);
    } catch (e) {
    }
    this.#webSapiInitialized = false;
    this.#wasmErrorsTarget = null;
    delete this[__private__dont__use]["onMessage"];
    delete this[__private__dont__use];
  }
  [(__private__dont__use, Symbol.dispose)]() {
    if (this.#webSapiInitialized) {
      this.exit(0);
    }
  }
};
function normalizeHeaders(headers) {
  const normalized = {};
  for (const key in headers) {
    normalized[key.toLowerCase()] = headers[key];
  }
  return normalized;
}
function copyFS(source, target, path) {
  let oldNode;
  try {
    oldNode = source.lookupPath(path);
  } catch (e) {
    return;
  }
  if (!("contents" in oldNode.node)) {
    return;
  }
  try {
  } catch (e) {
  }
  if (!source.isDir(oldNode.node.mode)) {
    target.writeFile(path, source.readFile(path));
    return;
  }
  target.mkdirTree(path);
  const filenames = source.readdir(path).filter((name) => name !== "." && name !== "..");
  for (const filename of filenames) {
    copyFS(source, target, joinPaths(path, filename));
  }
}

// packages/php-wasm/universal/src/lib/ini.ts
var import_ini = __toESM(require_ini(), 1);

// packages/php-wasm/stream-compression/src/utils/iterable-stream-polyfill.ts
if (!ReadableStream.prototype[Symbol.asyncIterator]) {
  ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
    const reader = this.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          return;
        }
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  };
  ReadableStream.prototype.iterate = // @ts-ignore
  ReadableStream.prototype[Symbol.asyncIterator];
}

// packages/php-wasm/stream-compression/src/zip/decode-remote-zip.ts
var CENTRAL_DIRECTORY_END_SCAN_CHUNK_SIZE = 110 * 1024;
var BATCH_DOWNLOAD_OF_FILES_IF_CLOSER_THAN = 10 * 1024;
var PREFER_RANGES_IF_FILE_LARGER_THAN = 1024 * 1024 * 1;
var fetchSemaphore = new Semaphore({ concurrency: 10 });

// packages/php-wasm/universal/src/lib/php-process-manager.ts
var MaxPhpInstancesError = class extends Error {
  constructor(limit) {
    super(
      `Requested more concurrent PHP instances than the limit (${limit}).`
    );
    this.name = this.constructor.name;
  }
};
var PHPProcessManager = class {
  constructor(options) {
    this.primaryIdle = true;
    this.nextInstance = null;
    /**
     * All spawned PHP instances, including the primary PHP instance.
     * Used for bookkeeping and reaping all instances on dispose.
     */
    this.allInstances = [];
    this.maxPhpInstances = options?.maxPhpInstances ?? 5;
    this.phpFactory = options?.phpFactory;
    this.primaryPhp = options?.primaryPhp;
    this.semaphore = new Semaphore({
      concurrency: this.maxPhpInstances,
      /**
       * Wait up to 5 seconds for resources to become available
       * before assuming that all the PHP instances are deadlocked.
       */
      timeout: options?.timeout || 5e3
    });
  }
  /**
   * Get the primary PHP instance.
   *
   * If the primary PHP instance is not set, it will be spawned
   * using the provided phpFactory.
   *
   * @throws {Error} when called twice before the first call is resolved.
   */
  async getPrimaryPhp() {
    if (!this.phpFactory && !this.primaryPhp) {
      throw new Error(
        "phpFactory or primaryPhp must be set before calling getPrimaryPhp()."
      );
    } else if (!this.primaryPhp) {
      const spawned = await this.spawn({ isPrimary: true });
      this.primaryPhp = spawned.php;
    }
    return this.primaryPhp;
  }
  /**
   * Get a PHP instance.
   *
   * It could be either the primary PHP instance, an idle disposable PHP instance,
   * or a newly spawned PHP instance  depending on the resource availability.
   *
   * @throws {MaxPhpInstancesError} when the maximum number of PHP instances is reached
   *                                and the waiting timeout is exceeded.
   */
  async acquirePHPInstance() {
    if (this.primaryIdle) {
      this.primaryIdle = false;
      return {
        php: await this.getPrimaryPhp(),
        reap: () => this.primaryIdle = true
      };
    }
    const spawnedPhp = this.nextInstance || this.spawn({ isPrimary: false });
    if (this.semaphore.remaining > 0) {
      this.nextInstance = this.spawn({ isPrimary: false });
    } else {
      this.nextInstance = null;
    }
    return await spawnedPhp;
  }
  /**
   * Initiated spawning of a new PHP instance.
   * This function is synchronous on purpose  it needs to synchronously
   * add the spawn promise to the allInstances array without waiting
   * for PHP to spawn.
   */
  spawn(factoryArgs) {
    if (factoryArgs.isPrimary && this.allInstances.length > 0) {
      throw new Error(
        "Requested spawning a primary PHP instance when another primary instance already started spawning."
      );
    }
    const spawned = this.doSpawn(factoryArgs);
    this.allInstances.push(spawned);
    const pop = () => {
      this.allInstances = this.allInstances.filter(
        (instance) => instance !== spawned
      );
    };
    return spawned.catch((rejection) => {
      pop();
      throw rejection;
    }).then((result) => ({
      ...result,
      reap: () => {
        pop();
        result.reap();
      }
    }));
  }
  /**
   * Actually acquires the lock and spawns a new PHP instance.
   */
  async doSpawn(factoryArgs) {
    let release;
    try {
      release = await this.semaphore.acquire();
    } catch (error) {
      if (error instanceof AcquireTimeoutError) {
        throw new MaxPhpInstancesError(this.maxPhpInstances);
      }
      throw error;
    }
    try {
      const php = await this.phpFactory(factoryArgs);
      return {
        php,
        reap() {
          php.exit();
          release();
        }
      };
    } catch (e) {
      release();
      throw e;
    }
  }
  async [Symbol.asyncDispose]() {
    if (this.primaryPhp) {
      this.primaryPhp.exit();
    }
    await Promise.all(
      this.allInstances.map(
        (instance) => instance.then(({ reap }) => reap())
      )
    );
  }
};

// packages/php-wasm/universal/src/lib/supported-php-versions.ts
var SupportedPHPVersions = [
  "8.3",
  "8.2",
  "8.1",
  "8.0",
  "7.4",
  "7.3",
  "7.2",
  "7.1",
  "7.0"
];
var LatestSupportedPHPVersion = SupportedPHPVersions[0];

// packages/php-wasm/node/src/lib/get-php-loader-module.ts
async function getPHPLoaderModule(version = LatestSupportedPHPVersion) {
  switch (version) {
    case "8.3":
      return await Promise.resolve().then(() => (init_php_8_3(), php_8_3_exports));
    case "8.2":
      return await Promise.resolve().then(() => (init_php_8_2(), php_8_2_exports));
    case "8.1":
      return await Promise.resolve().then(() => (init_php_8_1(), php_8_1_exports));
    case "8.0":
      return await Promise.resolve().then(() => (init_php_8_0(), php_8_0_exports));
    case "7.4":
      return await Promise.resolve().then(() => (init_php_7_4(), php_7_4_exports));
    case "7.3":
      return await Promise.resolve().then(() => (init_php_7_3(), php_7_3_exports));
    case "7.2":
      return await Promise.resolve().then(() => (init_php_7_2(), php_7_2_exports));
    case "7.1":
      return await Promise.resolve().then(() => (init_php_7_1(), php_7_1_exports));
    case "7.0":
      return await Promise.resolve().then(() => (init_php_7_0(), php_7_0_exports));
  }
  throw new Error(`Unsupported PHP version ${version}`);
}

// packages/php-wasm/node/src/lib/networking/outbound-ws-to-tcp-proxy.ts
var dns = __toESM(require("dns"));
var util = __toESM(require("node:util"));
var net2 = __toESM(require("net"));
var http = __toESM(require("http"));

// node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// packages/php-wasm/node/src/lib/networking/utils.ts
var net = __toESM(require("net"));
function debugLog(message, ...args) {
  if (process.env["DEV"] && !process.env["TEST"]) {
    logger.log(message, ...args);
  }
}
async function findFreePorts(n) {
  const serversPromises = [];
  for (let i = 0; i < n; i++) {
    serversPromises.push(listenOnRandomPort());
  }
  const servers = await Promise.all(serversPromises);
  const ports = [];
  for (const server of servers) {
    const address = server.address();
    ports.push(address.port);
    server.close();
  }
  return ports;
}
function listenOnRandomPort() {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.listen(0, () => {
      resolve(server);
    });
  });
}

// packages/php-wasm/node/src/lib/networking/outbound-ws-to-tcp-proxy.ts
function log(...args) {
  debugLog("[WS Server]", ...args);
}
var lookup2 = util.promisify(dns.lookup);
function prependByte(chunk, byte) {
  if (typeof chunk === "string") {
    chunk = String.fromCharCode(byte) + chunk;
  } else if (chunk instanceof ArrayBuffer || "byteLength" in chunk) {
    const buffer = new Uint8Array(chunk.byteLength + 1);
    buffer[0] = byte;
    buffer.set(new Uint8Array(chunk), 1);
    chunk = buffer.buffer;
  } else {
    log({ chunk });
    throw new Error("Unsupported chunk type: " + typeof chunk);
  }
  return chunk;
}
var COMMAND_CHUNK = 1;
var COMMAND_SET_SOCKETOPT = 2;
function addSocketOptionsSupportToWebSocketClass(WebSocketConstructor) {
  return class PHPWasmWebSocketConstructor extends WebSocketConstructor {
    // @ts-ignore
    send(chunk, callback) {
      return this.sendCommand(COMMAND_CHUNK, chunk, callback);
    }
    setSocketOpt(optionClass, optionName, optionValue) {
      return this.sendCommand(
        COMMAND_SET_SOCKETOPT,
        new Uint8Array([optionClass, optionName, optionValue]).buffer,
        () => void 0
      );
    }
    sendCommand(commandType, chunk, callback) {
      return WebSocketConstructor.prototype.send.call(
        this,
        prependByte(chunk, commandType),
        callback
      );
    }
  };
}
function initOutboundWebsocketProxyServer(listenPort, listenHost = "127.0.0.1") {
  log(`Binding the WebSockets server to ${listenHost}:${listenPort}...`);
  const webServer = http.createServer((request, response) => {
    response.writeHead(403, { "Content-Type": "text/plain" });
    response.write(
      "403 Permission Denied\nOnly websockets are allowed here.\n"
    );
    response.end();
  });
  return new Promise((resolve) => {
    webServer.listen(listenPort, listenHost, function() {
      const wsServer = new import_websocket_server.default({ server: webServer });
      wsServer.on("connection", onWsConnect);
      resolve(webServer);
    });
  });
}
async function onWsConnect(client, request) {
  const clientAddr = client?._socket?.remoteAddress || client.url;
  const clientLog = function(...args) {
    log(" " + clientAddr + ": ", ...args);
  };
  clientLog(
    "WebSocket connection from : " + clientAddr + " at URL " + (request ? request.url : client.upgradeReq.url)
  );
  clientLog(
    "Version " + client.protocolVersion + ", subprotocol: " + client.protocol
  );
  const reqUrl = new URL(`ws://0.0.0.0` + request.url);
  const reqTargetPort = Number(reqUrl.searchParams.get("port"));
  const reqTargetHost = reqUrl.searchParams.get("host");
  if (!reqTargetPort || !reqTargetHost) {
    clientLog("Missing host or port information");
    client.close(3e3);
    return;
  }
  let target;
  const recvQueue = [];
  function flushMessagesQueue() {
    while (recvQueue.length > 0) {
      const msg = recvQueue.pop();
      const commandType = msg[0];
      clientLog("flushing", { commandType }, msg);
      if (commandType === COMMAND_CHUNK) {
        target.write(msg.slice(1));
      } else if (commandType === COMMAND_SET_SOCKETOPT) {
        const SOL_SOCKET = 1;
        const SO_KEEPALIVE = 9;
        const IPPROTO_TCP = 6;
        const TCP_NODELAY = 1;
        if (msg[1] === SOL_SOCKET && msg[2] === SO_KEEPALIVE) {
          target.setKeepAlive(msg[3]);
        } else if (msg[1] === IPPROTO_TCP && msg[2] === TCP_NODELAY) {
          target.setNoDelay(msg[3]);
        }
      } else {
        clientLog("Unknown command type: " + commandType);
        process.exit();
      }
    }
  }
  client.on("message", function(msg) {
    recvQueue.unshift(msg);
    if (target) {
      flushMessagesQueue();
    }
  });
  client.on("close", function(code, reason) {
    clientLog(
      "WebSocket client disconnected: " + code + " [" + reason + "]"
    );
    if (target) {
      target.end();
    }
  });
  client.on("error", function(a) {
    clientLog("WebSocket client error: " + a);
    target.end();
  });
  let reqTargetIp;
  if (net2.isIP(reqTargetHost) === 0) {
    clientLog("resolving " + reqTargetHost + "... ");
    try {
      const resolution = await lookup2(reqTargetHost);
      reqTargetIp = resolution.address;
      clientLog("resolved " + reqTargetHost + " -> " + reqTargetIp);
    } catch (e) {
      clientLog("can't resolve " + reqTargetHost + " due to:", e);
      client.send([]);
      client.close(3e3);
      return;
    }
  } else {
    reqTargetIp = reqTargetHost;
  }
  clientLog(
    "Opening a socket connection to " + reqTargetIp + ":" + reqTargetPort
  );
  target = net2.createConnection(reqTargetPort, reqTargetIp, function() {
    clientLog("Connected to target");
    flushMessagesQueue();
  });
  target.on("data", function(data) {
    try {
      client.send(data);
    } catch (e) {
      clientLog("Client closed, cleaning up target");
      target.end();
    }
  });
  target.on("end", function() {
    clientLog("target disconnected");
    client.close();
  });
  target.on("error", function(e) {
    clientLog("target connection error", e);
    target.end();
    client.close(3e3);
  });
}

// packages/php-wasm/node/src/lib/networking/inbound-tcp-to-ws-proxy.ts
var import_net = require("net");
function log2(...args) {
  debugLog("[TCP Server]", ...args);
}
function addTCPServerToWebSocketServerClass(wsListenPort, WSServer) {
  return class PHPWasmWebSocketServer extends WSServer {
    constructor(options, callback) {
      const requestedPort = options.port;
      options.port = wsListenPort;
      listenTCPToWSProxy({
        tcpListenPort: requestedPort,
        wsConnectPort: wsListenPort
      });
      super(options, callback);
    }
  };
}
function listenTCPToWSProxy(options) {
  options = {
    wsConnectHost: "127.0.0.1",
    ...options
  };
  const { tcpListenPort, wsConnectHost, wsConnectPort } = options;
  const server = (0, import_net.createServer)();
  server.on("connection", function handleConnection(tcpSource) {
    const inBuffer = [];
    const wsTarget = new import_websocket.default(
      `ws://${wsConnectHost}:${wsConnectPort}/`
    );
    wsTarget.binaryType = "arraybuffer";
    function wsSend(data) {
      wsTarget.send(new Uint8Array(data));
    }
    wsTarget.addEventListener("open", function() {
      log2("Outbound WebSocket connection established");
      while (inBuffer.length > 0) {
        wsSend(inBuffer.shift());
      }
    });
    wsTarget.addEventListener("message", (e) => {
      log2(
        "WS->TCP message:",
        new TextDecoder().decode(e.data)
      );
      tcpSource.write(Buffer.from(e.data));
    });
    wsTarget.addEventListener("close", () => {
      log2("WebSocket connection closed");
      tcpSource.end();
    });
    tcpSource.on("data", function(data) {
      log2("TCP->WS message:", data);
      if (wsTarget.readyState === import_websocket.default.OPEN) {
        while (inBuffer.length > 0) {
          wsSend(inBuffer.shift());
        }
        wsSend(data);
      } else {
        inBuffer.push(data);
      }
    });
    tcpSource.once("close", function() {
      log2("TCP connection closed");
      wsTarget.close();
    });
    tcpSource.on("error", function() {
      log2("TCP connection error");
      wsTarget.close();
    });
  });
  server.listen(tcpListenPort, function() {
    log2("TCP server listening");
  });
}

// packages/php-wasm/node/src/lib/networking/with-networking.ts
async function withNetworking(phpModuleArgs = {}) {
  const [inboundProxyWsServerPort, outboundProxyWsServerPort] = await findFreePorts(2);
  await initOutboundWebsocketProxyServer(outboundProxyWsServerPort);
  return {
    ...phpModuleArgs,
    websocket: {
      ...phpModuleArgs["websocket"] || {},
      url: (_, host, port) => {
        const query = new URLSearchParams({
          host,
          port
        }).toString();
        return `ws://127.0.0.1:${outboundProxyWsServerPort}/?${query}`;
      },
      subprotocol: "binary",
      decorator: addSocketOptionsSupportToWebSocketClass,
      serverDecorator: addTCPServerToWebSocketServerClass.bind(
        null,
        inboundProxyWsServerPort
      )
    }
  };
}

// packages/php-wasm/node/src/lib/load-runtime.ts
async function loadNodeRuntime(phpVersion, options = {}) {
  const emscriptenOptions = {
    /**
     * Emscripten default behavior is to kill the process when
     * the WASM program calls `exit()`. We want to throw an
     * exception instead.
     */
    quit: function(code, error) {
      throw error;
    },
    ...options.emscriptenOptions || {}
  };
  return await loadPHPRuntime(
    await getPHPLoaderModule(phpVersion),
    await withNetworking(emscriptenOptions)
  );
}

// packages/php-wasm/node/src/lib/use-host-filesystem.ts
var import_node_fs = require("node:fs");

// packages/php-wasm/node/src/lib/node-fs-mount.ts
function createNodeFsMountHandler(localPath) {
  return async function(php, FS, vfsMountPoint) {
    FS.mount(FS.filesystems["NODEFS"], { root: localPath }, vfsMountPoint);
    return () => {
      FS.unmount(localPath);
    };
  };
}

// packages/php-wasm/node/src/lib/use-host-filesystem.ts
function useHostFilesystem(php) {
  const dirs = (0, import_node_fs.readdirSync)("/").filter((file) => file !== "dev").map((file) => `/${file}`).filter((file) => (0, import_node_fs.lstatSync)(file).isDirectory());
  for (const dir of dirs) {
    if (!php.fileExists(dir)) {
      php.mkdirTree(dir);
    }
    php.mount(dir, createNodeFsMountHandler(dir));
  }
  php.chdir(process.cwd());
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createNodeFsMountHandler,
  getPHPLoaderModule,
  loadNodeRuntime,
  useHostFilesystem,
  withNetworking
});
