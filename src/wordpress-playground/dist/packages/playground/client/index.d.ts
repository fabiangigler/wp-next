// Generated by dts-bundle-generator v7.2.0

import * as Comlink from 'comlink';
import { Remote } from 'comlink';

declare class EmscriptenDownloadMonitor extends EventTarget {
	#private;
	expectAssets(assets: Record<string, number>): void;
	monitorFetch(fetchPromise: Promise<Response>): Promise<Response>;
}
/**
 * Options for customizing the progress tracker.
 */
export interface ProgressTrackerOptions {
	/** The weight of the progress, a number between 0 and 1. */
	weight?: number;
	/** The caption to display during progress, a string. */
	caption?: string;
	/** The time in milliseconds to fill the progress, a number. */
	fillTime?: number;
}
/**
 * Custom event providing information about a loading process.
 */
export type LoadingEvent = CustomEvent<{
	/** The number representing how much was loaded. */
	loaded: number;
	/** The number representing how much needs to loaded in total. */
	total: number;
}>;
/**
 * Custom event providing progress details.
 */
export type ProgressTrackerEvent = CustomEvent<ProgressDetails>;
export interface ProgressDetails {
	/** The progress percentage as a number between 0 and 100. */
	progress: number;
	/** The caption to display during progress, a string. */
	caption: string;
}
/**
 * ProgressObserver A function that receives progress updates.
 *
 * @param progress The progress percentage as a number between 0 and 100.
 */
export type ProgressObserver = (progress: number) => void;
/**
 * Listener A function for handling specific event types.
 *
 * @param event The event of type T.
 */
export type Listener<T> = (event: T) => void;
export type TSCompatibleListener<T> = EventListenerOrEventListenerObject | null | Listener<T>;
export interface ProgressReceiver {
	setProgress(details: ProgressDetails): any;
	setLoaded(): any;
}
declare class ProgressTracker extends EventTarget {
	private _selfWeight;
	private _selfDone;
	private _selfProgress;
	private _selfCaption;
	private _weight;
	private _progressObserver?;
	private _loadingListener?;
	private _isFilling;
	private _fillTime;
	private _fillInterval?;
	private _subTrackers;
	constructor({ weight, caption, fillTime, }?: ProgressTrackerOptions);
	/**
	 * Creates a new sub-tracker with a specific weight.
	 *
	 * The weight determines what percentage of the overall progress
	 * the sub-tracker represents. For example, if the main tracker is
	 * monitoring a process that has two stages, and the first stage
	 * is expected to take twice as long as the second stage, you could
	 * create the first sub-tracker with a weight of 0.67 and the second
	 * sub-tracker with a weight of 0.33.
	 *
	 * The caption is an optional string that describes the current stage
	 * of the operation. If provided, it will be used as the progress caption
	 * for the sub-tracker. If not provided, the main tracker will look for
	 * the next sub-tracker with a non-empty caption and use that as the progress
	 * caption instead.
	 *
	 * Returns the newly-created sub-tracker.
	 *
	 * @throws {Error} If the weight of the new stage would cause the total weight of all stages to exceed 1.
	 *
	 * @param weight The weight of the new stage, as a decimal value between 0 and 1.
	 * @param caption The caption for the new stage, which will be used as the progress caption for the sub-tracker.
	 *
	 * @example
	 * ```ts
	 * const tracker = new ProgressTracker();
	 * const subTracker1 = tracker.stage(0.67, 'Slow stage');
	 * const subTracker2 = tracker.stage(0.33, 'Fast stage');
	 *
	 * subTracker2.set(50);
	 * subTracker1.set(75);
	 * subTracker2.set(100);
	 * subTracker1.set(100);
	 * ```
	 */
	stage(weight?: number, caption?: string): ProgressTracker;
	/**
	 * Fills the progress bar slowly over time, simulating progress.
	 *
	 * The progress bar is filled in a 100 steps, and each step, the progress
	 * is increased by 1. If `stopBeforeFinishing` is true, the progress bar
	 * will stop filling when it reaches 99% so that you can call `finish()`
	 * explicitly.
	 *
	 * If the progress bar is filling or already filled, this method does nothing.
	 *
	 * @example
	 * ```ts
	 * const progress = new ProgressTracker({ caption: 'Processing...' });
	 * progress.fillSlowly();
	 * ```
	 *
	 * @param options Optional options.
	 */
	fillSlowly({ stopBeforeFinishing }?: {
		stopBeforeFinishing?: boolean | undefined;
	}): void;
	set(value: number): void;
	finish(): void;
	get caption(): string;
	setCaption(caption: string): void;
	get done(): boolean;
	get progress(): number;
	get weight(): number;
	get observer(): ProgressObserver;
	get loadingListener(): Listener<LoadingEvent>;
	pipe(receiver: ProgressReceiver): void;
	addEventListener(type: string, listener: TSCompatibleListener<ProgressTrackerEvent>): void;
	removeEventListener(type: string, listener: TSCompatibleListener<ProgressTrackerEvent>): void;
	private notifyProgress;
	private notifyDone;
}
export interface PHPResponseData {
	/**
	 * Response headers.
	 */
	readonly headers: Record<string, string[]>;
	/**
	 * Response body. Contains the output from `echo`,
	 * `print`, inline HTML etc.
	 */
	readonly bytes: ArrayBuffer;
	/**
	 * Stderr contents, if any.
	 */
	readonly errors: string;
	/**
	 * The exit code of the script. `0` is a success, while
	 * `1` and `2` indicate an error.
	 */
	readonly exitCode: number;
	/**
	 * Response HTTP status code, e.g. 200.
	 */
	readonly httpStatusCode: number;
}
/**
 * PHP response. Body is an `ArrayBuffer` because it can
 * contain binary data.
 *
 * This type is used in Comlink.transferHandlers.set('PHPResponse', \{ ... \})
 * so be sure to update that if you change this type.
 */
export declare class PHPResponse implements PHPResponseData {
	/** @inheritDoc */
	readonly headers: Record<string, string[]>;
	/** @inheritDoc */
	readonly bytes: ArrayBuffer;
	/** @inheritDoc */
	readonly errors: string;
	/** @inheritDoc */
	readonly exitCode: number;
	/** @inheritDoc */
	readonly httpStatusCode: number;
	constructor(httpStatusCode: number, headers: Record<string, string[]>, body: ArrayBuffer, errors?: string, exitCode?: number);
	static forHttpCode(httpStatusCode: number, text?: string): PHPResponse;
	static fromRawData(data: PHPResponseData): PHPResponse;
	toRawData(): PHPResponseData;
	/**
	 * Response body as JSON.
	 */
	get json(): any;
	/**
	 * Response body as text.
	 */
	get text(): string;
}
export type RuntimeType = "NODE" | "WEB" | "WORKER";
export type PHPRuntimeId = number;
/** Other WebAssembly declarations, for compatibility with older versions of Typescript */
export declare namespace Emscripten {
	export interface RootFS extends Emscripten.FileSystemInstance {
		filesystems: Record<string, Emscripten.FileSystemType>;
	}
	export interface FileSystemType {
		mount(mount: FS.Mount): FS.FSNode;
		syncfs(mount: FS.Mount, populate: () => unknown, done: (err?: number | null) => unknown): void;
	}
	export type EnvironmentType = "WEB" | "NODE" | "SHELL" | "WORKER";
	export type JSType = "number" | "string" | "array" | "boolean";
	export type TypeCompatibleWithC = number | string | any[] | boolean;
	export type CIntType = "i8" | "i16" | "i32" | "i64";
	export type CFloatType = "float" | "double";
	export type CPointerType = "i8*" | "i16*" | "i32*" | "i64*" | "float*" | "double*" | "*";
	export type CType = CIntType | CFloatType | CPointerType;
	export interface CCallOpts {
		async?: boolean | undefined;
	}
	type NamespaceToInstance<T> = {
		[K in keyof T]: T[K] extends (...args: any[]) => any ? T[K] : never;
	};
	export type FileSystemInstance = NamespaceToInstance<typeof FS> & {
		mkdirTree(path: string): void;
		lookupPath(path: string, opts?: any): FS.Lookup;
	};
	export interface EmscriptenModule {
		print(str: string): void;
		printErr(str: string): void;
		arguments: string[];
		environment: Emscripten.EnvironmentType;
		preInit: Array<{
			(): void;
		}>;
		preRun: Array<{
			(): void;
		}>;
		postRun: Array<{
			(): void;
		}>;
		onAbort: {
			(what: any): void;
		};
		onRuntimeInitialized: {
			(): void;
		};
		preinitializedWebGLContext: WebGLRenderingContext;
		noInitialRun: boolean;
		noExitRuntime: boolean;
		logReadFiles: boolean;
		filePackagePrefixURL: string;
		wasmBinary: ArrayBuffer;
		destroy(object: object): void;
		getPreloadedPackage(remotePackageName: string, remotePackageSize: number): ArrayBuffer;
		instantiateWasm(imports: WebAssembly.Imports, successCallback: (module: WebAssembly.Instance) => void): WebAssembly.Exports | undefined;
		locateFile(url: string, scriptDirectory: string): string;
		onCustomMessage(event: MessageEvent): void;
		HEAP: Int32Array;
		IHEAP: Int32Array;
		FHEAP: Float64Array;
		HEAP8: Int8Array;
		HEAP16: Int16Array;
		HEAP32: Int32Array;
		HEAPU8: Uint8Array;
		HEAPU16: Uint16Array;
		HEAPU32: Uint32Array;
		HEAPF32: Float32Array;
		HEAPF64: Float64Array;
		HEAP64: BigInt64Array;
		HEAPU64: BigUint64Array;
		TOTAL_STACK: number;
		TOTAL_MEMORY: number;
		FAST_MEMORY: number;
		addOnPreRun(cb: () => any): void;
		addOnInit(cb: () => any): void;
		addOnPreMain(cb: () => any): void;
		addOnExit(cb: () => any): void;
		addOnPostRun(cb: () => any): void;
		preloadedImages: any;
		preloadedAudios: any;
		_malloc(size: number): number;
		_free(ptr: number): void;
	}
	/**
	 * A factory function is generated when setting the `MODULARIZE` build option
	 * to `1` in your Emscripten build. It return a Promise that resolves to an
	 * initialized, ready-to-call `EmscriptenModule` instance.
	 *
	 * By default, the factory function will be named `Module`. It's recommended to
	 * use the `EXPORT_ES6` option, in which the factory function will be the
	 * default export. If used without `EXPORT_ES6`, the factory function will be a
	 * global variable. You can rename the variable using the `EXPORT_NAME` build
	 * option. It's left to you to export any global variables as needed in your
	 * application's types.
	 * @param moduleOverrides Default properties for the initialized module.
	 */
	export type EmscriptenModuleFactory<T extends EmscriptenModule = EmscriptenModule> = (moduleOverrides?: Partial<T>) => Promise<T>;
	export namespace FS {
		interface Lookup {
			path: string;
			node: FSNode;
		}
		interface Analyze {
			isRoot: boolean;
			exists: boolean;
			error: Error;
			name: string;
			path: Lookup["path"];
			object: Lookup["node"];
			parentExists: boolean;
			parentPath: Lookup["path"];
			parentObject: Lookup["node"];
		}
		interface Mount {
			type: Emscripten.FileSystemType;
			opts: object;
			mountpoint: string;
			mounts: Mount[];
			root: FSNode;
		}
		class FSStream {
			constructor();
			object: FSNode;
			readonly isRead: boolean;
			readonly isWrite: boolean;
			readonly isAppend: boolean;
			flags: number;
			position: number;
		}
		class FSNode {
			parent: FSNode;
			mount: Mount;
			mounted?: Mount;
			id: number;
			name: string;
			mode: number;
			rdev: number;
			readMode: number;
			writeMode: number;
			constructor(parent: FSNode, name: string, mode: number, rdev: number);
			read: boolean;
			write: boolean;
			readonly isFolder: boolean;
			readonly isDevice: boolean;
		}
		interface ErrnoError extends Error {
			name: "ErronoError";
			errno: number;
			code: string;
		}
		function lookupPath(path: string, opts: any): Lookup;
		function getPath(node: FSNode): string;
		function analyzePath(path: string, dontResolveLastLink?: boolean): Analyze;
		function isFile(mode: number): boolean;
		function isDir(mode: number): boolean;
		function isLink(mode: number): boolean;
		function isChrdev(mode: number): boolean;
		function isBlkdev(mode: number): boolean;
		function isFIFO(mode: number): boolean;
		function isSocket(mode: number): boolean;
		function major(dev: number): number;
		function minor(dev: number): number;
		function makedev(ma: number, mi: number): number;
		function registerDevice(dev: number, ops: any): void;
		function syncfs(populate: boolean, callback: (e: any) => any): void;
		function syncfs(callback: (e: any) => any, populate?: boolean): void;
		function mount(type: Emscripten.FileSystemType, opts: any, mountpoint: string): any;
		function unmount(mountpoint: string): void;
		function mkdir(path: string, mode?: number): any;
		function mkdev(path: string, mode?: number, dev?: number): any;
		function symlink(oldpath: string, newpath: string): any;
		function rename(old_path: string, new_path: string): void;
		function rmdir(path: string): void;
		function readdir(path: string): any;
		function unlink(path: string): void;
		function readlink(path: string): string;
		function stat(path: string, dontFollow?: boolean): any;
		function lstat(path: string): any;
		function chmod(path: string, mode: number, dontFollow?: boolean): void;
		function lchmod(path: string, mode: number): void;
		function fchmod(fd: number, mode: number): void;
		function chown(path: string, uid: number, gid: number, dontFollow?: boolean): void;
		function lchown(path: string, uid: number, gid: number): void;
		function fchown(fd: number, uid: number, gid: number): void;
		function truncate(path: string, len: number): void;
		function ftruncate(fd: number, len: number): void;
		function utime(path: string, atime: number, mtime: number): void;
		function open(path: string, flags: string, mode?: number, fd_start?: number, fd_end?: number): FSStream;
		function close(stream: FSStream): void;
		function llseek(stream: FSStream, offset: number, whence: number): any;
		function read(stream: FSStream, buffer: ArrayBufferView, offset: number, length: number, position?: number): number;
		function write(stream: FSStream, buffer: ArrayBufferView, offset: number, length: number, position?: number, canOwn?: boolean): number;
		function allocate(stream: FSStream, offset: number, length: number): void;
		function mmap(stream: FSStream, buffer: ArrayBufferView, offset: number, length: number, position: number, prot: number, flags: number): any;
		function ioctl(stream: FSStream, cmd: any, arg: any): any;
		function readFile(path: string, opts: {
			encoding: "binary";
			flags?: string | undefined;
		}): Uint8Array;
		function readFile(path: string, opts: {
			encoding: "utf8";
			flags?: string | undefined;
		}): string;
		function readFile(path: string, opts?: {
			flags?: string | undefined;
		}): Uint8Array;
		function writeFile(path: string, data: string | ArrayBufferView, opts?: {
			flags?: string | undefined;
		}): void;
		function cwd(): string;
		function chdir(path: string): void;
		function init(input: null | (() => number | null), output: null | ((c: number) => any), error: null | ((c: number) => any)): void;
		function createLazyFile(parent: string | FSNode, name: string, url: string, canRead: boolean, canWrite: boolean): FSNode;
		function createPreloadedFile(parent: string | FSNode, name: string, url: string, canRead: boolean, canWrite: boolean, onload?: () => void, onerror?: () => void, dontCreateFile?: boolean, canOwn?: boolean): void;
		function createDataFile(parent: string | FSNode, name: string, data: ArrayBufferView, canRead: boolean, canWrite: boolean, canOwn: boolean): FSNode;
	}
	export const MEMFS: Emscripten.FileSystemType;
	export const NODEFS: Emscripten.FileSystemType;
	export const IDBFS: Emscripten.FileSystemType;
	type StringToType<R> = R extends Emscripten.JSType ? {
		number: number;
		string: string;
		array: number[] | string[] | boolean[] | Uint8Array | Int8Array;
		boolean: boolean;
		null: null;
	}[R] : never;
	type ArgsToType<T extends Array<Emscripten.JSType | null>> = Extract<{
		[P in keyof T]: StringToType<T[P]>;
	}, any[]>;
	type ReturnToType<R extends Emscripten.JSType | null> = R extends null ? null : StringToType<Exclude<R, null>>;
	export function cwrap<I extends Array<Emscripten.JSType | null> | [
	], R extends Emscripten.JSType | null>(ident: string, returnType: R, argTypes: I, opts?: Emscripten.CCallOpts): (...arg: ArgsToType<I>) => ReturnToType<R>;
	export function ccall<I extends Array<Emscripten.JSType | null> | [
	], R extends Emscripten.JSType | null>(ident: string, returnType: R, argTypes: I, args: ArgsToType<I>, opts?: Emscripten.CCallOpts): ReturnToType<R>;
	export function setValue(ptr: number, value: any, type: Emscripten.CType, noSafe?: boolean): void;
	export function getValue(ptr: number, type: Emscripten.CType, noSafe?: boolean): number;
	export function allocate(slab: number[] | ArrayBufferView | number, types: Emscripten.CType | Emscripten.CType[], allocator: number, ptr?: number): number;
	export function stackAlloc(size: number): number;
	export function stackSave(): number;
	export function stackRestore(ptr: number): void;
	export function UTF8ToString(ptr: number, maxBytesToRead?: number): string;
	export function stringToUTF8(str: string, outPtr: number, maxBytesToRead?: number): void;
	export function lengthBytesUTF8(str: string): number;
	export function allocateUTF8(str: string): number;
	export function allocateUTF8OnStack(str: string): number;
	export function UTF16ToString(ptr: number): string;
	export function stringToUTF16(str: string, outPtr: number, maxBytesToRead?: number): void;
	export function lengthBytesUTF16(str: string): number;
	export function UTF32ToString(ptr: number): string;
	export function stringToUTF32(str: string, outPtr: number, maxBytesToRead?: number): void;
	export function lengthBytesUTF32(str: string): number;
	export function intArrayFromString(stringy: string, dontAddNull?: boolean, length?: number): number[];
	export function intArrayToString(array: number[]): string;
	export function writeStringToMemory(str: string, buffer: number, dontAddNull: boolean): void;
	export function writeArrayToMemory(array: number[], buffer: number): void;
	export function writeAsciiToMemory(str: string, buffer: number, dontAddNull: boolean): void;
	export function addRunDependency(id: any): void;
	export function removeRunDependency(id: any): void;
	export function addFunction(func: (...args: any[]) => any, signature?: string): number;
	export function removeFunction(funcPtr: number): void;
	export const ALLOC_NORMAL: number;
	export const ALLOC_STACK: number;
	export const ALLOC_STATIC: number;
	export const ALLOC_DYNAMIC: number;
	export const ALLOC_NONE: number;
	export {};
}
export interface RmDirOptions {
	/**
	 * If true, recursively removes the directory and all its contents.
	 * Default: true.
	 */
	recursive?: boolean;
}
export interface ListFilesOptions {
	/**
	 * If true, prepend given folder path to all file names.
	 * Default: false.
	 */
	prependPath: boolean;
}
export interface SemaphoreOptions {
	/**
	 * The maximum number of concurrent locks.
	 */
	concurrency: number;
	/**
	 * The maximum time to wait for a lock to become available.
	 */
	timeout?: number;
}
declare class Semaphore {
	private _running;
	private concurrency;
	private timeout?;
	private queue;
	constructor({ concurrency, timeout }: SemaphoreOptions);
	get remaining(): number;
	get running(): number;
	acquire(): Promise<() => void>;
	run<T>(fn: () => T | Promise<T>): Promise<T>;
}
export declare function phpVar(value: unknown): string;
export declare function phpVars<T extends Record<string, unknown>>(vars: T): Record<keyof T, string>;
export type PHPFactoryOptions = {
	isPrimary: boolean;
};
export type PHPFactory = (options: PHPFactoryOptions) => Promise<PHP>;
export interface ProcessManagerOptions {
	/**
	 * The maximum number of PHP instances that can exist at
	 * the same time.
	 */
	maxPhpInstances?: number;
	/**
	 * The number of milliseconds to wait for a PHP instance when
	 * we have reached the maximum number of PHP instances and
	 * cannot spawn a new one. If the timeout is reached, we assume
	 * all the PHP instances are deadlocked and a throw MaxPhpInstancesError.
	 *
	 * Default: 5000
	 */
	timeout?: number;
	/**
	 * The primary PHP instance that's never killed. This instance
	 * contains the reference filesystem used by all other PHP instances.
	 */
	primaryPhp?: PHP;
	/**
	 * A factory function used for spawning new PHP instances.
	 */
	phpFactory?: PHPFactory;
}
export interface SpawnedPHP {
	php: PHP;
	reap: () => void;
}
declare class PHPProcessManager implements AsyncDisposable {
	private primaryPhp?;
	private primaryIdle;
	private nextInstance;
	/**
	 * All spawned PHP instances, including the primary PHP instance.
	 * Used for bookkeeping and reaping all instances on dispose.
	 */
	private allInstances;
	private phpFactory?;
	private maxPhpInstances;
	private semaphore;
	constructor(options?: ProcessManagerOptions);
	/**
	 * Get the primary PHP instance.
	 *
	 * If the primary PHP instance is not set, it will be spawned
	 * using the provided phpFactory.
	 *
	 * @throws {Error} when called twice before the first call is resolved.
	 */
	getPrimaryPhp(): Promise<PHP>;
	/**
	 * Get a PHP instance.
	 *
	 * It could be either the primary PHP instance, an idle disposable PHP instance,
	 * or a newly spawned PHP instance – depending on the resource availability.
	 *
	 * @throws {MaxPhpInstancesError} when the maximum number of PHP instances is reached
	 *                                and the waiting timeout is exceeded.
	 */
	acquirePHPInstance(): Promise<SpawnedPHP>;
	/**
	 * Initiated spawning of a new PHP instance.
	 * This function is synchronous on purpose – it needs to synchronously
	 * add the spawn promise to the allInstances array without waiting
	 * for PHP to spawn.
	 */
	private spawn;
	/**
	 * Actually acquires the lock and spawns a new PHP instance.
	 */
	private doSpawn;
	[Symbol.asyncDispose](): Promise<void>;
}
export type RewriteRule = {
	match: RegExp;
	replacement: string;
};
export interface BaseConfiguration {
	/**
	 * The directory in the PHP filesystem where the server will look
	 * for the files to serve. Default: `/var/www`.
	 */
	documentRoot?: string;
	/**
	 * Request Handler URL. Used to populate $_SERVER details like HTTP_HOST.
	 */
	absoluteUrl?: string;
	/**
	 * Rewrite rules
	 */
	rewriteRules?: RewriteRule[];
}
export type PHPRequestHandlerFactoryArgs = PHPFactoryOptions & {
	requestHandler: PHPRequestHandler;
};
export type PHPRequestHandlerConfiguration = BaseConfiguration & ({
	/**
	 * PHPProcessManager is required because the request handler needs
	 * to make a decision for each request.
	 *
	 * Static assets are served using the primary PHP's filesystem, even
	 * when serving 100 static files concurrently. No new PHP interpreter
	 * is ever created as there's no need for it.
	 *
	 * Dynamic PHP requests, however, require grabbing an available PHP
	 * interpreter, and that's where the PHPProcessManager comes in.
	 */
	processManager: PHPProcessManager;
} | {
	phpFactory: (requestHandler: PHPRequestHandlerFactoryArgs) => Promise<PHP>;
	/**
	 * The maximum number of PHP instances that can exist at
	 * the same time.
	 */
	maxPhpInstances?: number;
});
/**
 * Handles HTTP requests using PHP runtime as a backend.
 *
 * @public
 * @example Use PHPRequestHandler implicitly with a new PHP instance:
 * ```js
 * import { PHP } from '@php-wasm/web';
 *
 * const php = await PHP.load( '7.4', {
 *     requestHandler: {
 *         // PHP FS path to serve the files from:
 *         documentRoot: '/www',
 *
 *         // Used to populate $_SERVER['SERVER_NAME'] etc.:
 *         absoluteUrl: 'http://127.0.0.1'
 *     }
 * } );
 *
 * php.mkdirTree('/www');
 * php.writeFile('/www/index.php', '<?php echo "Hi from PHP!"; ');
 *
 * const response = await php.request({ path: '/index.php' });
 * console.log(response.text);
 * // "Hi from PHP!"
 * ```
 *
 * @example Explicitly create a PHPRequestHandler instance and run a PHP script:
 * ```js
 * import {
 *   loadPHPRuntime,
 *   PHP,
 *   PHPRequestHandler,
 *   getPHPLoaderModule,
 * } from '@php-wasm/web';
 *
 * const runtime = await loadPHPRuntime( await getPHPLoaderModule('7.4') );
 * const php = new PHP( runtime );
 *
 * php.mkdirTree('/www');
 * php.writeFile('/www/index.php', '<?php echo "Hi from PHP!"; ');
 *
 * const server = new PHPRequestHandler(php, {
 *     // PHP FS path to serve the files from:
 *     documentRoot: '/www',
 *
 *     // Used to populate $_SERVER['SERVER_NAME'] etc.:
 *     absoluteUrl: 'http://127.0.0.1'
 * });
 *
 * const response = server.request({ path: '/index.php' });
 * console.log(response.text);
 * // "Hi from PHP!"
 * ```
 */
export declare class PHPRequestHandler {
	#private;
	rewriteRules: RewriteRule[];
	processManager: PHPProcessManager;
	/**
	 * The request handler needs to decide whether to serve a static asset or
	 * run the PHP interpreter. For static assets it should just reuse the primary
	 * PHP even if there's 50 concurrent requests to serve. However, for
	 * dynamic PHP requests, it needs to grab an available interpreter.
	 * Therefore, it cannot just accept PHP as an argument as serving requests
	 * requires access to ProcessManager.
	 *
	 * @param  php    - The PHP instance.
	 * @param  config - Request Handler configuration.
	 */
	constructor(config: PHPRequestHandlerConfiguration);
	getPrimaryPhp(): Promise<PHP>;
	/**
	 * Converts a path to an absolute URL based at the PHPRequestHandler
	 * root.
	 *
	 * @param  path The server path to convert to an absolute URL.
	 * @returns The absolute URL.
	 */
	pathToInternalUrl(path: string): string;
	/**
	 * Converts an absolute URL based at the PHPRequestHandler to a relative path
	 * without the server pathname and scope.
	 *
	 * @param  internalUrl An absolute URL based at the PHPRequestHandler root.
	 * @returns The relative path.
	 */
	internalUrlToPath(internalUrl: string): string;
	/**
	 * The absolute URL of this PHPRequestHandler instance.
	 */
	get absoluteUrl(): string;
	/**
	 * The directory in the PHP filesystem where the server will look
	 * for the files to serve. Default: `/var/www`.
	 */
	get documentRoot(): string;
	/**
	 * Serves the request – either by serving a static file, or by
	 * dispatching it to the PHP runtime.
	 *
	 * The request() method mode behaves like a web server and only works if
	 * the PHP was initialized with a `requestHandler` option (which the online version
	 * of WordPress Playground does by default).
	 *
	 * In the request mode, you pass an object containing the request information
	 * (method, headers, body, etc.) and the path to the PHP file to run:
	 *
	 * ```ts
	 * const php = PHP.load('7.4', {
	 * 	requestHandler: {
	 * 		documentRoot: "/www"
	 * 	}
	 * })
	 * php.writeFile("/www/index.php", `<?php echo file_get_contents("php://input");`);
	 * const result = await php.request({
	 * 	method: "GET",
	 * 	headers: {
	 * 		"Content-Type": "text/plain"
	 * 	},
	 * 	body: "Hello world!",
	 * 	path: "/www/index.php"
	 * });
	 * // result.text === "Hello world!"
	 * ```
	 *
	 * The `request()` method cannot be used in conjunction with `cli()`.
	 *
	 * @example
	 * ```js
	 * const output = await php.request({
	 * 	method: 'GET',
	 * 	url: '/index.php',
	 * 	headers: {
	 * 		'X-foo': 'bar',
	 * 	},
	 * 	body: {
	 * 		foo: 'bar',
	 * 	},
	 * });
	 * console.log(output.stdout); // "Hello world!"
	 * ```
	 *
	 * @param  request - PHP Request data.
	 */
	request(request: PHPRequest): Promise<PHPResponse>;
}
declare const __private__dont__use: unique symbol;
export type UnmountFunction = (() => Promise<any>) | (() => any);
export type MountHandler = (php: PHP, FS: Emscripten.RootFS, vfsMountPoint: string) => UnmountFunction | Promise<UnmountFunction>;
declare class PHP implements Disposable {
	#private;
	protected [__private__dont__use]: any;
	requestHandler?: PHPRequestHandler;
	/**
	 * An exclusive lock that prevent multiple requests from running at
	 * the same time.
	 */
	semaphore: Semaphore;
	/**
	 * Initializes a PHP runtime.
	 *
	 * @internal
	 * @param  PHPRuntime - Optional. PHP Runtime ID as initialized by loadPHPRuntime.
	 * @param  requestHandlerOptions - Optional. Options for the PHPRequestHandler. If undefined, no request handler will be initialized.
	 */
	constructor(PHPRuntimeId?: PHPRuntimeId);
	/**
	 * Adds an event listener for a PHP event.
	 * @param eventType - The type of event to listen for.
	 * @param listener - The listener function to be called when the event is triggered.
	 */
	addEventListener(eventType: PHPEvent["type"], listener: PHPEventListener): void;
	/**
	 * Removes an event listener for a PHP event.
	 * @param eventType - The type of event to remove the listener from.
	 * @param listener - The listener function to be removed.
	 */
	removeEventListener(eventType: PHPEvent["type"], listener: PHPEventListener): void;
	dispatchEvent<Event extends PHPEvent>(event: Event): void;
	/**
	 * Listens to message sent by the PHP code.
	 *
	 * To dispatch messages, call:
	 *
	 *     post_message_to_js(string $data)
	 *
	 *     Arguments:
	 *         $data (string) – Data to pass to JavaScript.
	 *
	 * @example
	 *
	 * ```ts
	 * const php = await PHP.load('8.0');
	 *
	 * php.onMessage(
	 *     // The data is always passed as a string
	 *     function (data: string) {
	 *         // Let's decode and log the data:
	 *         console.log(JSON.parse(data));
	 *     }
	 * );
	 *
	 * // Now that we have a listener in place, let's
	 * // dispatch a message:
	 * await php.run({
	 *     code: `<?php
	 *         post_message_to_js(
	 *             json_encode([
	 *                 'post_id' => '15',
	 *                 'post_title' => 'This is a blog post!'
	 *             ])
	 *         ));
	 *     `,
	 * });
	 * ```
	 *
	 * @param listener Callback function to handle the message.
	 */
	onMessage(listener: MessageListener): void;
	setSpawnHandler(handler: SpawnHandler | string): Promise<void>;
	/** @deprecated Use PHPRequestHandler instead. */
	get absoluteUrl(): string;
	/** @deprecated Use PHPRequestHandler instead. */
	get documentRoot(): string;
	/** @deprecated Use PHPRequestHandler instead. */
	pathToInternalUrl(path: string): string;
	/** @deprecated Use PHPRequestHandler instead. */
	internalUrlToPath(internalUrl: string): string;
	initializeRuntime(runtimeId: PHPRuntimeId): void;
	/** @inheritDoc */
	setSapiName(newName: string): Promise<void>;
	/**
	 * Changes the current working directory in the PHP filesystem.
	 * This is the directory that will be used as the base for relative paths.
	 * For example, if the current working directory is `/root/php`, and the
	 * path is `data`, the absolute path will be `/root/php/data`.
	 *
	 * @param  path - The new working directory.
	 */
	chdir(path: string): void;
	/**
	 * Do not use. Use new PHPRequestHandler() instead.
	 * @deprecated
	 */
	request(request: PHPRequest): Promise<PHPResponse>;
	/**
	 * Runs PHP code.
	 *
	 * This low-level method directly interacts with the WebAssembly
	 * PHP interpreter.
	 *
	 * Every time you call run(), it prepares the PHP
	 * environment and:
	 *
	 * * Resets the internal PHP state
	 * * Populates superglobals ($_SERVER, $_GET, etc.)
	 * * Handles file uploads
	 * * Populates input streams (stdin, argv, etc.)
	 * * Sets the current working directory
	 *
	 * You can use run() in two primary modes:
	 *
	 * ### Code snippet mode
	 *
	 * In this mode, you pass a string containing PHP code to run.
	 *
	 * ```ts
	 * const result = await php.run({
	 * 	code: `<?php echo "Hello world!";`
	 * });
	 * // result.text === "Hello world!"
	 * ```
	 *
	 * In this mode, information like __DIR__ or __FILE__ isn't very
	 * useful because the code is not associated with any file.
	 *
	 * Under the hood, the PHP snippet is passed to the `zend_eval_string`
	 * C function.
	 *
	 * ### File mode
	 *
	 * In the file mode, you pass a scriptPath and PHP executes a file
	 * found at a that path:
	 *
	 * ```ts
	 * php.writeFile(
	 * 	"/www/index.php",
	 * 	`<?php echo "Hello world!";"`
	 * );
	 * const result = await php.run({
	 * 	scriptPath: "/www/index.php"
	 * });
	 * // result.text === "Hello world!"
	 * ```
	 *
	 * In this mode, you can rely on path-related information like __DIR__
	 * or __FILE__.
	 *
	 * Under the hood, the PHP file is executed with the `php_execute_script`
	 * C function.
	 *
	 * The `run()` method cannot be used in conjunction with `cli()`.
	 *
	 * @example
	 * ```js
	 * const result = await php.run(`<?php
	 *  $fp = fopen('php://stderr', 'w');
	 *  fwrite($fp, "Hello, world!");
	 * `);
	 * // result.errors === "Hello, world!"
	 * ```
	 *
	 * @param  options - PHP runtime options.
	 */
	run(request: PHPRunOptions): Promise<PHPResponse>;
	/**
	 * Defines a constant in the PHP runtime.
	 * @param key - The name of the constant.
	 * @param value - The value of the constant.
	 */
	defineConstant(key: string, value: string | boolean | number | null): void;
	/**
	 * Recursively creates a directory with the given path in the PHP filesystem.
	 * For example, if the path is `/root/php/data`, and `/root` already exists,
	 * it will create the directories `/root/php` and `/root/php/data`.
	 *
	 * @param  path - The directory path to create.
	 */
	mkdir(path: string): void;
	/**
	 * @deprecated Use mkdir instead.
	 */
	mkdirTree(path: string): void;
	/**
	 * Reads a file from the PHP filesystem and returns it as a string.
	 *
	 * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsText(path: string): string;
	/**
	 * Reads a file from the PHP filesystem and returns it as an array buffer.
	 *
	 * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsBuffer(path: string): Uint8Array;
	/**
	 * Overwrites data in a file in the PHP filesystem.
	 * Creates a new file if one doesn't exist yet.
	 *
	 * @param  path - The file path to write to.
	 * @param  data - The data to write to the file.
	 */
	writeFile(path: string, data: string | Uint8Array): void;
	/**
	 * Removes a file from the PHP filesystem.
	 *
	 * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to remove.
	 */
	unlink(path: string): void;
	/**
	 * Moves a file or directory in the PHP filesystem to a
	 * new location.
	 *
	 * @param oldPath The path to rename.
	 * @param newPath The new path.
	 */
	mv(fromPath: string, toPath: string): void;
	/**
	 * Removes a directory from the PHP filesystem.
	 *
	 * @param path The directory path to remove.
	 * @param options Options for the removal.
	 */
	rmdir(path: string, options?: RmDirOptions): void;
	/**
	 * Lists the files and directories in the given directory.
	 *
	 * @param  path - The directory path to list.
	 * @param  options - Options for the listing.
	 * @returns The list of files and directories in the given directory.
	 */
	listFiles(path: string, options?: ListFilesOptions): string[];
	/**
	 * Checks if a directory exists in the PHP filesystem.
	 *
	 * @param  path – The path to check.
	 * @returns True if the path is a directory, false otherwise.
	 */
	isDir(path: string): boolean;
	/**
	 * Checks if a file (or a directory) exists in the PHP filesystem.
	 *
	 * @param  path - The file path to check.
	 * @returns True if the file exists, false otherwise.
	 */
	fileExists(path: string): boolean;
	/**
	 * Hot-swaps the PHP runtime for a new one without
	 * interrupting the operations of this PHP instance.
	 *
	 * @param runtime
	 * @param cwd. Internal, the VFS path to recreate in the new runtime.
	 *             This arg is temporary and will be removed once BasePHP
	 *             is fully decoupled from the request handler and
	 *             accepts a constructor-level cwd argument.
	 */
	hotSwapPHPRuntime(runtime: number, cwd?: string): void;
	/**
	 * Mounts a filesystem to a given path in the PHP filesystem.
	 *
	 * @param  virtualFSPath - Where to mount it in the PHP virtual filesystem.
	 * @param  mountHandler - The mount handler to use.
	 * @return Unmount function to unmount the filesystem.
	 */
	mount(virtualFSPath: string, mountHandler: MountHandler): Promise<UnmountFunction>;
	/**
	 * Starts a PHP CLI session with given arguments.
	 *
	 * This method can only be used when PHP was compiled with the CLI SAPI
	 * and it cannot be used in conjunction with `run()`.
	 *
	 * Once this method finishes running, the PHP instance is no
	 * longer usable and should be discarded. This is because PHP
	 * internally cleans up all the resources and calls exit().
	 *
	 * @param  argv - The arguments to pass to the CLI.
	 * @returns The exit code of the CLI session.
	 */
	cli(argv: string[]): Promise<number>;
	setSkipShebang(shouldSkip: boolean): void;
	exit(code?: number): void;
	[Symbol.dispose](): void;
}
export type LimitedPHPApi = Pick<PHP, "request" | "defineConstant" | "addEventListener" | "removeEventListener" | "mkdir" | "mkdirTree" | "readFileAsText" | "readFileAsBuffer" | "writeFile" | "unlink" | "mv" | "rmdir" | "listFiles" | "isDir" | "fileExists" | "chdir" | "run" | "onMessage"> & {
	documentRoot: PHP["documentRoot"];
	absoluteUrl: PHP["absoluteUrl"];
};
declare class PHPWorker implements LimitedPHPApi {
	/** @inheritDoc @php-wasm/universal!RequestHandler.absoluteUrl  */
	absoluteUrl: string;
	/** @inheritDoc @php-wasm/universal!RequestHandler.documentRoot  */
	documentRoot: string;
	/** @inheritDoc */
	constructor(requestHandler?: PHPRequestHandler, monitor?: EmscriptenDownloadMonitor);
	__internal_setRequestHandler(requestHandler: PHPRequestHandler): void;
	/**
	 * @internal
	 * @deprecated
	 * Do not use this method directly in the code consuming
	 * the web API. It will change or even be removed without
	 * a warning.
	 */
	protected __internal_getPHP(): PHP | undefined;
	setPrimaryPHP(php: PHP): Promise<void>;
	/** @inheritDoc @php-wasm/universal!PHPRequestHandler.pathToInternalUrl  */
	pathToInternalUrl(path: string): string;
	/** @inheritDoc @php-wasm/universal!PHPRequestHandler.internalUrlToPath  */
	internalUrlToPath(internalUrl: string): string;
	/**
	 * The onDownloadProgress event listener.
	 */
	onDownloadProgress(callback: (progress: CustomEvent<ProgressEvent>) => void): Promise<void>;
	/** @inheritDoc @php-wasm/universal!PHP.mv  */
	mv(fromPath: string, toPath: string): Promise<void>;
	/** @inheritDoc @php-wasm/universal!PHP.rmdir  */
	rmdir(path: string, options?: RmDirOptions): Promise<void>;
	/** @inheritDoc @php-wasm/universal!PHPRequestHandler.request */
	request(request: PHPRequest): Promise<PHPResponse>;
	/** @inheritDoc @php-wasm/universal!/PHP.run */
	run(request: PHPRunOptions): Promise<PHPResponse>;
	/** @inheritDoc @php-wasm/universal!/PHP.chdir */
	chdir(path: string): void;
	/** @inheritDoc @php-wasm/universal!/PHP.setSapiName */
	setSapiName(newName: string): void;
	/** @inheritDoc @php-wasm/universal!/PHP.mkdir */
	mkdir(path: string): void;
	/** @inheritDoc @php-wasm/universal!/PHP.mkdirTree */
	mkdirTree(path: string): void;
	/** @inheritDoc @php-wasm/universal!/PHP.readFileAsText */
	readFileAsText(path: string): string;
	/** @inheritDoc @php-wasm/universal!/PHP.readFileAsBuffer */
	readFileAsBuffer(path: string): Uint8Array;
	/** @inheritDoc @php-wasm/universal!/PHP.writeFile */
	writeFile(path: string, data: string | Uint8Array): void;
	/** @inheritDoc @php-wasm/universal!/PHP.unlink */
	unlink(path: string): void;
	/** @inheritDoc @php-wasm/universal!/PHP.listFiles */
	listFiles(path: string, options?: ListFilesOptions): string[];
	/** @inheritDoc @php-wasm/universal!/PHP.isDir */
	isDir(path: string): boolean;
	/** @inheritDoc @php-wasm/universal!/PHP.fileExists */
	fileExists(path: string): boolean;
	/** @inheritDoc @php-wasm/universal!/PHP.onMessage */
	onMessage(listener: MessageListener): void;
	/** @inheritDoc @php-wasm/universal!/PHP.defineConstant */
	defineConstant(key: string, value: string | boolean | number | null): void;
	/** @inheritDoc @php-wasm/universal!/PHP.addEventListener */
	addEventListener(eventType: PHPEvent["type"], listener: PHPEventListener): void;
	/** @inheritDoc @php-wasm/universal!/PHP.removeEventListener */
	removeEventListener(eventType: PHPEvent["type"], listener: PHPEventListener): void;
}
/**
 * Represents an event related to the PHP request.
 */
export interface PHPRequestEndEvent {
	type: "request.end";
}
/**
 * Represents an error event related to the PHP request.
 */
export interface PHPRequestErrorEvent {
	type: "request.error";
	error: Error;
	source?: "request" | "php-wasm";
}
/**
 * Represents a PHP runtime initialization event.
 */
export interface PHPRuntimeInitializedEvent {
	type: "runtime.initialized";
}
/**
 * Represents a PHP runtime destruction event.
 */
export interface PHPRuntimeBeforeDestroyEvent {
	type: "runtime.beforedestroy";
}
/**
 * Represents an event related to the PHP instance.
 * This is intentionally not an extension of CustomEvent
 * to make it isomorphic between different JavaScript runtimes.
 */
export type PHPEvent = PHPRequestEndEvent | PHPRequestErrorEvent | PHPRuntimeInitializedEvent | PHPRuntimeBeforeDestroyEvent;
/**
 * A callback function that handles PHP events.
 */
export type PHPEventListener = (event: PHPEvent) => void;
export type UniversalPHP = LimitedPHPApi | Remote<LimitedPHPApi>;
export type MessageListener = (data: string) => Promise<string | Uint8Array | void> | string | void;
export interface EventEmitter {
	on(event: string, listener: (...args: any[]) => void): this;
	emit(event: string, ...args: any[]): boolean;
}
export type ChildProcess = EventEmitter & {
	stdout: EventEmitter;
	stderr: EventEmitter;
};
export type SpawnHandler = (command: string, args: string[]) => ChildProcess;
export type HTTPMethod = "GET" | "POST" | "HEAD" | "OPTIONS" | "PATCH" | "PUT" | "DELETE";
export type PHPRequestHeaders = Record<string, string>;
export interface PHPRequest {
	/**
	 * Request method. Default: `GET`.
	 */
	method?: HTTPMethod;
	/**
	 * Request path or absolute URL.
	 */
	url: string;
	/**
	 * Request headers.
	 */
	headers?: PHPRequestHeaders;
	/**
	 * Request body.
	 * If an object is given, the request will be encoded as multipart
	 * and sent with a `multipart/form-data` header.
	 */
	body?: string | Uint8Array | Record<string, string | Uint8Array | File>;
}
export interface PHPRunOptions {
	/**
	 * Request path following the domain:port part.
	 */
	relativeUri?: string;
	/**
	 * Path of the .php file to execute.
	 */
	scriptPath?: string;
	/**
	 * Request protocol.
	 */
	protocol?: string;
	/**
	 * Request method. Default: `GET`.
	 */
	method?: HTTPMethod;
	/**
	 * Request headers.
	 */
	headers?: PHPRequestHeaders;
	/**
	 * Request body.
	 */
	body?: string | Uint8Array;
	/**
	 * Environment variables to set for this run.
	 */
	env?: Record<string, string>;
	/**
	 * $_SERVER entries to set for this run.
	 */
	$_SERVER?: Record<string, string>;
	/**
	 * The code snippet to eval instead of a php file.
	 */
	code?: string;
}
/**
 * Output of the PHP.wasm runtime.
 */
export interface PHPOutput {
	/** Exit code of the PHP process. 0 means success, 1 and 2 mean error. */
	exitCode: number;
	/** Stdout data */
	stdout: ArrayBuffer;
	/** Stderr lines */
	stderr: string[];
}
/**
 * Rewrites the php.ini file with the given entries.
 *
 * @param php The PHP instance.
 * @param entries The entries to write to the php.ini file.
 */
export declare function setPhpIniEntries(php: UniversalPHP, entries: Record<string, unknown>): Promise<void>;
/**
 * Emscripten's filesystem-related Exception.
 *
 * @see https://emscripten.org/docs/api_reference/Filesystem-API.html
 * @see https://github.com/emscripten-core/emscripten/blob/main/system/lib/libc/musl/arch/emscripten/bits/errno.h
 * @see https://github.com/emscripten-core/emscripten/blob/38eedc630f17094b3202fd48ac0c2c585dbea31e/system/include/wasi/api.h#L336
 */
export interface ErrnoError extends Error {
	node?: any;
	errno: number;
	message: string;
}
export declare const SupportedPHPVersions: readonly [
	"8.3",
	"8.2",
	"8.1",
	"8.0",
	"7.4",
	"7.3",
	"7.2",
	"7.1",
	"7.0"
];
export declare const LatestSupportedPHPVersion: "8.3";
export declare const SupportedPHPVersionsList: string[];
export type SupportedPHPVersion = (typeof SupportedPHPVersions)[number];
export type SupportedPHPExtension = "iconv" | "mbstring" | "xml-bundle" | "gd";
export type SupportedPHPExtensionBundle = "kitchen-sink" | "light";
export declare const ResourceTypes: readonly [
	"vfs",
	"literal",
	"wordpress.org/themes",
	"wordpress.org/plugins",
	"url"
];
export type VFSReference = {
	/** Identifies the file resource as Virtual File System (VFS) */
	resource: "vfs";
	/** The path to the file in the VFS */
	path: string;
};
export type LiteralReference = {
	/** Identifies the file resource as a literal file */
	resource: "literal";
	/** The name of the file */
	name: string;
	/** The contents of the file */
	contents: string | Uint8Array;
};
export type CoreThemeReference = {
	/** Identifies the file resource as a WordPress Core theme */
	resource: "wordpress.org/themes";
	/** The slug of the WordPress Core theme */
	slug: string;
};
export type CorePluginReference = {
	/** Identifies the file resource as a WordPress Core plugin */
	resource: "wordpress.org/plugins";
	/** The slug of the WordPress Core plugin */
	slug: string;
};
export type UrlReference = {
	/** Identifies the file resource as a URL */
	resource: "url";
	/** The URL of the file */
	url: string;
	/** Optional caption for displaying a progress message */
	caption?: string;
};
export type FileReference = VFSReference | LiteralReference | CoreThemeReference | CorePluginReference | UrlReference;
export interface ResourceOptions {
	/** Optional semaphore to limit concurrent downloads */
	semaphore?: Semaphore;
	progress?: ProgressTracker;
}
export declare abstract class Resource {
	/** Optional progress tracker to monitor progress */
	abstract progress?: ProgressTracker;
	/** A Promise that resolves to the file contents */
	protected promise?: Promise<File>;
	protected playground?: UniversalPHP;
	/**
	 * Creates a new Resource based on the given file reference
	 *
	 * @param ref The file reference to create the Resource for
	 * @param options Additional options for the Resource
	 * @returns A new Resource instance
	 */
	static create(ref: FileReference, { semaphore, progress }: ResourceOptions): Resource;
	setPlayground(playground: UniversalPHP): void;
	/**
	 * Resolves the file contents
	 * @returns The resolved file.
	 */
	abstract resolve(): Promise<File>;
	/** The name of the referenced file */
	abstract get name(): string;
	/** Whether this Resource is loaded asynchronously */
	get isAsync(): boolean;
}
/**
 * A `Resource` that represents a file in the VFS (virtual file system) of the playground.
 */
export declare class VFSResource extends Resource {
	private resource;
	progress?: ProgressTracker | undefined;
	/**
	 * Creates a new instance of `VFSResource`.
	 * @param playground The playground client.
	 * @param resource The VFS reference.
	 * @param progress The progress tracker.
	 */
	constructor(resource: VFSReference, progress?: ProgressTracker | undefined);
	/** @inheritDoc */
	resolve(): Promise<File>;
	/** @inheritDoc */
	get name(): string;
}
/**
 * A `Resource` that represents a literal file.
 */
export declare class LiteralResource extends Resource {
	private resource;
	progress?: ProgressTracker | undefined;
	/**
	 * Creates a new instance of `LiteralResource`.
	 * @param resource The literal reference.
	 * @param progress The progress tracker.
	 */
	constructor(resource: LiteralReference, progress?: ProgressTracker | undefined);
	/** @inheritDoc */
	resolve(): Promise<File>;
	/** @inheritDoc */
	get name(): string;
}
/**
 * A base class for `Resource`s that require fetching data from a remote URL.
 */
export declare abstract class FetchResource extends Resource {
	progress?: ProgressTracker | undefined;
	/**
	 * Creates a new instance of `FetchResource`.
	 * @param progress The progress tracker.
	 */
	constructor(progress?: ProgressTracker | undefined);
	/** @inheritDoc */
	resolve(): Promise<File>;
	/**
	 * Gets the URL to fetch the data from.
	 * @returns The URL.
	 */
	protected abstract getURL(): string;
	/**
	 * Gets the caption for the progress tracker.
	 * @returns The caption.
	 */
	protected get caption(): string;
	/** @inheritDoc */
	get name(): string;
	/** @inheritDoc */
	get isAsync(): boolean;
}
/**
 * A `Resource` that represents a file available from a URL.
 */
export declare class UrlResource extends FetchResource {
	private resource;
	/**
	 * Creates a new instance of `UrlResource`.
	 * @param resource The URL reference.
	 * @param progress The progress tracker.
	 */
	constructor(resource: UrlReference, progress?: ProgressTracker);
	/** @inheritDoc */
	getURL(): string;
	/** @inheritDoc */
	protected get caption(): string;
}
/**
 * A `Resource` that represents a WordPress core theme.
 */
export declare class CoreThemeResource extends FetchResource {
	private resource;
	constructor(resource: CoreThemeReference, progress?: ProgressTracker);
	get name(): string;
	getURL(): string;
}
/**
 * A resource that fetches a WordPress plugin from wordpress.org.
 */
export declare class CorePluginResource extends FetchResource {
	private resource;
	constructor(resource: CorePluginReference, progress?: ProgressTracker);
	/** @inheritDoc */
	get name(): string;
	/** @inheritDoc */
	getURL(): string;
}
/**
 * A decorator for a resource that adds functionality such as progress tracking and caching.
 */
export declare class DecoratedResource<T extends Resource> extends Resource {
	private resource;
	constructor(resource: T);
	/** @inheritDoc */
	resolve(): Promise<File>;
	/** @inheritDoc */
	setPlayground(playground: UniversalPHP): Promise<void>;
	/** @inheritDoc */
	get progress(): ProgressTracker | undefined;
	/** @inheritDoc */
	set progress(value: ProgressTracker | undefined);
	/** @inheritDoc */
	get name(): string;
	/** @inheritDoc */
	get isAsync(): boolean;
}
/**
 * A decorator for a resource that adds caching functionality.
 */
export declare class CachedResource<T extends Resource> extends DecoratedResource<T> {
	protected promise?: Promise<File>;
	/** @inheritDoc */
	resolve(): Promise<File>;
}
/**
 * A decorator for a resource that adds concurrency control functionality through a semaphore.
 */
export declare class SemaphoreResource<T extends Resource> extends DecoratedResource<T> {
	private readonly semaphore;
	constructor(resource: T, semaphore: Semaphore);
	/** @inheritDoc */
	resolve(): Promise<File>;
}
/**
 * @inheritDoc activatePlugin
 * @example
 *
 * <code>
 * {
 * 		"step": "activatePlugin",
 * 		"pluginName": "Gutenberg",
 * 		"pluginPath": "/wordpress/wp-content/plugins/gutenberg"
 * }
 * </code>
 */
export interface ActivatePluginStep {
	step: "activatePlugin";
	/** Path to the plugin directory as absolute path (/wordpress/wp-content/plugins/plugin-name); or the plugin entry file relative to the plugins directory (plugin-name/plugin-name.php). */
	pluginPath: string;
	/** Optional. Plugin name to display in the progress bar. */
	pluginName?: string;
}
/**
 * Activates a WordPress plugin (if it's installed).
 *
 * @param playground The playground client.
 */
export declare const activatePlugin: StepHandler<ActivatePluginStep>;
/**
 * Changes the site URL of the WordPress installation.
 *
 * @inheritDoc defineSiteUrl
 */
export interface DefineSiteUrlStep {
	step: "defineSiteUrl";
	/** The URL */
	siteUrl: string;
}
/**
 * Sets [`WP_HOME`](https://developer.wordpress.org/advanced-administration/wordpress/wp-config/#blog-address-url) and [`WP_SITEURL`](https://developer.wordpress.org/advanced-administration/wordpress/wp-config/#wp-siteurl) constants for the WordPress installation.
 *
 * Using this step on playground.wordpress.net is moot.
 * It is useful when building a custom Playground-based tool, like [`wp-now`](https://www.npmjs.com/package/@wp-now/wp-now),
 * or deploying Playground on a custom domain.
 *
 * @param playground The playground client.
 * @param siteUrl
 */
export declare const defineSiteUrl: StepHandler<DefineSiteUrlStep>;
export interface InstallAssetOptions {
	/**
	 * The zip file to install.
	 */
	zipFile: File;
	/**
	 * Target path to extract the main folder.
	 * @example
	 *
	 * <code>
	 * const targetPath = `${await playground.documentRoot}/wp-content/plugins`;
	 * </code>
	 */
	targetPath: string;
	/**
	 * What to do if the asset already exists.
	 */
	ifAlreadyInstalled?: "overwrite" | "skip" | "error";
}
/**
 * @inheritDoc installPlugin
 * @hasRunnableExample
 * @needsLogin
 * @landingPage /wp-admin/plugins.php
 * @example
 *
 * <code>
 * {
 * 	    "step": "installPlugin",
 * 		"pluginZipFile": {
 * 			"resource": "wordpress.org/plugins",
 * 			"slug": "gutenberg"
 * 		},
 * 		"options": {
 * 			"activate": true
 * 		}
 * }
 * </code>
 */
export interface InstallPluginStep<ResourceType> extends Pick<InstallAssetOptions, "ifAlreadyInstalled"> {
	/**
	 * The step identifier.
	 */
	step: "installPlugin";
	/**
	 * The plugin zip file to install.
	 */
	pluginZipFile: ResourceType;
	/**
	 * Optional installation options.
	 */
	options?: InstallPluginOptions;
}
export interface InstallPluginOptions {
	/**
	 * Whether to activate the plugin after installing it.
	 */
	activate?: boolean;
}
/**
 * Installs a WordPress plugin in the Playground.
 *
 * @param playground The playground client.
 * @param pluginZipFile The plugin zip file.
 * @param options Optional. Set `activate` to false if you don't want to activate the plugin.
 */
export declare const installPlugin: StepHandler<InstallPluginStep<File>>;
/**
 * @inheritDoc installTheme
 * @hasRunnableExample
 * @needsLogin
 * @example
 *
 * <code>
 * {
 * 		"step": "installTheme",
 * 		"themeZipFile": {
 * 			"resource": "wordpress.org/themes",
 * 			"slug": "pendant"
 * 		},
 * 		"options": {
 * 			"activate": true
 * 		}
 * }
 * </code>
 */
export interface InstallThemeStep<ResourceType> extends Pick<InstallAssetOptions, "ifAlreadyInstalled"> {
	/**
	 * The step identifier.
	 */
	step: "installTheme";
	/**
	 * The theme zip file to install.
	 */
	themeZipFile: ResourceType;
	/**
	 * Optional installation options.
	 */
	options?: {
		/**
		 * Whether to activate the theme after installing it.
		 */
		activate?: boolean;
	};
}
export interface InstallThemeOptions {
	/**
	 * Whether to activate the theme after installing it.
	 */
	activate?: boolean;
}
/**
 * Installs a WordPress theme in the Playground.
 *
 * @param playground The playground client.
 * @param themeZipFile The theme zip file.
 * @param options Optional. Set `activate` to false if you don't want to activate the theme.
 */
export declare const installTheme: StepHandler<InstallThemeStep<File>>;
/**
 * @inheritDoc login
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 * 	    "step": "login",
 * 		"username": "admin",
 * 		"password": "password"
 * }
 * </code>
 */
export type LoginStep = {
	step: "login";
	/**
	 * The user to log in as. Defaults to 'admin'.
	 */
	username?: string;
	/**
	 * The password to log in with. Defaults to 'password'.
	 */
	password?: string;
};
/**
 * Logs in to Playground.
 * Under the hood, this function submits the [`wp-login.php`](https://developer.wordpress.org/reference/files/wp-login.php/) [form](https://developer.wordpress.org/reference/functions/wp_login_form/)
 * just like a user would.
 */
export declare const login: StepHandler<LoginStep>;
/**
 * @private
 */
export interface RunWpInstallationWizardStep {
	step: "runWpInstallationWizard";
	options: WordPressInstallationOptions;
}
export interface WordPressInstallationOptions {
	adminUsername?: string;
	adminPassword?: string;
}
/**
 * Installs WordPress
 *
 * @param playground The playground client.
 * @param options Installation options.
 */
export declare const runWpInstallationWizard: StepHandler<RunWpInstallationWizardStep>;
/**
 * @inheritDoc setSiteOptions
 * @hasRunnableExample
 *
 * @example
 *
 * <code>
 * {
 *     "step": "setSiteOptions",
 *     "options": {
 *         "blogname": "My Blog",
 *         "blogdescription": "A great blog"
 *     }
 * }
 * </code>
 */
export type SetSiteOptionsStep = {
	/** The name of the step. Must be "setSiteOptions". */
	step: "setSiteOptions";
	/** The options to set on the site. */
	options: Record<string, unknown>;
};
/**
 * Sets site options. This is equivalent to calling [`update_option`](https://developer.wordpress.org/reference/functions/update_option/) for each
 * option in the [`options`](https://developer.wordpress.org/apis/options/#available-options-by-category) object.
 */
export declare const setSiteOptions: StepHandler<SetSiteOptionsStep>;
/**
 * @inheritDoc updateUserMeta
 * @hasRunnableExample
 *
 * @example
 *
 * <code>
 * {
 *     "step": "updateUserMeta",
 *     "meta": {
 * 	       "first_name": "John",
 * 	       "last_name": "Doe"
 *     },
 *     "userId": 1
 * }
 * </code>
 */
export interface UpdateUserMetaStep {
	step: "updateUserMeta";
	/** An object of user meta values to set, e.g. { "first_name": "John" } */
	meta: Record<string, unknown>;
	/** User ID */
	userId: number;
}
/**
 * Updates user meta. This is equivalent to calling [`update_user_meta`](https://developer.wordpress.org/reference/functions/update_user_meta/) for each
 * meta value in the `meta` object.
 */
export declare const updateUserMeta: StepHandler<UpdateUserMetaStep>;
/**
 * @inheritDoc rm
 * @hasRunnableExample
 * @landingPage /index.php
 * @example
 *
 * <code>
 * {
 * 		"step": "rm",
 * 		"path": "/wordpress/index.php"
 * }
 * </code>
 */
export interface RmStep {
	step: "rm";
	/** The path to remove */
	path: string;
}
/**
 * Removes a file at the specified path.
 */
export declare const rm: StepHandler<RmStep>;
/**
 * @inheritDoc cp
 * @hasRunnableExample
 * @landingPage /index2.php
 * @example
 *
 * <code>
 * {
 * 		"step": "cp",
 * 		"fromPath": "/wordpress/index.php",
 * 		"toPath": "/wordpress/index2.php"
 * }
 * </code>
 */
export interface CpStep {
	step: "cp";
	/** Source path */
	fromPath: string;
	/** Target path */
	toPath: string;
}
/**
 * Copies a file from one path to another.
 */
export declare const cp: StepHandler<CpStep>;
/**
 * @inheritDoc rmdir
 * @hasRunnableExample
 * @landingPage /wp-admin/
 * @example
 *
 * <code>
 * {
 * 		"step": "rmdir",
 * 		"path": "/wordpress/wp-admin"
 * }
 * </code>
 */
export interface RmdirStep {
	step: "rmdir";
	/** The path to remove */
	path: string;
}
/**
 * Removes a directory at the specified path.
 */
export declare const rmdir: StepHandler<RmdirStep>;
/**
 * @inheritDoc runSql
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 *		"step": "runSql",
 *		"sql": {
 *			"resource": "literal",
 *			"name": "schema.sql",
 *			"contents": "DELETE FROM wp_posts"
 *		}
 * }
 * </code>
 */
export interface RunSqlStep<ResourceType> {
	/**
	 * The step identifier.
	 */
	step: "runSql";
	/**
	 * The SQL to run. Each non-empty line must contain a valid SQL query.
	 */
	sql: ResourceType;
}
/**
 * Run one or more SQL queries.
 *
 * This step will treat each non-empty line in the input SQL as a query and
 * try to execute it using `$wpdb`. Queries spanning multiple lines are not
 * yet supported.
 */
export declare const runSql: StepHandler<RunSqlStep<File>>;
/**
 * @inheritDoc mkdir
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 * 		"step": "mkdir",
 * 		"path": "/wordpress/my-new-folder"
 * }
 * </code>
 */
export interface MkdirStep {
	step: "mkdir";
	/** The path of the directory you want to create */
	path: string;
}
/**
 * Creates a directory at the specified path.
 */
export declare const mkdir: StepHandler<MkdirStep>;
/**
 * @inheritDoc mv
 * @hasRunnableExample
 * @landingPage /index2.php
 * @example
 *
 * <code>
 * {
 * 		"step": "mv",
 * 		"fromPath": "/wordpress/index.php",
 * 		"toPath": "/wordpress/index2.php"
 * }
 * </code>
 */
export interface MvStep {
	step: "mv";
	/** Source path */
	fromPath: string;
	/** Target path */
	toPath: string;
}
/**
 * Moves a file or directory from one path to another.
 */
export declare const mv: StepHandler<MvStep>;
/**
 * @inheritDoc runPHP
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 * 		"step": "runPHP",
 * 		"code": "<?php require_once 'wordpress/wp-load.php'; wp_insert_post(array('post_title' => 'wp-load.php required for WP functionality', 'post_status' => 'publish')); ?>"
 * }
 * </code>
 */
export interface RunPHPStep {
	/** The step identifier. */
	step: "runPHP";
	/** The PHP code to run. */
	code: string;
}
/**
 * Runs PHP code.
 * When running WordPress functions, the `code` key must first load [`wp-load.php`](https://github.com/WordPress/WordPress/blob/master/wp-load.php) and start with `"<?php require_once 'wordpress/wp-load.php'; "`.
 */
export declare const runPHP: StepHandler<RunPHPStep, Promise<PHPResponse>>;
/**
 * @inheritDoc runPHP
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 * 		"step": "runPHP",
 * 		"options": {
 * 			"code": "<?php echo $_SERVER['CONTENT_TYPE']; ?>",
 * 			"headers": {
 * 				"Content-type": "text/plain"
 * 			}
 * 		}
 * }
 * </code>
 */
export interface RunPHPWithOptionsStep {
	step: "runPHPWithOptions";
	/**
	 * Run options (See /wordpress-playground/api/universal/interface/PHPRunOptions/))
	 */
	options: PHPRunOptions;
}
/**
 * Runs PHP code with the given options.
 */
export declare const runPHPWithOptions: StepHandler<RunPHPWithOptionsStep>;
/**
 * @private
 * @inheritDoc request
 * @needsLogin
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 * 		"step": "request",
 * 		"request": {
 * 			"method": "POST",
 * 			"url": "/wp-admin/admin-ajax.php",
 * 			"formData": {
 * 				"action": "my_action",
 * 				"foo": "bar"
 * 			}
 * 		}
 * }
 * </code>
 */
export interface RequestStep {
	step: "request";
	/**
	 * Request details (See /wordpress-playground/api/universal/interface/PHPRequest)
	 */
	request: PHPRequest;
}
/**
 * Sends a HTTP request to Playground.
 */
export declare const request: StepHandler<RequestStep, Promise<PHPResponse>>;
/**
 * @inheritDoc writeFile
 * @hasRunnableExample
 * @landingPage /test.php
 * @example
 *
 * <code>
 * {
 * 		"step": "writeFile",
 * 		"path": "/wordpress/test.php",
 * 		"data": "<?php echo 'Hello World!'; ?>"
 * }
 * </code>
 */
export interface WriteFileStep<ResourceType> {
	step: "writeFile";
	/** The path of the file to write to */
	path: string;
	/** The data to write */
	data: ResourceType | string | Uint8Array;
}
/**
 * Writes data to a file at the specified path.
 */
export declare const writeFile: StepHandler<WriteFileStep<File>>;
/**
 * @inheritDoc defineWpConfigConsts
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 * 		"step": "defineWpConfigConsts",
 * 		"consts": {
 *          "WP_DEBUG": true
 *      }
 * }
 * </code>
 */
export interface DefineWpConfigConstsStep {
	step: "defineWpConfigConsts";
	/** The constants to define */
	consts: Record<string, unknown>;
	/**
	 * The method of defining the constants in wp-config.php. Possible values are:
	 *
	 * - rewrite-wp-config: Default. Rewrites the wp-config.php file to
	 *                      explicitly call define() with the requested
	 *                      name and value. This method alters the file
	 *                      on the disk, but it doesn't conflict with
	 *                      existing define() calls in wp-config.php.
	 *
	 * - define-before-run: Defines the constant before running the requested
	 *                      script. It doesn't alter any files on the disk, but
	 *                      constants defined this way may conflict with existing
	 *                      define() calls in wp-config.php.
	 */
	method?: "rewrite-wp-config" | "define-before-run";
	/**
	 * @deprecated This option is noop and will be removed in a future version.
	 * This option is only kept in here to avoid breaking Blueprint schema validation
	 * for existing apps using this option.
	 */
	virtualize?: boolean;
}
/**
 * Defines constants in a [`wp-config.php`](https://developer.wordpress.org/advanced-administration/wordpress/wp-config/) file.
 *
 * This step can be called multiple times, and the constants will be merged.
 *
 * @param playground The playground client.
 * @param wpConfigConst
 */
export declare const defineWpConfigConsts: StepHandler<DefineWpConfigConstsStep>;
/**
 * @inheritDoc activateTheme
 * @example
 *
 * <code>
 * {
 * 		"step": "activateTheme",
 * 		"themeFolderName": "storefront"
 * }
 * </code>
 */
export interface ActivateThemeStep {
	step: "activateTheme";
	/**
	 * The name of the theme folder inside wp-content/themes/
	 */
	themeFolderName: string;
}
/**
 * Activates a WordPress theme (if it's installed).
 *
 * @param playground The playground client.
 * @param themeFolderName The theme folder name.
 */
export declare const activateTheme: StepHandler<ActivateThemeStep>;
/**
 * @inheritDoc unzip
 * @example
 *
 * <code>
 * {
 * 		"step": "unzip",
 * 		"zipFile": {
 * 			"resource": "vfs",
 * 			"path": "/wordpress/data.zip"
 * 		},
 * 		"extractToPath": "/wordpress"
 * }
 * </code>
 */
export interface UnzipStep<ResourceType> {
	step: "unzip";
	/** The zip file to extract */
	zipFile?: ResourceType;
	/**
	 * The path of the zip file to extract
	 * @deprecated Use zipFile instead.
	 */
	zipPath?: string;
	/** The path to extract the zip file to */
	extractToPath: string;
}
/**
 * Unzip a zip file.
 *
 * @param playground Playground client.
 * @param zipPath The zip file to unzip.
 * @param extractTo The directory to extract the zip file to.
 */
export declare const unzip: StepHandler<UnzipStep<File>>;
/**
 * @inheritDoc importWordPressFiles
 * @example
 *
 * <code>
 * {
 * 		"step": "importWordPressFiles",
 * 		"wordPressFilesZip": {
 * 			"resource": "url",
 * 			"url": "https://mysite.com/import.zip"
 *  	}
 * }
 * </code>
 */
export interface ImportWordPressFilesStep<ResourceType> {
	step: "importWordPressFiles";
	/**
	 * The zip file containing the top-level WordPress files and
	 * directories.
	 */
	wordPressFilesZip: ResourceType;
	/**
	 * The path inside the zip file where the WordPress files are.
	 */
	pathInZip?: string;
}
/**
 * Imports top-level WordPress files from a given zip file into
 * the `documentRoot`. For example, if a zip file contains the
 * `wp-content` and `wp-includes` directories, they will replace
 * the corresponding directories in Playground's `documentRoot`.
 *
 * Any files that Playground recognizes as "excluded from the export"
 * will carry over from the existing document root into the imported
 * directories. For example, the sqlite-database-integration plugin.
 *
 * @param playground Playground client.
 * @param wordPressFilesZip Zipped WordPress site.
 */
export declare const importWordPressFiles: StepHandler<ImportWordPressFilesStep<File>>;
/**
 * @inheritDoc importWxr
 * @example
 *
 * <code>
 * {
 * 		"step": "importWxr",
 * 		"file": {
 * 			"resource": "url",
 * 			"url": "https://your-site.com/starter-content.wxr"
 * 		}
 * }
 * </code>
 */
export interface ImportWxrStep<ResourceType> {
	step: "importWxr";
	/** The file to import */
	file: ResourceType;
}
/**
 * Imports a WXR file into WordPress.
 *
 * @param playground Playground client.
 * @param file The file to import.
 */
export declare const importWxr: StepHandler<ImportWxrStep<File>>;
/**
 * @inheritDoc enableMultisite
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 * 		"step": "enableMultisite"
 * }
 * </code>
 */
export interface EnableMultisiteStep {
	step: "enableMultisite";
}
/**
 * Defines the [Multisite](https://developer.wordpress.org/advanced-administration/multisite/create-network/) constants in a `wp-config.php` file.
 *
 * This step can be called multiple times, and the constants will be merged.
 *
 * @param playground The playground client.
 * @param enableMultisite
 */
export declare const enableMultisite: StepHandler<EnableMultisiteStep>;
/**
 * @inheritDoc wpCLI
 * @hasRunnableExample
 * @example
 *
 * <code>
 * {
 * 		"step": "wp-cli",
 * 		"command": "wp post create --post_title='Test post' --post_excerpt='Some content'"
 * }
 * </code>
 */
export interface WPCLIStep {
	/** The step identifier. */
	step: "wp-cli";
	/** The WP CLI command to run. */
	command: string | string[];
	/** wp-cli.phar path */
	wpCliPath?: string;
}
/**
 * Runs PHP code using [WP-CLI](https://developer.wordpress.org/cli/commands/).
 */
export declare const wpCLI: StepHandler<WPCLIStep, Promise<PHPResponse>>;
/**
 * Deletes WordPress posts and comments and sets the auto increment sequence for the
 * posts and comments tables to 0.
 *
 * @private
 * @internal
 * @inheritDoc resetData
 * @example
 *
 * <code>
 * {
 * 		"step": "resetData"
 * }
 * </code>
 */
export interface ResetDataStep {
	step: "resetData";
}
/**
 * @param playground Playground client.
 */
export declare const resetData: StepHandler<ResetDataStep>;
/**
 * Used by the export step to exclude the Playground-specific files
 * from the zip file. Keep it in sync with the list of files created
 * by WordPressPatcher.
 */
export declare const wpContentFilesExcludedFromExport: string[];
export type Step = GenericStep<FileReference>;
export type StepDefinition = Step & {
	progress?: {
		weight?: number;
		caption?: string;
	};
};
/**
 * If you add a step here, make sure to also
 * add it to the exports below.
 */
export type GenericStep<Resource> = ActivatePluginStep | ActivateThemeStep | CpStep | DefineWpConfigConstsStep | DefineSiteUrlStep | EnableMultisiteStep | ImportWxrStep<Resource> | ImportWordPressFilesStep<Resource> | InstallPluginStep<Resource> | InstallThemeStep<Resource> | LoginStep | MkdirStep | MvStep | ResetDataStep | RequestStep | RmStep | RmdirStep | RunPHPStep | RunPHPWithOptionsStep | RunWpInstallationWizardStep | RunSqlStep<Resource> | SetSiteOptionsStep | UnzipStep<Resource> | UpdateUserMetaStep | WriteFileStep<Resource> | WPCLIStep;
/**
 * Progress reporting details.
 */
export type StepProgress = {
	tracker: ProgressTracker;
	initialCaption?: string;
};
export type StepHandler<S extends GenericStep<File>, Return = any> = (
/**
 * A PHP instance or Playground client.
 */
php: UniversalPHP, args: Omit<S, "step">, progressArgs?: StepProgress) => Return;
/**
 * Exports the WordPress database as a WXR file using
 * the core WordPress export tool.
 *
 * @param playground Playground client
 * @returns WXR file
 */
export declare function exportWXR(playground: UniversalPHP): Promise<File>;
export interface ZipWpContentOptions {
	/**
	 * @private
	 * A temporary workaround to enable including the WordPress default theme
	 * in the exported zip file.
	 */
	selfContained?: boolean;
}
/**
 * Replace the current wp-content directory with one from the provided zip file.
 *
 * @param playground Playground client.
 * @param wpContentZip Zipped WordPress site.
 */
export declare const zipWpContent: (playground: UniversalPHP, { selfContained }?: ZipWpContentOptions) => Promise<Uint8Array>;
export interface Blueprint {
	/**
	 * The URL to navigate to after the blueprint has been run.
	 */
	landingPage?: string;
	/**
	 * Optional description. It doesn't do anything but is exposed as
	 * a courtesy to developers who may want to document which blueprint
	 * file does what.
	 *
	 * @deprecated Use meta.description instead.
	 */
	description?: string;
	/**
	 * Optional metadata. Used by the Blueprints gallery at https://github.com/WordPress/blueprints
	 */
	meta?: {
		/**
		 * A clear and concise name for your Blueprint.
		 */
		title: string;
		/**
		 * A brief explanation of what your Blueprint offers.
		 */
		description?: string;
		/**
		 * A GitHub username of the author of this Blueprint.
		 */
		author: string;
		/**
		 * Relevant categories to help users find your Blueprint in the future Blueprints section on WordPress.org.
		 */
		categories?: string[];
	};
	/**
	 * The preferred PHP and WordPress versions to use.
	 */
	preferredVersions?: {
		/**
		 * The preferred PHP version to use.
		 * If not specified, the latest supported version will be used
		 */
		php: SupportedPHPVersion | "latest";
		/**
		 * The preferred WordPress version to use.
		 * If not specified, the latest supported version will be used
		 */
		wp: string | "latest";
	};
	features?: {
		/** Should boot with support for network request via wp_safe_remote_get? */
		networking?: boolean;
	};
	/**
	 * PHP Constants to define on every request
	 * @deprecated This experimental option will change without warning.
	 *             Use `steps` instead.
	 */
	constants?: Record<string, string>;
	/**
	 * WordPress plugins to install and activate
	 * @deprecated This experimental option will change without warning.
	 *             Use `steps` instead.
	 */
	plugins?: Array<string | FileReference>;
	/**
	 * WordPress site options to define
	 * @deprecated This experimental option will change without warning.
	 *             Use `steps` instead.
	 */
	siteOptions?: Record<string, string> & {
		/** The site title */
		blogname?: string;
	};
	/**
	 * User to log in as.
	 * If true, logs the user in as admin/password.
	 */
	login?: boolean | {
		username: string;
		password: string;
	};
	/**
	 * The PHP extensions to use.
	 */
	phpExtensionBundles?: SupportedPHPExtensionBundle[];
	/**
	 * The steps to run after every other operation in this Blueprint was
	 * executed.
	 */
	steps?: Array<StepDefinition | string | undefined | false | null>;
}
export type CompiledStep = (php: UniversalPHP) => Promise<void> | void;
export interface CompiledBlueprint {
	/** The requested versions of PHP and WordPress for the blueprint */
	versions: {
		php: SupportedPHPVersion;
		wp: string;
	};
	/** The requested PHP extensions to load */
	phpExtensions: SupportedPHPExtension[];
	features: {
		/** Should boot with support for network request via wp_safe_remote_get? */
		networking: boolean;
	};
	/** The compiled steps for the blueprint */
	run: (playground: UniversalPHP) => Promise<void>;
}
export type OnStepCompleted = (output: any, step: StepDefinition) => any;
export interface CompileBlueprintOptions {
	/** Optional progress tracker to monitor progress */
	progress?: ProgressTracker;
	/** Optional semaphore to control access to a shared resource */
	semaphore?: Semaphore;
	/** Optional callback with step output */
	onStepCompleted?: OnStepCompleted;
}
/**
 * Compiles Blueprint into a form that can be executed.
 *
 * @param playground The PlaygroundClient to use for the compilation
 * @param blueprint The bBueprint to compile
 * @param options Additional options for the compilation
 * @returns The compiled blueprint
 */
export declare function compileBlueprint(blueprint: Blueprint, { progress, semaphore, onStepCompleted, }?: CompileBlueprintOptions): CompiledBlueprint;
export declare function runBlueprintSteps(compiledBlueprint: CompiledBlueprint, playground: UniversalPHP): Promise<void>;
/**
 * @deprecated This function is a no-op. Playground no longer uses a proxy to download plugins and themes.
 *             To be removed in v0.3.0
 */
export declare function setPluginProxyURL(): void;
export type WithAPIState = {
	/**
	 * Resolves to true when the remote API is ready for
	 * Comlink communication, but not necessarily fully initialized yet.
	 */
	isConnected: () => Promise<void>;
	/**
	 * Resolves to true when the remote API is declares it's
	 * fully loaded and ready to be used.
	 */
	isReady: () => Promise<void>;
};
export type RemoteAPI<T> = Comlink.Remote<T> & WithAPIState;
export interface MountOptions {
	initialSync: {
		direction?: "opfs-to-memfs" | "memfs-to-opfs";
		onProgress?: SyncProgressCallback;
	};
}
export type SyncProgress = {
	/** The number of files that have been synced. */
	files: number;
	/** The number of all files that need to be synced. */
	total: number;
};
export type SyncProgressCallback = (progress: SyncProgress) => void;
export type BindOpfsOptions = {
	php: PHP;
	opfs: FileSystemDirectoryHandle;
	initialSyncDirection?: MountOptions["initialSync"]["direction"];
	onProgress?: SyncProgressCallback;
	mountpoint: string;
};
/**
 * Represents the type of node in PHP file system.
 */
export type FSNodeType = "file" | "directory";
/**
 * Represents an update operation on a file system node.
 */
export type UpdateFileOperation = {
	/** The type of operation being performed. */
	operation: "WRITE";
	/** The path of the node being updated. */
	path: string;
	/** Optional. The new contents of the file. */
	data?: Uint8Array;
	nodeType: "file";
};
/**
 * Represents a directory operation.
 */
export type CreateOperation = {
	/** The type of operation being performed. */
	operation: "CREATE";
	/** The path of the node being created. */
	path: string;
	/** The type of the node being created. */
	nodeType: FSNodeType;
};
export type DeleteOperation = {
	/** The type of operation being performed. */
	operation: "DELETE";
	/** The path of the node being updated. */
	path: string;
	/** The type of the node being updated. */
	nodeType: FSNodeType;
};
/**
 * Represents a rename operation on a file or directory in PHP file system.
 */
export type RenameOperation = {
	/** The type of operation being performed. */
	operation: "RENAME";
	/** The original path of the file or directory being renamed. */
	path: string;
	/** The new path of the file or directory after the rename operation. */
	toPath: string;
	/** The type of node being renamed (file or directory). */
	nodeType: FSNodeType;
};
export type FilesystemOperation = CreateOperation | UpdateFileOperation | DeleteOperation | RenameOperation;
declare class PlaygroundWorkerEndpoint extends PHPWorker {
	/**
	 * A string representing the scope of the Playground instance.
	 */
	scope: string;
	/**
	 * A string representing the version of WordPress being used.
	 */
	wordPressVersion: string;
	constructor(monitor: EmscriptenDownloadMonitor, scope: string, wordPressVersion: string);
	/**
	 * @returns WordPress module details, including the static assets directory and default theme.
	 */
	getWordPressModuleDetails(): Promise<{
		majorVersion: string;
		staticAssetsDirectory: string;
	}>;
	getSupportedWordPressVersions(): Promise<{
		all: {
			nightly: string;
			beta: string;
			"6.5": string;
			"6.4": string;
			"6.3": string;
			"6.2": string;
		};
		latest: string;
	}>;
	resetVirtualOpfs(): Promise<void>;
	reloadFilesFromOpfs(): Promise<void>;
	bindOpfs(options: Omit<BindOpfsOptions, "php" | "onProgress">, onProgress?: SyncProgressCallback): Promise<void>;
	journalFSEvents(root: string, callback: (op: FilesystemOperation) => void): Promise<() => any>;
	replayFSJournal(events: FilesystemOperation[]): Promise<void>;
}
export interface ProgressBarOptions {
	caption?: string;
	progress?: number;
	isIndefinite?: boolean;
	visible?: boolean;
}
export interface WebClientMixin extends ProgressReceiver {
	/**
	 * Sets the progress bar options.
	 * @param options The progress bar options.
	 */
	setProgress(options: ProgressBarOptions): Promise<void>;
	/**
	 * Sets the loaded state.
	 */
	setLoaded(): Promise<void>;
	/**
	 * Sets the navigation event listener.
	 * @param fn The function to be called when a navigation event occurs.
	 */
	onNavigation(fn: (url: string) => void): Promise<void>;
	/**
	 * Navigates to the requested path.
	 * @param requestedPath The requested path.
	 */
	goTo(requestedPath: string): Promise<void>;
	/**
	 * Gets the current URL.
	 */
	getCurrentURL(): Promise<string>;
	/**
	 * Sets the iframe sandbox flags.
	 * @param flags The iframe sandbox flags.
	 */
	setIframeSandboxFlags(flags: string[]): Promise<void>;
	/**
	 * The onDownloadProgress event listener.
	 */
	onDownloadProgress: PlaygroundWorkerEndpoint["onDownloadProgress"];
	journalFSEvents: PlaygroundWorkerEndpoint["journalFSEvents"];
	replayFSJournal: PlaygroundWorkerEndpoint["replayFSJournal"];
	addEventListener: PlaygroundWorkerEndpoint["addEventListener"];
	removeEventListener: PlaygroundWorkerEndpoint["removeEventListener"];
	/** @inheritDoc @php-wasm/universal!UniversalPHP.onMessage */
	onMessage: PlaygroundWorkerEndpoint["onMessage"];
	bindOpfs(options: Omit<BindOpfsOptions, "php" | "onProgress">, onProgress?: SyncProgressCallback): Promise<void>;
}
/**
 * The Playground Client interface.
 */
export interface PlaygroundClient extends RemoteAPI<PlaygroundWorkerEndpoint & WebClientMixin> {
}
export interface StartPlaygroundOptions {
	iframe: HTMLIFrameElement;
	remoteUrl: string;
	progressTracker?: ProgressTracker;
	disableProgressBar?: boolean;
	blueprint?: Blueprint;
	onBlueprintStepCompleted?: OnStepCompleted;
	/**
	 * Called when the playground client is connected, but before the blueprint
	 * steps are run.
	 *
	 * @param playground
	 * @returns
	 */
	onClientConnected?: (playground: PlaygroundClient) => void;
	/**
	 * The SAPI name PHP will use.
	 * @internal
	 * @private
	 */
	sapiName?: string;
	/**
	 * Called before the blueprint steps are run,
	 * allows the caller to delay the Blueprint execution
	 * once the Playground is booted.
	 *
	 * @returns
	 */
	onBeforeBlueprint?: () => Promise<void>;
	siteSlug?: string;
}
/**
 * Loads playground in iframe and returns a PlaygroundClient instance.
 *
 * @param iframe Any iframe with Playground's remote.html loaded.
 * @param options Options for loading the playground.
 * @returns A PlaygroundClient instance.
 */
export declare function startPlaygroundWeb({ iframe, blueprint, remoteUrl, progressTracker, disableProgressBar, onBlueprintStepCompleted, onClientConnected, sapiName, onBeforeBlueprint, siteSlug, }: StartPlaygroundOptions): Promise<PlaygroundClient>;
/**
 * @deprecated Use `startPlayground` instead.
 *
 * @param iframe Any iframe with Playground's remote.html loaded.
 * @param options Optional. If `loadRemote` is set, the iframe's `src` will be set to that URL.
 *                In other words, use this option if your iframe doesn't have remote.html already
 * 				  loaded.
 */
export declare function connectPlayground(iframe: HTMLIFrameElement, options?: {
	loadRemote?: string;
}): Promise<PlaygroundClient>;

export {};
